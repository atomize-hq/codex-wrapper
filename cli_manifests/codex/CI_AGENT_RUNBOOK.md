# Codex CLI Parity: CI Agent Runbook (Using Generated Artifacts)

This document tells an automated agent (or a human) how to use the generated parity artifacts under `cli_manifests/codex/` to bring the Rust wrapper (`crates/codex`) into parity with a specific upstream Codex CLI version.

## Inputs (generated by CI)

For a given upstream version `V`:

- **Union snapshot (authoritative upstream surface inventory)**  
  `cli_manifests/codex/snapshots/V/union.json`

- **Coverage reports (work queue)**  
  `cli_manifests/codex/reports/V/coverage.any.json`  
  `cli_manifests/codex/reports/V/coverage.<target_triple>.json`  
  `cli_manifests/codex/reports/V/coverage.all.json` (only if `union.complete=true`)

- **Wrapper coverage manifest (generated; do not hand-edit)**  
  `cli_manifests/codex/wrapper_coverage.json`

- **Wrapper coverage source of truth (edit this)**  
  `crates/codex/src/wrapper_coverage_manifest.rs`

Baseline comparison:

- `BASELINE="$(cat cli_manifests/codex/latest_validated.txt)"`
- `cli_manifests/codex/snapshots/$BASELINE/union.json`
- `cli_manifests/codex/reports/$BASELINE/coverage.any.json`

## Outputs (what you change)

You bring the wrapper “to spec” by changing:

- `crates/codex/` code (new APIs, flag wiring, request structs, parsing, etc.)
- `crates/codex/src/wrapper_coverage_manifest.rs` (coverage declarations)

Then you regenerate:

- `cli_manifests/codex/wrapper_coverage.json`
- `cli_manifests/codex/reports/V/**`
- optionally `cli_manifests/codex/versions/V.json` (status/coverage computed fields)

Do not hand-edit generated JSON unless you are fixing a generator bug.

## How To Read The Work Queue (`coverage.*.json`)

The report is a deterministic diff between:
- upstream union snapshot surfaces, and
- wrapper coverage declarations.

Work the report fields in this order:

1) `deltas.missing_commands`
2) `deltas.missing_flags`
3) `deltas.missing_args`
4) `deltas.unsupported` (if present)
5) `deltas.passthrough_candidates` (if present; optional “promotion” work)
6) `deltas.intentionally_unsupported` (if present; audit/review of explicitly waived or inherited IU surfaces)

Each entry contains:
- `path`: command path tokens (`[]` means root command)
- `upstream_available_on`: targets where the surface exists
- `wrapper_level`: `null|unknown|unsupported|passthrough|explicit|intentionally_unsupported`
- `note`: rationale (required for `intentionally_unsupported`)

## Coverage Level Policy (what to choose)

For each upstream surface (command/flag/arg), choose one:

- `explicit`: there is a first-class wrapper API (typed request/response or dedicated method).
- `passthrough`: wrapper can only drive it through generic forwarding (weak support).
- `intentionally_unsupported`: we deliberately do not support it. Must include a non-empty `note`.
- `unsupported` / `unknown`: treated as “work not done yet” and should be eliminated before claiming support.

Validator rule: any `intentionally_unsupported` entry (command/flag/arg) requires a rationale note.

## Operating Loop (single version V)

### 0) Determine what changed vs baseline

Compute “new” and “removed” command surfaces by comparing union snapshots:

```bash
V="0.91.0"
BASELINE="$(cat cli_manifests/codex/latest_validated.txt)"

jq -r '.commands[].path | if length==0 then "<root>" else join(" ") end' \
  "cli_manifests/codex/snapshots/${BASELINE}/union.json" | sort > /tmp/cmds.baseline.txt
jq -r '.commands[].path | if length==0 then "<root>" else join(" ") end' \
  "cli_manifests/codex/snapshots/${V}/union.json" | sort > /tmp/cmds.new.txt

echo "Only in baseline:"
comm -23 /tmp/cmds.baseline.txt /tmp/cmds.new.txt
echo "Only in new version:"
comm -13 /tmp/cmds.baseline.txt /tmp/cmds.new.txt
```

Repeat the same idea for flags/args by emitting stable keys like:
- `<command_path>\t<flag.key>`
- `<command_path>\t<arg.name>`

### 1) Implement or waive each missing surface

For each entry in `coverage.<filter>.json` that is missing/unknown/unsupported:

Option A: implement wrapper support
- Add or update wrapper APIs in `crates/codex/src/lib.rs` (and supporting structs/types).
- Ensure flags/args are forwarded correctly and are testable.
- Update `crates/codex/src/wrapper_coverage_manifest.rs` to mark the surface as `explicit` (or `passthrough` when appropriate).

Option B: intentionally waive
- In `crates/codex/src/wrapper_coverage_manifest.rs`, add a matching entry with:
  - `level: intentionally_unsupported`
  - `note: Some("...")` (must be non-empty)
  - keep the note stable and policy-based (avoid churn).

Subtree waivers (ADR 0004):
- If an entire command family is intentionally unwrapped (e.g. `codex completion ...`), prefer marking the *parent command* as `intentionally_unsupported` with a stable rationale note.
- After ADR 0004 is implemented, `xtask codex-report` will treat descendant commands/flags/args as `intentionally_unsupported` by inheritance unless explicitly overridden by an exact wrapper coverage entry.
- In reports, inherited IU entries appear under `deltas.intentionally_unsupported` and MUST NOT appear under `missing_*`.

### 2) Regenerate artifacts (always do this after changes)

```bash
V="0.91.0"

cargo run -p xtask -- codex-wrapper-coverage --out cli_manifests/codex/wrapper_coverage.json
cargo run -p xtask -- codex-report --version "$V" --root cli_manifests/codex
cargo run -p xtask -- codex-version-metadata --version "$V" --status reported --root cli_manifests/codex
cargo run -p xtask -- codex-validate --root cli_manifests/codex
```

If `snapshots/V/union.json.complete == true`, `codex-report` will also produce `coverage.all.json`. If union is incomplete, do not expect `coverage.all.json` to exist.

### 3) Run wrapper tests (minimum)

```bash
cargo test -p codex
cargo test -p codex --examples

# Real CLI e2e uses an externally provided codex binary; CI sets this up on Linux.
CODEX_E2E_BINARY=./codex-x86_64-unknown-linux-musl cargo test -p codex --test cli_e2e -- --nocapture
```

## “Done” (what constitutes completion)

Required:
- `xtask codex-validate` passes.

Coverage completion targets:
- For the required target (`x86_64-unknown-linux-musl`), the regenerated `coverage.x86_64-unknown-linux-musl.json` has no remaining uncovered units (no `missing_*` and no `unsupported` entries), unless they are explicitly `intentionally_unsupported` with rationale notes.

If union is complete:
- Meet the same bar across all expected targets (use `coverage.all.json` or per-target reports).

## Guardrails

- Do not edit generated snapshots/reports directly; change code + coverage declarations and regenerate.
- Do not change `RULES.json`/schemas as part of routine parity work (only in spec-changing PRs).
- Do not update `latest_validated.txt` / pointer promotion unless explicitly requested by maintainers (promotion is a separate decision gate).
- Do not update `min_supported.txt` unless explicitly requested by maintainers (this is a policy change, not routine parity work).

## When to recommend bumping `min_supported.txt` (maintainer decision)

`cli_manifests/codex/min_supported.txt` is the repo’s policy floor for “oldest upstream Codex CLI version we commit to supporting”.

Agents should not change it by default, but should recommend a bump when maintaining the old floor is causing repeated friction, for example:
- The wrapper needs pervasive version checks / capability gating that materially increases complexity solely to keep the old floor working.
- New upstream surfaces require incompatible behavioral changes that cannot be cleanly made backwards-compatible.
- E2E tests or CI workflows repeatedly require special-casing due to the floor version.

How to make the recommendation:
- Add a short note in the PR body or a maintainer comment describing:
  - the current floor (`min_supported.txt`) and why it’s driving complexity,
  - the proposed new floor (usually the oldest version we still actively validate in practice),
  - the expected impact (what code paths / tests could be deleted or simplified).
