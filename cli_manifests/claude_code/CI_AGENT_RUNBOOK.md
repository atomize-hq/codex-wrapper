# Claude Code CLI Parity: CI Agent Runbook (Using Generated Artifacts)

This document tells an automated agent (or a human) how to use the generated parity artifacts under `cli_manifests/claude_code/` to bring the Rust wrapper (`crates/claude_code`) into parity with a specific upstream Claude Code CLI version.

## Inputs (generated by CI)

For a given upstream version `V`:

- **Union snapshot (authoritative upstream surface inventory)**  
  `cli_manifests/claude_code/snapshots/V/union.json`

- **Coverage reports (work queue)**  
  `cli_manifests/claude_code/reports/V/coverage.any.json`  
  `cli_manifests/claude_code/reports/V/coverage.<target_triple>.json`  
  `cli_manifests/claude_code/reports/V/coverage.all.json` (only if `union.complete=true`)

- **Wrapper coverage manifest (generated; do not hand-edit)**  
  `cli_manifests/claude_code/wrapper_coverage.json`

- **Wrapper coverage source of truth (edit this)**  
  `crates/claude_code/src/wrapper_coverage_manifest.rs`

When you add or change any wrapper API that spawns `claude`, you must update:
1) the wrapper implementation (`crates/claude_code`),
2) `wrapper_coverage_manifest.rs` so regenerated artifacts reflect the new surface.

Anti-goal:
- Do **not** “zero out” `missing_*` by bulk-adding upstream-discovered commands/flags/args into `wrapper_coverage_manifest.rs` unless the wrapper actually spawns/supports those surfaces. If the report shows obviously-global flags missing under many commands (for example `--help`, `--config`, `--enable`, `--disable`), treat it as a snapshot/union/report normalization bug and fix the generator instead of papering over it in wrapper coverage.

Baseline comparison:

- `BASELINE="$(cat cli_manifests/claude_code/latest_validated.txt)"`
- `cli_manifests/claude_code/snapshots/$BASELINE/union.json`
- `cli_manifests/claude_code/reports/$BASELINE/coverage.any.json`

## Outputs (what you change)

You bring the wrapper “to spec” by changing:

- `crates/claude_code/` code (new APIs, flag wiring, request structs, parsing, etc.)
- `crates/claude_code/` code (new APIs, flag wiring, request structs, parsing, etc.)
- `crates/claude_code/src/wrapper_coverage_manifest.rs` (coverage declarations)

Then you regenerate:

- `cli_manifests/claude_code/wrapper_coverage.json`
- `cli_manifests/claude_code/reports/V/**`
- optionally `cli_manifests/claude_code/versions/V.json` (status/coverage computed fields)

Do not hand-edit generated JSON unless you are fixing a generator bug.

## How To Read The Work Queue (`coverage.*.json`)

The report is a deterministic diff between:
- upstream union snapshot surfaces, and
- wrapper coverage declarations.

### Inheritance and normalization rules (important)

Two rules can make “missing” look surprising if you don’t know they exist:

1) **IU subtree inheritance (ADR 0004)**  
If the wrapper explicitly marks a command path as `intentionally_unsupported`, then all descendant commands/flags/args are classified as `intentionally_unsupported` by inheritance unless an exact wrapper coverage entry overrides them. These inherited IU units must show up under `deltas.intentionally_unsupported` (audit-only) and must not show up under `missing_*`.

2) **Global/effective flags model (`RULES.json.globals.effective_flags_model`)**  
Some flags are treated as global (root) flags that are effectively available across subcommands. To avoid repeated noise, reports are allowed to summarize global-flag deltas at `path=[]`. When in doubt, consult the union snapshot for the specific version and check whether the flag is present on the root command vs only on a subcommand.

Work the report fields in this order:

1) `deltas.missing_commands`
2) `deltas.missing_flags`
3) `deltas.missing_args`
4) `deltas.unsupported` (if present)
5) `deltas.passthrough_candidates` (if present; optional “promotion” work)
6) `deltas.intentionally_unsupported` (if present; audit/review of explicitly waived or inherited IU surfaces)

Each entry contains:
- `path`: command path tokens (`[]` means root command)
- `upstream_available_on`: targets where the surface exists
- `wrapper_level`: `null|unknown|unsupported|passthrough|explicit|intentionally_unsupported`
- `note`: rationale (required for `intentionally_unsupported`)

## Coverage Level Policy (what to choose)

For each upstream surface (command/flag/arg), choose one:

- `explicit`: there is a first-class wrapper API (typed request/response or dedicated method).
- `passthrough`: wrapper can only drive it through generic forwarding (weak support).
- `intentionally_unsupported`: we deliberately do not support it. Must include a non-empty `note`.
- `unsupported` / `unknown`: treated as “work not done yet” and should be eliminated before claiming support.

Validator rule: any `intentionally_unsupported` entry (command/flag/arg) requires a rationale note.

Note policy (to avoid churn):
- `intentionally_unsupported` entries must have a stable, non-empty `note`.
- Capability-guarded surfaces must use `note: "capability-guarded"` (exact string) per the generator contract.

## Operating Loop (single version V)

### 0) Determine what changed vs baseline

Compute “new” and “removed” command surfaces by comparing union snapshots:

```bash
V="0.91.0"
BASELINE="$(cat cli_manifests/claude_code/latest_validated.txt)"

jq -r '.commands[].path | if length==0 then "<root>" else join(" ") end' \
  "cli_manifests/claude_code/snapshots/${BASELINE}/union.json" | sort > /tmp/cmds.baseline.txt
jq -r '.commands[].path | if length==0 then "<root>" else join(" ") end' \
  "cli_manifests/claude_code/snapshots/${V}/union.json" | sort > /tmp/cmds.new.txt

echo "Only in baseline:"
comm -23 /tmp/cmds.baseline.txt /tmp/cmds.new.txt
echo "Only in new version:"
comm -13 /tmp/cmds.baseline.txt /tmp/cmds.new.txt
```

Repeat the same idea for flags/args by emitting stable keys like:
- `<command_path>\t<flag.key>`
- `<command_path>\t<arg.name>`

### 1) Implement or waive each missing surface

For each entry in `coverage.<filter>.json` that is missing/unknown/unsupported:

Option A: implement wrapper support
- Add or update wrapper APIs in `crates/claude_code/src/lib.rs` (and supporting structs/types).
- Ensure flags/args are forwarded correctly and are testable.
- Update `crates/claude_code/src/wrapper_coverage_manifest.rs` to mark the surface as `explicit` (or `passthrough` when appropriate).

Option B: intentionally waive
- In `crates/claude_code/src/wrapper_coverage_manifest.rs`, add a matching entry with:
  - `level: intentionally_unsupported`
  - `note: Some("...")` (must be non-empty)
  - keep the note stable and policy-based (avoid churn).

Subtree waivers (ADR 0004):
- If an entire command family is intentionally unwrapped (e.g. `claude install ...`), prefer marking the *parent command* as `intentionally_unsupported` with a stable rationale note.
- `xtask codex-report` treats descendant commands/flags/args as `intentionally_unsupported` by inheritance unless explicitly overridden by an exact wrapper coverage entry.
- In reports, inherited IU entries appear under `deltas.intentionally_unsupported` and MUST NOT appear under `missing_*`.

### 2) Regenerate artifacts (always do this after changes)

```bash
V="0.91.0"

cargo run -p xtask -- claude-wrapper-coverage --out cli_manifests/claude_code/wrapper_coverage.json
cargo run -p xtask -- codex-report --version "$V" --root cli_manifests/claude_code
cargo run -p xtask -- codex-version-metadata --version "$V" --status reported --root cli_manifests/claude_code
cargo run -p xtask -- codex-validate --root cli_manifests/claude_code
```

If `snapshots/V/union.json.complete == true`, `codex-report` will also produce `coverage.all.json`. If union is incomplete, do not expect `coverage.all.json` to exist.

### 3) Run wrapper tests (minimum)

```bash
cargo test -p claude_code
```

## “Done” (what constitutes completion)

Required:
- `xtask codex-validate` passes.

Coverage completion targets:
- For the required target (`linux-x64`), the regenerated `coverage.linux-x64.json` has no remaining uncovered units (no `missing_*` and no `unsupported` entries), unless they are explicitly `intentionally_unsupported` with rationale notes.

If union is complete:
- Meet the same bar across all expected targets (use `coverage.all.json` or per-target reports).

## Guardrails

- Do not edit generated snapshots/reports directly; change code + coverage declarations and regenerate.
- Do not change `RULES.json`/schemas as part of routine parity work (only in spec-changing PRs).
- Do not update `latest_validated.txt` / pointer promotion unless explicitly requested by maintainers (promotion is a separate decision gate).
- Do not update `min_supported.txt` unless explicitly requested by maintainers (this is a policy change, not routine parity work).

## When to recommend bumping `min_supported.txt` (maintainer decision)

`cli_manifests/claude_code/min_supported.txt` is the repo’s policy floor for “oldest upstream Claude Code CLI version we commit to supporting”.

Agents should not change it by default, but should recommend a bump when maintaining the old floor is causing repeated friction, for example:
- The wrapper needs pervasive version checks / capability gating that materially increases complexity solely to keep the old floor working.
- New upstream surfaces require incompatible behavioral changes that cannot be cleanly made backwards-compatible.
- E2E tests or CI workflows repeatedly require special-casing due to the floor version.

How to make the recommendation:
- Add a short note in the PR body or a maintainer comment describing:
  - the current floor (`min_supported.txt`) and why it’s driving complexity,
  - the proposed new floor (usually the oldest version we still actively validate in practice),
  - the expected impact (what code paths / tests could be deleted or simplified).
