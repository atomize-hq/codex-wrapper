diff --git a/crates/xtask/src/codex_validate.rs b/crates/xtask/src/codex_validate.rs
index c02ed0a..f54656c 100644
--- a/crates/xtask/src/codex_validate.rs
+++ b/crates/xtask/src/codex_validate.rs
@@ -12,6 +12,10 @@ use serde_json::{json, Value};
 use thiserror::Error;
 
 mod models;
+mod pointers;
+mod report_invariants;
+mod schema;
+mod wrapper_coverage;
 use models::{
     IuSortKey, ParityExclusionUnit, ParityExclusionsIndex, PointerRead, PointerValue,
     PointerValues, Rules, RulesWrapperCoverage, ScopedEntry, Violation, WrapperCoverageFile,
@@ -64,33 +68,6 @@ pub enum FatalError {
     Rules(String),
 }
 
-fn absolutize_schema_id(schema: &mut Value, schema_path: &Path) -> Result<(), FatalError> {
-    let Some(id) = schema.get("$id").and_then(|v| v.as_str()) else {
-        return Ok(());
-    };
-
-    // `jsonschema` expects `$id` to be an absolute URI. Our committed schemas use
-    // repo-relative `$id` values (e.g. `cli_manifests/codex/SCHEMA.json`) for
-    // readability, so rewrite them to a file URI at runtime.
-    if id.contains("://") {
-        return Ok(());
-    }
-
-    let abs = fs::canonicalize(schema_path)?;
-    let abs_str = abs.to_string_lossy();
-    let file_uri = if abs_str.starts_with('/') {
-        format!("file://{abs_str}")
-    } else {
-        format!("file:///{abs_str}")
-    };
-
-    if let Some(obj) = schema.as_object_mut() {
-        obj.insert("$id".to_string(), Value::String(file_uri));
-    }
-
-    Ok(())
-}
-
 #[derive(Debug)]
 struct ValidateCtx {
     root: PathBuf,
@@ -200,8 +177,8 @@ fn run_inner(args: Args) -> Result<Vec<Violation>, FatalError> {
     let mut schema_value: Value = serde_json::from_slice(&fs::read(&schema_path)?)?;
     let mut version_schema_value: Value = serde_json::from_slice(&fs::read(&version_schema_path)?)?;
 
-    absolutize_schema_id(&mut schema_value, &schema_path)?;
-    absolutize_schema_id(&mut version_schema_value, &version_schema_path)?;
+    schema::absolutize_schema_id(&mut schema_value, &schema_path)?;
+    schema::absolutize_schema_id(&mut version_schema_value, &version_schema_path)?;
 
     let schema = JSONSchema::options()
         .with_draft(Draft::Draft202012)
@@ -244,7 +221,7 @@ fn run_inner(args: Args) -> Result<Vec<Violation>, FatalError> {
     validate_parity_exclusions_config(&mut ctx, &mut violations);
 
     // 1) Pointer files.
-    let pointer_values = validate_pointers(&mut ctx, &mut violations);
+    let pointer_values = pointers::validate_pointers(&mut ctx, &mut violations);
 
     // 2) Version set to validate.
     let versions_to_validate =
@@ -264,7 +241,7 @@ fn run_inner(args: Args) -> Result<Vec<Violation>, FatalError> {
     );
 
     // 5) wrapper_coverage.json and semantic invariants.
-    validate_wrapper_coverage(&mut ctx, &mut violations);
+    wrapper_coverage::validate_wrapper_coverage(&mut ctx, &mut violations);
 
     // 6) Pointer â†’ version metadata consistency (requires parsed metadata).
     validate_pointer_consistency(&ctx, &mut violations, &pointer_values, &version_metadata);
@@ -298,14 +275,14 @@ fn apply_fix_mode(ctx: &ValidateCtx) -> Result<(), FatalError> {
     for target in &ctx.expected_targets {
         for dir in ["pointers/latest_supported", "pointers/latest_validated"] {
             let path = ctx.root.join(dir).join(format!("{target}.txt"));
-            normalize_single_line_file(&path)?;
+            pointers::normalize_single_line_file(&path)?;
         }
     }
-    normalize_single_line_file(&ctx.root.join("latest_validated.txt"))?;
-    normalize_single_line_file(&ctx.root.join("min_supported.txt"))?;
+    pointers::normalize_single_line_file(&ctx.root.join("latest_validated.txt"))?;
+    pointers::normalize_single_line_file(&ctx.root.join("min_supported.txt"))?;
 
     // 3) Normalize current.json to match snapshots/<latest_validated>/union.json (if possible).
-    let latest_validated = match read_pointer_file(
+    let latest_validated = match pointers::read_pointer_file(
         &ctx.root.join("latest_validated.txt"),
         &ctx.stable_semver_re,
         false,
@@ -325,315 +302,6 @@ fn apply_fix_mode(ctx: &ValidateCtx) -> Result<(), FatalError> {
     Ok(())
 }
 
-fn normalize_single_line_file(path: &Path) -> Result<(), FatalError> {
-    let bytes = match fs::read(path) {
-        Ok(b) => b,
-        Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(()),
-        Err(e) => return Err(e.into()),
-    };
-    let content =
-        String::from_utf8(bytes).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
-    let line = content
-        .split('\n')
-        .next()
-        .unwrap_or("")
-        .trim_end_matches('\r');
-    fs::write(path, format!("{line}\n"))?;
-    Ok(())
-}
-
-fn validate_pointers(ctx: &mut ValidateCtx, violations: &mut Vec<Violation>) -> PointerValues {
-    let mut out = PointerValues::default();
-
-    let min_supported_path = ctx.root.join("min_supported.txt");
-    match read_pointer_file(&min_supported_path, &ctx.stable_semver_re, false) {
-        Ok(PointerRead::Value(PointerValue::Version(ver))) => {
-            out.min_supported = Some(ver.to_string());
-        }
-        Ok(PointerRead::Missing) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_MISSING_FILE",
-            &min_supported_path,
-            "missing required file: min_supported.txt",
-        )),
-        Ok(PointerRead::InvalidFormat { reason }) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_INVALID_FORMAT",
-            &min_supported_path,
-            &format!("invalid pointer file format ({reason}); expected single line + trailing newline"),
-        )),
-        Ok(PointerRead::InvalidValue { raw }) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_INVALID_VALUE",
-            &min_supported_path,
-            &format!("invalid pointer value (got {raw}); expected strict stable semver MAJOR.MINOR.PATCH"),
-        )),
-        Ok(PointerRead::Value(PointerValue::None)) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_INVALID_VALUE",
-            &min_supported_path,
-            "invalid pointer value (got none); expected strict stable semver MAJOR.MINOR.PATCH",
-        )),
-        Err(e) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_UNREADABLE",
-            &min_supported_path,
-            &format!("failed to read pointer file: {e}"),
-        )),
-    }
-
-    let latest_validated_path = ctx.root.join("latest_validated.txt");
-    match read_pointer_file(&latest_validated_path, &ctx.stable_semver_re, false) {
-        Ok(PointerRead::Value(PointerValue::Version(ver))) => {
-            out.latest_validated = Some(ver.to_string());
-        }
-        Ok(PointerRead::Missing) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_MISSING_FILE",
-            &latest_validated_path,
-            "missing required file: latest_validated.txt",
-        )),
-        Ok(PointerRead::InvalidFormat { reason }) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_INVALID_FORMAT",
-            &latest_validated_path,
-            &format!("invalid pointer file format ({reason}); expected single line + trailing newline"),
-        )),
-        Ok(PointerRead::InvalidValue { raw }) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_INVALID_VALUE",
-            &latest_validated_path,
-            &format!("invalid pointer value (got {raw}); expected strict stable semver MAJOR.MINOR.PATCH"),
-        )),
-        Ok(PointerRead::Value(PointerValue::None)) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_INVALID_VALUE",
-            &latest_validated_path,
-            "invalid pointer value (got none); expected strict stable semver MAJOR.MINOR.PATCH",
-        )),
-        Err(e) => violations.push(pointer_violation(
-            ctx,
-            "POINTER_UNREADABLE",
-            &latest_validated_path,
-            &format!("failed to read pointer file: {e}"),
-        )),
-    }
-
-    for target in ctx.expected_targets.clone() {
-        let supported_path = ctx
-            .root
-            .join("pointers/latest_supported")
-            .join(format!("{target}.txt"));
-        let validated_path = ctx
-            .root
-            .join("pointers/latest_validated")
-            .join(format!("{target}.txt"));
-
-        let supported = match read_pointer_file(&supported_path, &ctx.stable_semver_re, true) {
-            Ok(PointerRead::Value(PointerValue::None)) => None,
-            Ok(PointerRead::Value(PointerValue::Version(ver))) => Some(ver.to_string()),
-            Ok(PointerRead::Missing) => {
-                violations.push(Violation {
-                    code: "POINTER_MISSING_FILE",
-                    path: rel_path(&ctx.root, &supported_path),
-                    json_pointer: None,
-                    message: format!(
-                        "missing pointer file for target_triple={target} kind=latest_supported"
-                    ),
-                    unit: Some("pointers"),
-                    command_path: None,
-                    key_or_name: Some(target.clone()),
-                    field: Some("latest_supported"),
-                    target_triple: Some(target.clone()),
-                    details: None,
-                });
-                None
-            }
-            Ok(PointerRead::InvalidFormat { reason }) => {
-                violations.push(Violation {
-                    code: "POINTER_INVALID_FORMAT",
-                    path: rel_path(&ctx.root, &supported_path),
-                    json_pointer: None,
-                    message: format!(
-                        "invalid pointer file format ({reason}); expected single line + trailing newline (target_triple={target} kind=latest_supported)"
-                    ),
-                    unit: Some("pointers"),
-                    command_path: None,
-                    key_or_name: Some(target.clone()),
-                    field: Some("latest_supported"),
-                    target_triple: Some(target.clone()),
-                    details: None,
-                });
-                None
-            }
-            Ok(PointerRead::InvalidValue { raw }) => {
-                violations.push(Violation {
-                    code: "POINTER_INVALID_VALUE",
-                    path: rel_path(&ctx.root, &supported_path),
-                    json_pointer: None,
-                    message: format!(
-                        "invalid pointer value (got {raw}); expected none or strict stable semver MAJOR.MINOR.PATCH (target_triple={target} kind=latest_supported)"
-                    ),
-                    unit: Some("pointers"),
-                    command_path: None,
-                    key_or_name: Some(target.clone()),
-                    field: Some("latest_supported"),
-                    target_triple: Some(target.clone()),
-                    details: None,
-                });
-                None
-            }
-            Err(e) => {
-                violations.push(Violation {
-                    code: "POINTER_UNREADABLE",
-                    path: rel_path(&ctx.root, &supported_path),
-                    json_pointer: None,
-                    message: format!(
-                        "failed to read pointer file: {e} (target_triple={target} kind=latest_supported)"
-                    ),
-                    unit: Some("pointers"),
-                    command_path: None,
-                    key_or_name: Some(target.clone()),
-                    field: Some("latest_supported"),
-                    target_triple: Some(target.clone()),
-                    details: None,
-                });
-                None
-            }
-        };
-        out.by_target_latest_supported
-            .insert(target.clone(), supported);
-
-        let validated = match read_pointer_file(&validated_path, &ctx.stable_semver_re, true) {
-            Ok(PointerRead::Value(PointerValue::None)) => None,
-            Ok(PointerRead::Value(PointerValue::Version(ver))) => Some(ver.to_string()),
-            Ok(PointerRead::Missing) => {
-                violations.push(Violation {
-                    code: "POINTER_MISSING_FILE",
-                    path: rel_path(&ctx.root, &validated_path),
-                    json_pointer: None,
-                    message: format!(
-                        "missing pointer file for target_triple={target} kind=latest_validated"
-                    ),
-                    unit: Some("pointers"),
-                    command_path: None,
-                    key_or_name: Some(target.clone()),
-                    field: Some("latest_validated"),
-                    target_triple: Some(target.clone()),
-                    details: None,
-                });
-                None
-            }
-            Ok(PointerRead::InvalidFormat { reason }) => {
-                violations.push(Violation {
-                    code: "POINTER_INVALID_FORMAT",
-                    path: rel_path(&ctx.root, &validated_path),
-                    json_pointer: None,
-                    message: format!(
-                        "invalid pointer file format ({reason}); expected single line + trailing newline (target_triple={target} kind=latest_validated)"
-                    ),
-                    unit: Some("pointers"),
-                    command_path: None,
-                    key_or_name: Some(target.clone()),
-                    field: Some("latest_validated"),
-                    target_triple: Some(target.clone()),
-                    details: None,
-                });
-                None
-            }
-            Ok(PointerRead::InvalidValue { raw }) => {
-                violations.push(Violation {
-                    code: "POINTER_INVALID_VALUE",
-                    path: rel_path(&ctx.root, &validated_path),
-                    json_pointer: None,
-                    message: format!(
-                        "invalid pointer value (got {raw}); expected none or strict stable semver MAJOR.MINOR.PATCH (target_triple={target} kind=latest_validated)"
-                    ),
-                    unit: Some("pointers"),
-                    command_path: None,
-                    key_or_name: Some(target.clone()),
-                    field: Some("latest_validated"),
-                    target_triple: Some(target.clone()),
-                    details: None,
-                });
-                None
-            }
-            Err(e) => {
-                violations.push(Violation {
-                    code: "POINTER_UNREADABLE",
-                    path: rel_path(&ctx.root, &validated_path),
-                    json_pointer: None,
-                    message: format!(
-                        "failed to read pointer file: {e} (target_triple={target} kind=latest_validated)"
-                    ),
-                    unit: Some("pointers"),
-                    command_path: None,
-                    key_or_name: Some(target.clone()),
-                    field: Some("latest_validated"),
-                    target_triple: Some(target.clone()),
-                    details: None,
-                });
-                None
-            }
-        };
-        out.by_target_latest_validated
-            .insert(target.clone(), validated);
-    }
-
-    // latest_validated.txt must equal pointers/latest_validated/<required_target>.txt and must not be none.
-    if let Some(latest_validated) = out.latest_validated.clone() {
-        let required_ptr = ctx
-            .root
-            .join("pointers/latest_validated")
-            .join(format!("{}.txt", ctx.required_target));
-        let required_value = match read_pointer_file(&required_ptr, &ctx.stable_semver_re, true) {
-            Ok(PointerRead::Value(PointerValue::Version(ver))) => Some(ver.to_string()),
-            _ => None,
-        };
-        if required_value.as_deref() != Some(latest_validated.as_str()) {
-            violations.push(Violation {
-                code: "POINTER_LATEST_VALIDATED_MISMATCH",
-                path: rel_path(&ctx.root, &latest_validated_path),
-                json_pointer: None,
-                message: format!(
-                    "latest_validated.txt must equal pointers/latest_validated/{}.txt and must not be none (latest_validated={}, required_target_value={})",
-                    ctx.required_target,
-                    latest_validated,
-                    required_value.unwrap_or_else(|| "none".to_string())
-                ),
-                unit: Some("pointers"),
-                command_path: None,
-                key_or_name: Some(ctx.required_target.clone()),
-                field: Some("latest_validated"),
-                target_triple: Some(ctx.required_target.clone()),
-                details: None,
-            });
-        }
-    }
-
-    out
-}
-
-fn pointer_violation(
-    ctx: &ValidateCtx,
-    code: &'static str,
-    path: &Path,
-    message: &str,
-) -> Violation {
-    Violation {
-        code,
-        path: rel_path(&ctx.root, path),
-        json_pointer: None,
-        message: message.to_string(),
-        unit: Some("pointers"),
-        command_path: None,
-        key_or_name: None,
-        field: None,
-        target_triple: None,
-        details: None,
-    }
-}
-
 fn compute_versions_to_validate(
     ctx: &mut ValidateCtx,
     violations: &mut Vec<Violation>,
@@ -726,14 +394,14 @@ fn validate_version_bundle(
     version_metadata: &mut BTreeMap<String, Value>,
 ) {
     let version_path = ctx.root.join("versions").join(format!("{version}.json"));
-    match read_json_file(
+    match schema::read_json_file(
         &ctx.root,
         &version_path,
         violations,
         "VERSION_METADATA_INVALID_JSON",
     ) {
         Some(value) => {
-            schema_validate(
+            schema::schema_validate(
                 ctx,
                 violations,
                 &ctx.version_schema,
@@ -769,10 +437,14 @@ fn validate_version_bundle(
     }
 
     let union_path = ctx.root.join("snapshots").join(version).join("union.json");
-    let union_value = match read_json_file(&ctx.root, &union_path, violations, "UNION_INVALID_JSON")
-    {
+    let union_value = match schema::read_json_file(
+        &ctx.root,
+        &union_path,
+        violations,
+        "UNION_INVALID_JSON",
+    ) {
         Some(value) => {
-            schema_validate(
+            schema::schema_validate(
                 ctx,
                 violations,
                 &ctx.schema,
@@ -835,14 +507,14 @@ fn validate_version_bundle(
             .join("snapshots")
             .join(version)
             .join(format!("{target}.json"));
-        match read_json_file(
+        match schema::read_json_file(
             &ctx.root,
             &per_target_path,
             violations,
             "SNAPSHOT_INVALID_JSON",
         ) {
             Some(value) => {
-                schema_validate(
+                schema::schema_validate(
                     ctx,
                     violations,
                     &ctx.schema,
@@ -898,15 +570,15 @@ fn validate_version_bundle(
     let reports_dir = ctx.root.join("reports").join(version);
     let any_report = reports_dir.join("coverage.any.json");
     if require_reports {
-        require_report(ctx, violations, version, "any", None, &any_report);
+        report_invariants::require_report(ctx, violations, version, "any", None, &any_report);
     } else {
-        validate_report_if_present(ctx, violations, &any_report);
+        report_invariants::validate_report_if_present(ctx, violations, &any_report);
     }
 
     for target in &input_targets {
         let per_target = reports_dir.join(format!("coverage.{target}.json"));
         if require_reports {
-            require_report(
+            report_invariants::require_report(
                 ctx,
                 violations,
                 version,
@@ -915,7 +587,7 @@ fn validate_version_bundle(
                 &per_target,
             );
         } else {
-            validate_report_if_present(ctx, violations, &per_target);
+            report_invariants::validate_report_if_present(ctx, violations, &per_target);
         }
     }
 
@@ -927,94 +599,27 @@ fn validate_version_bundle(
     if complete {
         let all_report = reports_dir.join("coverage.all.json");
         if require_reports {
-            require_report(ctx, violations, version, "all", None, &all_report);
+            report_invariants::require_report(ctx, violations, version, "all", None, &all_report);
         } else {
-            validate_report_if_present(ctx, violations, &all_report);
-        }
-    }
-}
-
-fn require_report(
-    ctx: &ValidateCtx,
-    violations: &mut Vec<Violation>,
-    version: &str,
-    kind: &'static str,
-    target: Option<&str>,
-    path: &Path,
-) {
-    match read_json_file(&ctx.root, path, violations, "REPORT_INVALID_JSON") {
-        Some(value) => {
-            schema_validate(
-                ctx,
-                violations,
-                &ctx.schema,
-                &value,
-                path,
-                "REPORT_SCHEMA_INVALID",
-            );
-            validate_report_exclusions(ctx, violations, &value, path);
-            validate_report_intentionally_unsupported(ctx, violations, &value, path);
-        }
-        None => {
-            if path.exists() {
-                return;
-            }
-            violations.push(Violation {
-                code: "REPORT_MISSING",
-                path: rel_path(&ctx.root, path),
-                json_pointer: None,
-                message: match target {
-                    Some(t) => format!(
-                        "missing required file: reports/{version}/{} (kind={kind} target_triple={t})",
-                        path.file_name().and_then(|x| x.to_str()).unwrap_or("<unknown>")
-                    ),
-                    None => format!(
-                        "missing required file: reports/{version}/{} (kind={kind})",
-                        path.file_name().and_then(|x| x.to_str()).unwrap_or("<unknown>")
-                    ),
-                },
-                unit: Some("reports"),
-                command_path: None,
-                key_or_name: target.map(|t| t.to_string()),
-                field: Some("reports"),
-                target_triple: target.map(|t| t.to_string()),
-                details: None,
-            });
+            report_invariants::validate_report_if_present(ctx, violations, &all_report);
         }
     }
 }
 
-fn validate_report_if_present(ctx: &ValidateCtx, violations: &mut Vec<Violation>, path: &Path) {
-    let Some(value) = read_json_file(&ctx.root, path, violations, "REPORT_INVALID_JSON") else {
-        return;
-    };
-
-    schema_validate(
-        ctx,
-        violations,
-        &ctx.schema,
-        &value,
-        path,
-        "REPORT_SCHEMA_INVALID",
-    );
-    validate_report_exclusions(ctx, violations, &value, path);
-    validate_report_intentionally_unsupported(ctx, violations, &value, path);
-}
-
 fn validate_current_json(
     ctx: &mut ValidateCtx,
     violations: &mut Vec<Violation>,
     latest_validated: Option<&str>,
 ) {
     let current_path = ctx.root.join("current.json");
-    let current_value = match read_json_file(
+    let current_value = match schema::read_json_file(
         &ctx.root,
         &current_path,
         violations,
         "CURRENT_INVALID_JSON",
     ) {
         Some(v) => {
-            schema_validate(
+            schema::schema_validate(
                 ctx,
                 violations,
                 &ctx.schema,
@@ -1141,405 +746,20 @@ fn validate_current_json(
     }
 }
 
-fn validate_wrapper_coverage(ctx: &mut ValidateCtx, violations: &mut Vec<Violation>) {
-    let path = ctx.root.join("wrapper_coverage.json");
-    let value = match read_json_file(
-        &ctx.root,
-        &path,
-        violations,
-        "WRAPPER_COVERAGE_INVALID_JSON",
-    ) {
-        Some(v) => {
-            schema_validate(
-                ctx,
-                violations,
-                &ctx.schema,
-                &v,
-                &path,
-                "WRAPPER_COVERAGE_SCHEMA_INVALID",
-            );
-            v
-        }
-        None => {
-            if path.exists() {
-                return;
-            }
-            violations.push(Violation {
-                code: "WRAPPER_COVERAGE_MISSING",
-                path: rel_path(&ctx.root, &path),
-                json_pointer: None,
-                message: "missing required file: wrapper_coverage.json".to_string(),
-                unit: Some("wrapper_coverage"),
-                command_path: None,
-                key_or_name: None,
-                field: Some("wrapper_coverage"),
-                target_triple: None,
-                details: None,
-            });
-            return;
-        }
-    };
-
-    let parsed: WrapperCoverageFile = match serde_json::from_value(value) {
-        Ok(v) => v,
-        Err(e) => {
-            violations.push(Violation {
-                code: "WRAPPER_COVERAGE_PARSE_FAILED",
-                path: rel_path(&ctx.root, &path),
-                json_pointer: None,
-                message: format!("failed to parse wrapper_coverage.json for semantic checks: {e}"),
-                unit: Some("wrapper_coverage"),
-                command_path: None,
-                key_or_name: None,
-                field: Some("wrapper_coverage"),
-                target_triple: None,
-                details: None,
-            });
-            return;
-        }
-    };
-
-    if parsed.schema_version != 1 {
-        violations.push(Violation {
-            code: "WRAPPER_COVERAGE_SCHEMA_VERSION",
-            path: rel_path(&ctx.root, &path),
-            json_pointer: Some("/schema_version".to_string()),
-            message: format!(
-                "wrapper_coverage.json schema_version must be 1 (got {})",
-                parsed.schema_version
-            ),
-            unit: Some("wrapper_coverage"),
-            command_path: None,
-            key_or_name: None,
-            field: Some("schema_version"),
-            target_triple: None,
-            details: None,
-        });
-    }
-
-    validate_wrapper_coverage_exclusions(ctx, violations, &parsed, &path);
-    validate_wrapper_iu_notes(ctx, violations, &parsed, &path);
-    validate_wrapper_scope_overlaps(ctx, violations, &parsed, &path);
-}
-
-fn validate_wrapper_iu_notes(
-    ctx: &ValidateCtx,
-    violations: &mut Vec<Violation>,
-    wc: &WrapperCoverageFile,
-    path: &Path,
-) {
-    for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
-        if cmd.level == "intentionally_unsupported"
-            && cmd.note.as_deref().unwrap_or("").trim().is_empty()
-        {
-            violations.push(Violation {
-                code: "IU_NOTE_MISSING",
-                path: rel_path(&ctx.root, path),
-                json_pointer: Some(format!("/coverage/{cmd_idx}/note")),
-                message: format!(
-                    "intentionally_unsupported requires non-empty note (unit=command command_path={})",
-                    format_command_path(&cmd.path)
-                ),
-                unit: Some("wrapper_command"),
-                command_path: Some(format_command_path(&cmd.path)),
-                key_or_name: None,
-                field: Some("note"),
-                target_triple: None,
-                details: None,
-            });
-        }
-        for (flag_idx, flag) in cmd.flags.as_deref().unwrap_or(&[]).iter().enumerate() {
-            if flag.level == "intentionally_unsupported"
-                && flag.note.as_deref().unwrap_or("").trim().is_empty()
-            {
-                violations.push(Violation {
-                    code: "IU_NOTE_MISSING",
-                    path: rel_path(&ctx.root, path),
-                    json_pointer: Some(format!("/coverage/{cmd_idx}/flags/{flag_idx}/note")),
-                    message: format!(
-                        "intentionally_unsupported requires non-empty note (unit=flag command_path={} key={})",
-                        format_command_path(&cmd.path),
-                        flag.key
-                    ),
-                    unit: Some("wrapper_flag"),
-                    command_path: Some(format_command_path(&cmd.path)),
-                    key_or_name: Some(flag.key.clone()),
-                    field: Some("note"),
-                    target_triple: None,
-                    details: None,
-                });
-            }
-        }
-        for (arg_idx, arg) in cmd.args.as_deref().unwrap_or(&[]).iter().enumerate() {
-            if arg.level == "intentionally_unsupported"
-                && arg.note.as_deref().unwrap_or("").trim().is_empty()
-            {
-                violations.push(Violation {
-                    code: "IU_NOTE_MISSING",
-                    path: rel_path(&ctx.root, path),
-                    json_pointer: Some(format!("/coverage/{cmd_idx}/args/{arg_idx}/note")),
-                    message: format!(
-                        "intentionally_unsupported requires non-empty note (unit=arg command_path={} name={})",
-                        format_command_path(&cmd.path),
-                        arg.name
-                    ),
-                    unit: Some("wrapper_arg"),
-                    command_path: Some(format_command_path(&cmd.path)),
-                    key_or_name: Some(arg.name.clone()),
-                    field: Some("note"),
-                    target_triple: None,
-                    details: None,
-                });
-            }
-        }
-    }
+fn intersect(a: &BTreeSet<String>, b: &BTreeSet<String>) -> BTreeSet<String> {
+    a.intersection(b).cloned().collect()
 }
 
-fn validate_wrapper_scope_overlaps(
+fn validate_version_metadata_validation_sets(
     ctx: &ValidateCtx,
     violations: &mut Vec<Violation>,
-    wc: &WrapperCoverageFile,
+    version: &str,
+    meta: &Value,
     path: &Path,
 ) {
-    if !ctx.wrapper_rules.validation.disallow_overlapping_scopes {
+    let Some(validation) = meta.get("validation") else {
         return;
-    }
-
-    let expected = ctx
-        .expected_targets
-        .iter()
-        .cloned()
-        .collect::<BTreeSet<_>>();
-
-    // command_path overlap
-    if ctx
-        .wrapper_rules
-        .validation
-        .overlap_units
-        .iter()
-        .any(|u| u == "command_path")
-    {
-        let mut by_cmd = BTreeMap::<String, Vec<ScopedEntry>>::new();
-        for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
-            let cmd_targets = scope_to_targets(ctx, &expected, cmd.scope.as_ref());
-            by_cmd
-                .entry(format_command_path(&cmd.path))
-                .or_default()
-                .push(ScopedEntry {
-                    index: format!("coverage[{cmd_idx}]"),
-                    scope_kind: scope_kind(cmd.scope.as_ref()),
-                    targets: cmd_targets,
-                });
-        }
-        for (cmd_path, entries) in by_cmd {
-            detect_overlaps(
-                ctx,
-                violations,
-                path,
-                "WRAPPER_SCOPE_OVERLAP",
-                "command_path",
-                &cmd_path,
-                None,
-                entries,
-            );
-        }
-    }
-
-    // command_flag_key overlap
-    if ctx
-        .wrapper_rules
-        .validation
-        .overlap_units
-        .iter()
-        .any(|u| u == "command_flag_key")
-    {
-        let mut by_flag = BTreeMap::<(String, String), Vec<ScopedEntry>>::new();
-        for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
-            let cmd_targets = scope_to_targets(ctx, &expected, cmd.scope.as_ref());
-            for (flag_idx, flag) in cmd.flags.as_deref().unwrap_or(&[]).iter().enumerate() {
-                let flag_targets = scope_to_targets(ctx, &expected, flag.scope.as_ref());
-                let effective = intersect(&cmd_targets, &flag_targets);
-                by_flag
-                    .entry((format_command_path(&cmd.path), flag.key.clone()))
-                    .or_default()
-                    .push(ScopedEntry {
-                        index: format!("coverage[{cmd_idx}].flags[{flag_idx}]"),
-                        scope_kind: scope_kind(flag.scope.as_ref()),
-                        targets: effective,
-                    });
-            }
-        }
-        for ((cmd_path, key), entries) in by_flag {
-            detect_overlaps(
-                ctx,
-                violations,
-                path,
-                "WRAPPER_SCOPE_OVERLAP",
-                "flag",
-                &cmd_path,
-                Some(key),
-                entries,
-            );
-        }
-    }
-
-    // command_arg_name overlap
-    if ctx
-        .wrapper_rules
-        .validation
-        .overlap_units
-        .iter()
-        .any(|u| u == "command_arg_name")
-    {
-        let mut by_arg = BTreeMap::<(String, String), Vec<ScopedEntry>>::new();
-        for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
-            let cmd_targets = scope_to_targets(ctx, &expected, cmd.scope.as_ref());
-            for (arg_idx, arg) in cmd.args.as_deref().unwrap_or(&[]).iter().enumerate() {
-                let arg_targets = scope_to_targets(ctx, &expected, arg.scope.as_ref());
-                let effective = intersect(&cmd_targets, &arg_targets);
-                by_arg
-                    .entry((format_command_path(&cmd.path), arg.name.clone()))
-                    .or_default()
-                    .push(ScopedEntry {
-                        index: format!("coverage[{cmd_idx}].args[{arg_idx}]"),
-                        scope_kind: scope_kind(arg.scope.as_ref()),
-                        targets: effective,
-                    });
-            }
-        }
-        for ((cmd_path, name), entries) in by_arg {
-            detect_overlaps(
-                ctx,
-                violations,
-                path,
-                "WRAPPER_SCOPE_OVERLAP",
-                "arg",
-                &cmd_path,
-                Some(name),
-                entries,
-            );
-        }
-    }
-}
-
-#[allow(clippy::too_many_arguments)]
-fn detect_overlaps(
-    ctx: &ValidateCtx,
-    violations: &mut Vec<Violation>,
-    path: &Path,
-    code: &'static str,
-    unit: &'static str,
-    cmd_path: &str,
-    key_or_name: Option<String>,
-    entries: Vec<ScopedEntry>,
-) {
-    if entries.len() <= 1 {
-        return;
-    }
-    for target in &ctx.expected_targets {
-        let matching = entries
-            .iter()
-            .filter(|e| e.targets.contains(target))
-            .collect::<Vec<_>>();
-        if matching.len() <= 1 {
-            continue;
-        }
-        let indexes = matching
-            .iter()
-            .map(|e| e.index.as_str())
-            .collect::<Vec<_>>()
-            .join(",");
-        let mut msg = format!(
-            "overlapping wrapper_coverage scopes are manifest-invalid (unit={unit} command_path={cmd_path} target_triple={target} matching_entry_indexes=[{indexes}])"
-        );
-        if let Some(k) = key_or_name.as_deref() {
-            msg.push_str(&format!(" key_or_name={k}"));
-        }
-        violations.push(Violation {
-            code,
-            path: rel_path(&ctx.root, path),
-            json_pointer: None,
-            message: msg,
-            unit: Some("wrapper_coverage"),
-            command_path: Some(cmd_path.to_string()),
-            key_or_name: key_or_name.clone(),
-            field: Some("scope"),
-            target_triple: Some(target.to_string()),
-            details: Some(json!({
-                "matching_entry_indexes": matching.iter().map(|e| e.index.clone()).collect::<Vec<_>>(),
-                "matching_entry_scope_kinds": matching.iter().map(|e| e.scope_kind).collect::<Vec<_>>(),
-            })),
-        });
-    }
-}
-
-fn scope_kind(scope: Option<&WrapperScope>) -> &'static str {
-    let Some(scope) = scope else {
-        return "no_scope";
-    };
-    if scope.target_triples.as_ref().is_some_and(|v| !v.is_empty()) {
-        return "target_triples";
-    }
-    if scope.platforms.as_ref().is_some_and(|v| !v.is_empty()) {
-        return "platforms";
-    }
-    "no_scope"
-}
-
-fn scope_to_targets(
-    ctx: &ValidateCtx,
-    expected: &BTreeSet<String>,
-    scope: Option<&WrapperScope>,
-) -> BTreeSet<String> {
-    let Some(scope) = scope else {
-        return expected.clone();
-    };
-
-    let mut out = BTreeSet::<String>::new();
-    if let Some(tt) = scope.target_triples.as_ref() {
-        for t in tt {
-            if expected.contains(t) {
-                out.insert(t.clone());
-            }
-        }
-    }
-    if let Some(platforms) = scope.platforms.as_ref() {
-        if ctx
-            .wrapper_rules
-            .scope_semantics
-            .platforms_expand_to_expected_targets
-        {
-            for t in expected {
-                if let Some(p) = ctx.platform_mapping.get(t) {
-                    if platforms.iter().any(|pl| pl == p) {
-                        out.insert(t.clone());
-                    }
-                }
-            }
-        }
-    }
-
-    if out.is_empty() {
-        // Treat an empty/unknown scope as applying to no expected targets.
-        return BTreeSet::new();
-    }
-    out
-}
-
-fn intersect(a: &BTreeSet<String>, b: &BTreeSet<String>) -> BTreeSet<String> {
-    a.intersection(b).cloned().collect()
-}
-
-fn validate_version_metadata_validation_sets(
-    ctx: &ValidateCtx,
-    violations: &mut Vec<Violation>,
-    version: &str,
-    meta: &Value,
-    path: &Path,
-) {
-    let Some(validation) = meta.get("validation") else {
-        return;
-    };
+    };
 
     let expected = ctx
         .expected_targets
@@ -1761,138 +981,6 @@ fn validate_pointer_consistency(
     }
 }
 
-fn schema_validate(
-    ctx: &ValidateCtx,
-    violations: &mut Vec<Violation>,
-    schema: &JSONSchema,
-    instance: &Value,
-    path: &Path,
-    code: &'static str,
-) {
-    if let Err(errors) = schema.validate(instance) {
-        let mut errs = errors
-            .map(|e| {
-                let ptr = e.instance_path.to_string();
-                (ptr, e.to_string())
-            })
-            .collect::<Vec<_>>();
-        errs.sort_by(|a, b| a.0.cmp(&b.0).then_with(|| a.1.cmp(&b.1)));
-        for (ptr, msg) in errs {
-            violations.push(Violation {
-                code,
-                path: rel_path(&ctx.root, path),
-                json_pointer: if ptr.is_empty() { None } else { Some(ptr) },
-                message: msg,
-                unit: Some("schemas"),
-                command_path: None,
-                key_or_name: None,
-                field: Some("schema"),
-                target_triple: None,
-                details: None,
-            });
-        }
-    }
-}
-
-fn read_json_file(
-    root: &Path,
-    path: &Path,
-    violations: &mut Vec<Violation>,
-    code_invalid_json: &'static str,
-) -> Option<Value> {
-    let bytes = match fs::read(path) {
-        Ok(b) => b,
-        Err(e) if e.kind() == io::ErrorKind::NotFound => return None,
-        Err(e) => {
-            violations.push(Violation {
-                code: "FILE_UNREADABLE",
-                path: rel_path(root, path),
-                json_pointer: None,
-                message: format!("failed to read file: {e}"),
-                unit: None,
-                command_path: None,
-                key_or_name: None,
-                field: None,
-                target_triple: None,
-                details: None,
-            });
-            return None;
-        }
-    };
-    match serde_json::from_slice::<Value>(&bytes) {
-        Ok(v) => Some(v),
-        Err(e) => {
-            violations.push(Violation {
-                code: code_invalid_json,
-                path: rel_path(root, path),
-                json_pointer: None,
-                message: format!("invalid JSON: {e}"),
-                unit: Some("schemas"),
-                command_path: None,
-                key_or_name: None,
-                field: Some("json"),
-                target_triple: None,
-                details: None,
-            });
-            None
-        }
-    }
-}
-
-fn read_pointer_file(
-    path: &Path,
-    stable_semver_re: &Regex,
-    allow_none: bool,
-) -> Result<PointerRead, FatalError> {
-    let bytes = match fs::read(path) {
-        Ok(b) => b,
-        Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(PointerRead::Missing),
-        Err(e) => return Err(e.into()),
-    };
-
-    let content =
-        std::str::from_utf8(&bytes).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
-
-    if !content.ends_with('\n') {
-        return Ok(PointerRead::InvalidFormat {
-            reason: "missing trailing newline",
-        });
-    }
-
-    let without_nl = &content[..content.len() - 1];
-    if without_nl.contains('\n') {
-        return Ok(PointerRead::InvalidFormat {
-            reason: "multiple lines",
-        });
-    }
-    if without_nl.contains('\r') {
-        return Ok(PointerRead::InvalidFormat {
-            reason: "contains CR character",
-        });
-    }
-    if without_nl != without_nl.trim() {
-        return Ok(PointerRead::InvalidFormat {
-            reason: "contains leading/trailing whitespace",
-        });
-    }
-
-    if without_nl == "none" {
-        if allow_none {
-            return Ok(PointerRead::Value(PointerValue::None));
-        }
-        return Ok(PointerRead::InvalidValue {
-            raw: "none".to_string(),
-        });
-    }
-
-    let Some(ver) = parse_stable_version(without_nl, stable_semver_re) else {
-        return Ok(PointerRead::InvalidValue {
-            raw: without_nl.to_string(),
-        });
-    };
-    Ok(PointerRead::Value(PointerValue::Version(ver)))
-}
-
 fn parse_stable_version(s: &str, stable_semver_re: &Regex) -> Option<Version> {
     models::parse_stable_version(s, stable_semver_re)
 }
@@ -2130,378 +1218,6 @@ fn validate_parity_exclusions_config(ctx: &mut ValidateCtx, violations: &mut Vec
     }
 }
 
-fn validate_report_exclusions(
-    ctx: &ValidateCtx,
-    violations: &mut Vec<Violation>,
-    report: &Value,
-    report_path: &Path,
-) {
-    let Some(index) = ctx.parity_exclusions.as_ref() else {
-        return;
-    };
-    let Some(deltas) = report.get("deltas") else {
-        return;
-    };
-
-    let missing_commands = deltas.get("missing_commands").and_then(Value::as_array);
-    let missing_flags = deltas.get("missing_flags").and_then(Value::as_array);
-    let missing_args = deltas.get("missing_args").and_then(Value::as_array);
-
-    if let Some(items) = missing_commands {
-        for (i, item) in items.iter().enumerate() {
-            let path = item.get("path").and_then(Value::as_array).map(|arr| {
-                arr.iter()
-                    .filter_map(Value::as_str)
-                    .map(str::to_string)
-                    .collect::<Vec<_>>()
-            });
-            let Some(path) = path else { continue };
-            if index.commands.contains_key(&path) {
-                violations.push(Violation {
-                    code: "REPORT_MISSING_INCLUDES_EXCLUDED",
-                    path: rel_path(&ctx.root, report_path),
-                    json_pointer: Some(format!("/deltas/missing_commands/{i}")),
-                    message: format!(
-                        "report missing_commands includes excluded command_path={}",
-                        format_command_path(&path)
-                    ),
-                    unit: Some("reports"),
-                    command_path: Some(format_command_path(&path)),
-                    key_or_name: None,
-                    field: Some("missing_commands"),
-                    target_triple: None,
-                    details: None,
-                });
-            }
-        }
-    }
-
-    if let Some(items) = missing_flags {
-        for (i, item) in items.iter().enumerate() {
-            let path = item.get("path").and_then(Value::as_array).map(|arr| {
-                arr.iter()
-                    .filter_map(Value::as_str)
-                    .map(str::to_string)
-                    .collect::<Vec<_>>()
-            });
-            let key = item.get("key").and_then(Value::as_str).map(str::to_string);
-            let (Some(path), Some(key)) = (path, key) else {
-                continue;
-            };
-            if let Some(ex) = index.flags.get(&(path.clone(), key.clone())) {
-                violations.push(Violation {
-                    code: "REPORT_MISSING_INCLUDES_EXCLUDED",
-                    path: rel_path(&ctx.root, report_path),
-                    json_pointer: Some(format!("/deltas/missing_flags/{i}")),
-                    message: format!(
-                        "report missing_flags includes excluded flag (command_path={} key={} category={})",
-                        format_command_path(&path),
-                        key,
-                        ex.category.clone().unwrap_or_else(|| "<missing>".to_string())
-                    ),
-                    unit: Some("reports"),
-                    command_path: Some(format_command_path(&path)),
-                    key_or_name: Some(key),
-                    field: Some("missing_flags"),
-                    target_triple: None,
-                    details: None,
-                });
-            }
-        }
-    }
-
-    if let Some(items) = missing_args {
-        for (i, item) in items.iter().enumerate() {
-            let path = item.get("path").and_then(Value::as_array).map(|arr| {
-                arr.iter()
-                    .filter_map(Value::as_str)
-                    .map(str::to_string)
-                    .collect::<Vec<_>>()
-            });
-            let name = item.get("name").and_then(Value::as_str).map(str::to_string);
-            let (Some(path), Some(name)) = (path, name) else {
-                continue;
-            };
-            if let Some(ex) = index.args.get(&(path.clone(), name.clone())) {
-                violations.push(Violation {
-                    code: "REPORT_MISSING_INCLUDES_EXCLUDED",
-                    path: rel_path(&ctx.root, report_path),
-                    json_pointer: Some(format!("/deltas/missing_args/{i}")),
-                    message: format!(
-                        "report missing_args includes excluded arg (command_path={} name={} category={})",
-                        format_command_path(&path),
-                        name,
-                        ex.category.clone().unwrap_or_else(|| "<missing>".to_string())
-                    ),
-                    unit: Some("reports"),
-                    command_path: Some(format_command_path(&path)),
-                    key_or_name: Some(name),
-                    field: Some("missing_args"),
-                    target_triple: None,
-                    details: None,
-                });
-            }
-        }
-    }
-}
-
-fn cmp_path_tokens(a: &[String], b: &[String]) -> std::cmp::Ordering {
-    let mut i = 0usize;
-    while i < a.len() && i < b.len() {
-        match a[i].cmp(&b[i]) {
-            std::cmp::Ordering::Equal => i += 1,
-            non_eq => return non_eq,
-        }
-    }
-    a.len().cmp(&b.len())
-}
-
-fn cmp_iu_sort_key(a: &IuSortKey, b: &IuSortKey) -> std::cmp::Ordering {
-    a.kind_rank
-        .cmp(&b.kind_rank)
-        .then_with(|| cmp_path_tokens(&a.path, &b.path))
-        .then_with(|| a.key_or_name.cmp(&b.key_or_name))
-}
-
-fn validate_report_intentionally_unsupported(
-    ctx: &ValidateCtx,
-    violations: &mut Vec<Violation>,
-    report: &Value,
-    report_path: &Path,
-) {
-    let Some(deltas) = report.get("deltas") else {
-        return;
-    };
-
-    for (list_name, items) in [
-        (
-            "missing_commands",
-            deltas.get("missing_commands").and_then(Value::as_array),
-        ),
-        (
-            "missing_flags",
-            deltas.get("missing_flags").and_then(Value::as_array),
-        ),
-        (
-            "missing_args",
-            deltas.get("missing_args").and_then(Value::as_array),
-        ),
-    ] {
-        let Some(items) = items else { continue };
-        for (i, item) in items.iter().enumerate() {
-            if item
-                .get("wrapper_level")
-                .and_then(Value::as_str)
-                .is_some_and(|s| s == "intentionally_unsupported")
-            {
-                violations.push(Violation {
-                    code: "REPORT_MISSING_INCLUDES_INTENTIONALLY_UNSUPPORTED",
-                    path: rel_path(&ctx.root, report_path),
-                    json_pointer: Some(format!("/deltas/{list_name}/{i}")),
-                    message: format!(
-                        "report {list_name} includes wrapper_level=intentionally_unsupported"
-                    ),
-                    unit: Some("reports"),
-                    command_path: item.get("path").and_then(Value::as_array).map(|arr| {
-                        arr.iter()
-                            .filter_map(Value::as_str)
-                            .collect::<Vec<_>>()
-                            .join(" ")
-                    }),
-                    key_or_name: item
-                        .get("key")
-                        .and_then(Value::as_str)
-                        .or_else(|| item.get("name").and_then(Value::as_str))
-                        .map(|s| s.to_string()),
-                    field: Some(list_name),
-                    target_triple: None,
-                    details: None,
-                });
-            }
-        }
-    }
-
-    let Some(iu_items) = deltas
-        .get("intentionally_unsupported")
-        .and_then(Value::as_array)
-    else {
-        return;
-    };
-
-    let mut keys = Vec::new();
-    for (i, item) in iu_items.iter().enumerate() {
-        let path = item.get("path").and_then(Value::as_array).map(|arr| {
-            arr.iter()
-                .filter_map(Value::as_str)
-                .map(str::to_string)
-                .collect::<Vec<_>>()
-        });
-        let Some(path) = path else { continue };
-
-        let kind_rank = if item.get("key").is_some() {
-            1u8
-        } else if item.get("name").is_some() {
-            2u8
-        } else {
-            0u8
-        };
-
-        let key_or_name = item
-            .get("key")
-            .and_then(Value::as_str)
-            .or_else(|| item.get("name").and_then(Value::as_str))
-            .unwrap_or("")
-            .to_string();
-
-        if item.get("wrapper_level").and_then(Value::as_str) != Some("intentionally_unsupported") {
-            violations.push(Violation {
-                code: "REPORT_IU_NOTE_MISSING",
-                path: rel_path(&ctx.root, report_path),
-                json_pointer: Some(format!("/deltas/intentionally_unsupported/{i}/wrapper_level")),
-                message:
-                    "intentionally_unsupported entry must have wrapper_level=intentionally_unsupported"
-                        .to_string(),
-                unit: Some("reports"),
-                command_path: Some(format_command_path(&path)),
-                key_or_name: if key_or_name.is_empty() {
-                    None
-                } else {
-                    Some(key_or_name.clone())
-                },
-                field: Some("intentionally_unsupported"),
-                target_triple: None,
-                details: None,
-            });
-        }
-
-        if item
-            .get("note")
-            .and_then(Value::as_str)
-            .unwrap_or("")
-            .trim()
-            .is_empty()
-        {
-            violations.push(Violation {
-                code: "REPORT_IU_NOTE_MISSING",
-                path: rel_path(&ctx.root, report_path),
-                json_pointer: Some(format!("/deltas/intentionally_unsupported/{i}/note")),
-                message: "intentionally_unsupported entry requires non-empty note".to_string(),
-                unit: Some("reports"),
-                command_path: Some(format_command_path(&path)),
-                key_or_name: if key_or_name.is_empty() {
-                    None
-                } else {
-                    Some(key_or_name.clone())
-                },
-                field: Some("note"),
-                target_triple: None,
-                details: None,
-            });
-        }
-
-        keys.push(IuSortKey {
-            kind_rank,
-            path,
-            key_or_name,
-        });
-    }
-
-    let mut sorted = keys.clone();
-    sorted.sort_by(cmp_iu_sort_key);
-    if keys != sorted {
-        violations.push(Violation {
-            code: "REPORT_IU_NOT_SORTED",
-            path: rel_path(&ctx.root, report_path),
-            json_pointer: Some("/deltas/intentionally_unsupported".to_string()),
-            message:
-                "deltas.intentionally_unsupported must be stable-sorted by (kind,path,key_or_name)"
-                    .to_string(),
-            unit: Some("reports"),
-            command_path: None,
-            key_or_name: None,
-            field: Some("intentionally_unsupported"),
-            target_triple: None,
-            details: None,
-        });
-    }
-}
-
-fn validate_wrapper_coverage_exclusions(
-    ctx: &ValidateCtx,
-    violations: &mut Vec<Violation>,
-    wc: &WrapperCoverageFile,
-    wc_path: &Path,
-) {
-    let Some(index) = ctx.parity_exclusions.as_ref() else {
-        return;
-    };
-
-    for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
-        if let Some(ex) = index.commands.get(&cmd.path) {
-            violations.push(Violation {
-                code: "WRAPPER_COVERAGE_INCLUDES_EXCLUDED",
-                path: rel_path(&ctx.root, wc_path),
-                json_pointer: Some(format!("/coverage/{cmd_idx}")),
-                message: format!(
-                    "wrapper_coverage includes excluded command_path={} (note={})",
-                    format_command_path(&cmd.path),
-                    ex.note
-                ),
-                unit: Some("wrapper_command"),
-                command_path: Some(format_command_path(&cmd.path)),
-                key_or_name: None,
-                field: Some("coverage"),
-                target_triple: None,
-                details: None,
-            });
-        }
-
-        for (flag_idx, flag) in cmd.flags.as_deref().unwrap_or(&[]).iter().enumerate() {
-            if let Some(ex) = index.flags.get(&(cmd.path.clone(), flag.key.clone())) {
-                violations.push(Violation {
-                    code: "WRAPPER_COVERAGE_INCLUDES_EXCLUDED",
-                    path: rel_path(&ctx.root, wc_path),
-                    json_pointer: Some(format!("/coverage/{cmd_idx}/flags/{flag_idx}")),
-                    message: format!(
-                        "wrapper_coverage includes excluded flag (command_path={} key={} note={})",
-                        format_command_path(&cmd.path),
-                        flag.key,
-                        ex.note
-                    ),
-                    unit: Some("wrapper_flag"),
-                    command_path: Some(format_command_path(&cmd.path)),
-                    key_or_name: Some(flag.key.clone()),
-                    field: Some("flags"),
-                    target_triple: None,
-                    details: None,
-                });
-            }
-        }
-
-        for (arg_idx, arg) in cmd.args.as_deref().unwrap_or(&[]).iter().enumerate() {
-            if let Some(ex) = index.args.get(&(cmd.path.clone(), arg.name.clone())) {
-                violations.push(Violation {
-                    code: "WRAPPER_COVERAGE_INCLUDES_EXCLUDED",
-                    path: rel_path(&ctx.root, wc_path),
-                    json_pointer: Some(format!("/coverage/{cmd_idx}/args/{arg_idx}")),
-                    message: format!(
-                        "wrapper_coverage includes excluded arg (command_path={} name={} note={})",
-                        format_command_path(&cmd.path),
-                        arg.name,
-                        ex.note
-                    ),
-                    unit: Some("wrapper_arg"),
-                    command_path: Some(format_command_path(&cmd.path)),
-                    key_or_name: Some(arg.name.clone()),
-                    field: Some("args"),
-                    target_triple: None,
-                    details: None,
-                });
-            }
-        }
-    }
-}
-
 fn is_union_snapshot(v: &Value) -> bool {
     v.get("snapshot_schema_version")
         .and_then(Value::as_i64)
diff --git a/crates/xtask/src/codex_validate/pointers.rs b/crates/xtask/src/codex_validate/pointers.rs
new file mode 100644
index 0000000..3d35325
--- /dev/null
+++ b/crates/xtask/src/codex_validate/pointers.rs
@@ -0,0 +1,382 @@
+use std::{fs, io, path::Path};
+
+use regex::Regex;
+
+use super::{
+    parse_stable_version, rel_path, FatalError, PointerRead, PointerValue, PointerValues,
+    ValidateCtx, Violation,
+};
+
+pub(super) fn normalize_single_line_file(path: &Path) -> Result<(), FatalError> {
+    let bytes = match fs::read(path) {
+        Ok(b) => b,
+        Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(()),
+        Err(e) => return Err(e.into()),
+    };
+    let content =
+        String::from_utf8(bytes).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
+    let line = content
+        .split('\n')
+        .next()
+        .unwrap_or("")
+        .trim_end_matches('\r');
+    fs::write(path, format!("{line}\n"))?;
+    Ok(())
+}
+
+pub(super) fn validate_pointers(
+    ctx: &mut ValidateCtx,
+    violations: &mut Vec<Violation>,
+) -> PointerValues {
+    let mut out = PointerValues::default();
+
+    let min_supported_path = ctx.root.join("min_supported.txt");
+    match read_pointer_file(&min_supported_path, &ctx.stable_semver_re, false) {
+        Ok(PointerRead::Value(PointerValue::Version(ver))) => {
+            out.min_supported = Some(ver.to_string());
+        }
+        Ok(PointerRead::Missing) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_MISSING_FILE",
+            &min_supported_path,
+            "missing required file: min_supported.txt",
+        )),
+        Ok(PointerRead::InvalidFormat { reason }) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_INVALID_FORMAT",
+            &min_supported_path,
+            &format!(
+                "invalid pointer file format ({reason}); expected single line + trailing newline"
+            ),
+        )),
+        Ok(PointerRead::InvalidValue { raw }) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_INVALID_VALUE",
+            &min_supported_path,
+            &format!(
+                "invalid pointer value (got {raw}); expected strict stable semver MAJOR.MINOR.PATCH"
+            ),
+        )),
+        Ok(PointerRead::Value(PointerValue::None)) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_INVALID_VALUE",
+            &min_supported_path,
+            "invalid pointer value (got none); expected strict stable semver MAJOR.MINOR.PATCH",
+        )),
+        Err(e) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_UNREADABLE",
+            &min_supported_path,
+            &format!("failed to read pointer file: {e}"),
+        )),
+    }
+
+    let latest_validated_path = ctx.root.join("latest_validated.txt");
+    match read_pointer_file(&latest_validated_path, &ctx.stable_semver_re, false) {
+        Ok(PointerRead::Value(PointerValue::Version(ver))) => {
+            out.latest_validated = Some(ver.to_string());
+        }
+        Ok(PointerRead::Missing) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_MISSING_FILE",
+            &latest_validated_path,
+            "missing required file: latest_validated.txt",
+        )),
+        Ok(PointerRead::InvalidFormat { reason }) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_INVALID_FORMAT",
+            &latest_validated_path,
+            &format!(
+                "invalid pointer file format ({reason}); expected single line + trailing newline"
+            ),
+        )),
+        Ok(PointerRead::InvalidValue { raw }) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_INVALID_VALUE",
+            &latest_validated_path,
+            &format!(
+                "invalid pointer value (got {raw}); expected strict stable semver MAJOR.MINOR.PATCH"
+            ),
+        )),
+        Ok(PointerRead::Value(PointerValue::None)) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_INVALID_VALUE",
+            &latest_validated_path,
+            "invalid pointer value (got none); expected strict stable semver MAJOR.MINOR.PATCH",
+        )),
+        Err(e) => violations.push(pointer_violation(
+            ctx,
+            "POINTER_UNREADABLE",
+            &latest_validated_path,
+            &format!("failed to read pointer file: {e}"),
+        )),
+    }
+
+    for target in ctx.expected_targets.clone() {
+        let supported_path = ctx
+            .root
+            .join("pointers/latest_supported")
+            .join(format!("{target}.txt"));
+        let validated_path = ctx
+            .root
+            .join("pointers/latest_validated")
+            .join(format!("{target}.txt"));
+
+        let supported = match read_pointer_file(&supported_path, &ctx.stable_semver_re, true) {
+            Ok(PointerRead::Value(PointerValue::None)) => None,
+            Ok(PointerRead::Value(PointerValue::Version(ver))) => Some(ver.to_string()),
+            Ok(PointerRead::Missing) => {
+                violations.push(Violation {
+                    code: "POINTER_MISSING_FILE",
+                    path: rel_path(&ctx.root, &supported_path),
+                    json_pointer: None,
+                    message: format!(
+                        "missing pointer file for target_triple={target} kind=latest_supported"
+                    ),
+                    unit: Some("pointers"),
+                    command_path: None,
+                    key_or_name: Some(target.clone()),
+                    field: Some("latest_supported"),
+                    target_triple: Some(target.clone()),
+                    details: None,
+                });
+                None
+            }
+            Ok(PointerRead::InvalidFormat { reason }) => {
+                violations.push(Violation {
+                    code: "POINTER_INVALID_FORMAT",
+                    path: rel_path(&ctx.root, &supported_path),
+                    json_pointer: None,
+                    message: format!(
+                        "invalid pointer file format ({reason}); expected single line + trailing newline (target_triple={target} kind=latest_supported)"
+                    ),
+                    unit: Some("pointers"),
+                    command_path: None,
+                    key_or_name: Some(target.clone()),
+                    field: Some("latest_supported"),
+                    target_triple: Some(target.clone()),
+                    details: None,
+                });
+                None
+            }
+            Ok(PointerRead::InvalidValue { raw }) => {
+                violations.push(Violation {
+                    code: "POINTER_INVALID_VALUE",
+                    path: rel_path(&ctx.root, &supported_path),
+                    json_pointer: None,
+                    message: format!(
+                        "invalid pointer value (got {raw}); expected none or strict stable semver MAJOR.MINOR.PATCH (target_triple={target} kind=latest_supported)"
+                    ),
+                    unit: Some("pointers"),
+                    command_path: None,
+                    key_or_name: Some(target.clone()),
+                    field: Some("latest_supported"),
+                    target_triple: Some(target.clone()),
+                    details: None,
+                });
+                None
+            }
+            Err(e) => {
+                violations.push(Violation {
+                    code: "POINTER_UNREADABLE",
+                    path: rel_path(&ctx.root, &supported_path),
+                    json_pointer: None,
+                    message: format!(
+                        "failed to read pointer file: {e} (target_triple={target} kind=latest_supported)"
+                    ),
+                    unit: Some("pointers"),
+                    command_path: None,
+                    key_or_name: Some(target.clone()),
+                    field: Some("latest_supported"),
+                    target_triple: Some(target.clone()),
+                    details: None,
+                });
+                None
+            }
+        };
+        out.by_target_latest_supported
+            .insert(target.clone(), supported);
+
+        let validated = match read_pointer_file(&validated_path, &ctx.stable_semver_re, true) {
+            Ok(PointerRead::Value(PointerValue::None)) => None,
+            Ok(PointerRead::Value(PointerValue::Version(ver))) => Some(ver.to_string()),
+            Ok(PointerRead::Missing) => {
+                violations.push(Violation {
+                    code: "POINTER_MISSING_FILE",
+                    path: rel_path(&ctx.root, &validated_path),
+                    json_pointer: None,
+                    message: format!(
+                        "missing pointer file for target_triple={target} kind=latest_validated"
+                    ),
+                    unit: Some("pointers"),
+                    command_path: None,
+                    key_or_name: Some(target.clone()),
+                    field: Some("latest_validated"),
+                    target_triple: Some(target.clone()),
+                    details: None,
+                });
+                None
+            }
+            Ok(PointerRead::InvalidFormat { reason }) => {
+                violations.push(Violation {
+                    code: "POINTER_INVALID_FORMAT",
+                    path: rel_path(&ctx.root, &validated_path),
+                    json_pointer: None,
+                    message: format!(
+                        "invalid pointer file format ({reason}); expected single line + trailing newline (target_triple={target} kind=latest_validated)"
+                    ),
+                    unit: Some("pointers"),
+                    command_path: None,
+                    key_or_name: Some(target.clone()),
+                    field: Some("latest_validated"),
+                    target_triple: Some(target.clone()),
+                    details: None,
+                });
+                None
+            }
+            Ok(PointerRead::InvalidValue { raw }) => {
+                violations.push(Violation {
+                    code: "POINTER_INVALID_VALUE",
+                    path: rel_path(&ctx.root, &validated_path),
+                    json_pointer: None,
+                    message: format!(
+                        "invalid pointer value (got {raw}); expected none or strict stable semver MAJOR.MINOR.PATCH (target_triple={target} kind=latest_validated)"
+                    ),
+                    unit: Some("pointers"),
+                    command_path: None,
+                    key_or_name: Some(target.clone()),
+                    field: Some("latest_validated"),
+                    target_triple: Some(target.clone()),
+                    details: None,
+                });
+                None
+            }
+            Err(e) => {
+                violations.push(Violation {
+                    code: "POINTER_UNREADABLE",
+                    path: rel_path(&ctx.root, &validated_path),
+                    json_pointer: None,
+                    message: format!(
+                        "failed to read pointer file: {e} (target_triple={target} kind=latest_validated)"
+                    ),
+                    unit: Some("pointers"),
+                    command_path: None,
+                    key_or_name: Some(target.clone()),
+                    field: Some("latest_validated"),
+                    target_triple: Some(target.clone()),
+                    details: None,
+                });
+                None
+            }
+        };
+        out.by_target_latest_validated
+            .insert(target.clone(), validated);
+    }
+
+    // latest_validated.txt must equal pointers/latest_validated/<required_target>.txt and must not be none.
+    if let Some(latest_validated) = out.latest_validated.clone() {
+        let required_ptr = ctx
+            .root
+            .join("pointers/latest_validated")
+            .join(format!("{}.txt", ctx.required_target));
+        let required_value = match read_pointer_file(&required_ptr, &ctx.stable_semver_re, true) {
+            Ok(PointerRead::Value(PointerValue::Version(ver))) => Some(ver.to_string()),
+            _ => None,
+        };
+        if required_value.as_deref() != Some(latest_validated.as_str()) {
+            violations.push(Violation {
+                code: "POINTER_LATEST_VALIDATED_MISMATCH",
+                path: rel_path(&ctx.root, &latest_validated_path),
+                json_pointer: None,
+                message: format!(
+                    "latest_validated.txt must equal pointers/latest_validated/{}.txt and must not be none (latest_validated={}, required_target_value={})",
+                    ctx.required_target,
+                    latest_validated,
+                    required_value.unwrap_or_else(|| "none".to_string())
+                ),
+                unit: Some("pointers"),
+                command_path: None,
+                key_or_name: Some(ctx.required_target.clone()),
+                field: Some("latest_validated"),
+                target_triple: Some(ctx.required_target.clone()),
+                details: None,
+            });
+        }
+    }
+
+    out
+}
+
+fn pointer_violation(
+    ctx: &ValidateCtx,
+    code: &'static str,
+    path: &Path,
+    message: &str,
+) -> Violation {
+    Violation {
+        code,
+        path: rel_path(&ctx.root, path),
+        json_pointer: None,
+        message: message.to_string(),
+        unit: Some("pointers"),
+        command_path: None,
+        key_or_name: None,
+        field: None,
+        target_triple: None,
+        details: None,
+    }
+}
+
+pub(super) fn read_pointer_file(
+    path: &Path,
+    stable_semver_re: &Regex,
+    allow_none: bool,
+) -> Result<PointerRead, FatalError> {
+    let bytes = match fs::read(path) {
+        Ok(b) => b,
+        Err(e) if e.kind() == io::ErrorKind::NotFound => return Ok(PointerRead::Missing),
+        Err(e) => return Err(e.into()),
+    };
+
+    let content =
+        std::str::from_utf8(&bytes).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
+
+    if !content.ends_with('\n') {
+        return Ok(PointerRead::InvalidFormat {
+            reason: "missing trailing newline",
+        });
+    }
+
+    let without_nl = &content[..content.len() - 1];
+    if without_nl.contains('\n') {
+        return Ok(PointerRead::InvalidFormat {
+            reason: "multiple lines",
+        });
+    }
+    if without_nl.contains('\r') {
+        return Ok(PointerRead::InvalidFormat {
+            reason: "contains CR character",
+        });
+    }
+    if without_nl != without_nl.trim() {
+        return Ok(PointerRead::InvalidFormat {
+            reason: "contains leading/trailing whitespace",
+        });
+    }
+
+    if without_nl == "none" {
+        if allow_none {
+            return Ok(PointerRead::Value(PointerValue::None));
+        }
+        return Ok(PointerRead::InvalidValue {
+            raw: "none".to_string(),
+        });
+    }
+
+    let Some(ver) = parse_stable_version(without_nl, stable_semver_re) else {
+        return Ok(PointerRead::InvalidValue {
+            raw: without_nl.to_string(),
+        });
+    };
+    Ok(PointerRead::Value(PointerValue::Version(ver)))
+}
diff --git a/crates/xtask/src/codex_validate/report_invariants.rs b/crates/xtask/src/codex_validate/report_invariants.rs
new file mode 100644
index 0000000..5d32b83
--- /dev/null
+++ b/crates/xtask/src/codex_validate/report_invariants.rs
@@ -0,0 +1,373 @@
+use std::path::Path;
+
+use serde_json::Value;
+
+use super::{format_command_path, rel_path, schema, IuSortKey, ValidateCtx, Violation};
+
+pub(super) fn require_report(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    version: &str,
+    kind: &'static str,
+    target: Option<&str>,
+    path: &Path,
+) {
+    match schema::read_json_file(&ctx.root, path, violations, "REPORT_INVALID_JSON") {
+        Some(value) => {
+            schema::schema_validate(
+                ctx,
+                violations,
+                &ctx.schema,
+                &value,
+                path,
+                "REPORT_SCHEMA_INVALID",
+            );
+            validate_report_exclusions(ctx, violations, &value, path);
+            validate_report_intentionally_unsupported(ctx, violations, &value, path);
+        }
+        None => {
+            if path.exists() {
+                return;
+            }
+            violations.push(Violation {
+                code: "REPORT_MISSING",
+                path: rel_path(&ctx.root, path),
+                json_pointer: None,
+                message: match target {
+                    Some(t) => format!(
+                        "missing required file: reports/{version}/{} (kind={kind} target_triple={t})",
+                        path.file_name().and_then(|x| x.to_str()).unwrap_or("<unknown>")
+                    ),
+                    None => format!(
+                        "missing required file: reports/{version}/{} (kind={kind})",
+                        path.file_name().and_then(|x| x.to_str()).unwrap_or("<unknown>")
+                    ),
+                },
+                unit: Some("reports"),
+                command_path: None,
+                key_or_name: target.map(|t| t.to_string()),
+                field: Some("reports"),
+                target_triple: target.map(|t| t.to_string()),
+                details: None,
+            });
+        }
+    }
+}
+
+pub(super) fn validate_report_if_present(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    path: &Path,
+) {
+    let Some(value) = schema::read_json_file(&ctx.root, path, violations, "REPORT_INVALID_JSON")
+    else {
+        return;
+    };
+
+    schema::schema_validate(
+        ctx,
+        violations,
+        &ctx.schema,
+        &value,
+        path,
+        "REPORT_SCHEMA_INVALID",
+    );
+    validate_report_exclusions(ctx, violations, &value, path);
+    validate_report_intentionally_unsupported(ctx, violations, &value, path);
+}
+
+fn validate_report_exclusions(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    report: &Value,
+    report_path: &Path,
+) {
+    let Some(index) = ctx.parity_exclusions.as_ref() else {
+        return;
+    };
+    let Some(deltas) = report.get("deltas") else {
+        return;
+    };
+
+    let missing_commands = deltas.get("missing_commands").and_then(Value::as_array);
+    let missing_flags = deltas.get("missing_flags").and_then(Value::as_array);
+    let missing_args = deltas.get("missing_args").and_then(Value::as_array);
+
+    if let Some(items) = missing_commands {
+        for (i, item) in items.iter().enumerate() {
+            let path = item.get("path").and_then(Value::as_array).map(|arr| {
+                arr.iter()
+                    .filter_map(Value::as_str)
+                    .map(str::to_string)
+                    .collect::<Vec<_>>()
+            });
+            let Some(path) = path else { continue };
+            if index.commands.contains_key(&path) {
+                violations.push(Violation {
+                    code: "REPORT_MISSING_INCLUDES_EXCLUDED",
+                    path: rel_path(&ctx.root, report_path),
+                    json_pointer: Some(format!("/deltas/missing_commands/{i}")),
+                    message: format!(
+                        "report missing_commands includes excluded command_path={}",
+                        format_command_path(&path)
+                    ),
+                    unit: Some("reports"),
+                    command_path: Some(format_command_path(&path)),
+                    key_or_name: None,
+                    field: Some("missing_commands"),
+                    target_triple: None,
+                    details: None,
+                });
+            }
+        }
+    }
+
+    if let Some(items) = missing_flags {
+        for (i, item) in items.iter().enumerate() {
+            let path = item.get("path").and_then(Value::as_array).map(|arr| {
+                arr.iter()
+                    .filter_map(Value::as_str)
+                    .map(str::to_string)
+                    .collect::<Vec<_>>()
+            });
+            let key = item.get("key").and_then(Value::as_str).map(str::to_string);
+            let (Some(path), Some(key)) = (path, key) else {
+                continue;
+            };
+            if let Some(ex) = index.flags.get(&(path.clone(), key.clone())) {
+                violations.push(Violation {
+                    code: "REPORT_MISSING_INCLUDES_EXCLUDED",
+                    path: rel_path(&ctx.root, report_path),
+                    json_pointer: Some(format!("/deltas/missing_flags/{i}")),
+                    message: format!(
+                        "report missing_flags includes excluded flag (command_path={} key={} category={})",
+                        format_command_path(&path),
+                        key,
+                        ex.category.clone().unwrap_or_else(|| "<missing>".to_string())
+                    ),
+                    unit: Some("reports"),
+                    command_path: Some(format_command_path(&path)),
+                    key_or_name: Some(key),
+                    field: Some("missing_flags"),
+                    target_triple: None,
+                    details: None,
+                });
+            }
+        }
+    }
+
+    if let Some(items) = missing_args {
+        for (i, item) in items.iter().enumerate() {
+            let path = item.get("path").and_then(Value::as_array).map(|arr| {
+                arr.iter()
+                    .filter_map(Value::as_str)
+                    .map(str::to_string)
+                    .collect::<Vec<_>>()
+            });
+            let name = item.get("name").and_then(Value::as_str).map(str::to_string);
+            let (Some(path), Some(name)) = (path, name) else {
+                continue;
+            };
+            if let Some(ex) = index.args.get(&(path.clone(), name.clone())) {
+                violations.push(Violation {
+                    code: "REPORT_MISSING_INCLUDES_EXCLUDED",
+                    path: rel_path(&ctx.root, report_path),
+                    json_pointer: Some(format!("/deltas/missing_args/{i}")),
+                    message: format!(
+                        "report missing_args includes excluded arg (command_path={} name={} category={})",
+                        format_command_path(&path),
+                        name,
+                        ex.category.clone().unwrap_or_else(|| "<missing>".to_string())
+                    ),
+                    unit: Some("reports"),
+                    command_path: Some(format_command_path(&path)),
+                    key_or_name: Some(name),
+                    field: Some("missing_args"),
+                    target_triple: None,
+                    details: None,
+                });
+            }
+        }
+    }
+}
+
+fn cmp_path_tokens(a: &[String], b: &[String]) -> std::cmp::Ordering {
+    let mut i = 0usize;
+    while i < a.len() && i < b.len() {
+        match a[i].cmp(&b[i]) {
+            std::cmp::Ordering::Equal => i += 1,
+            non_eq => return non_eq,
+        }
+    }
+    a.len().cmp(&b.len())
+}
+
+fn cmp_iu_sort_key(a: &IuSortKey, b: &IuSortKey) -> std::cmp::Ordering {
+    a.kind_rank
+        .cmp(&b.kind_rank)
+        .then_with(|| cmp_path_tokens(&a.path, &b.path))
+        .then_with(|| a.key_or_name.cmp(&b.key_or_name))
+}
+
+fn validate_report_intentionally_unsupported(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    report: &Value,
+    report_path: &Path,
+) {
+    let Some(deltas) = report.get("deltas") else {
+        return;
+    };
+
+    for (list_name, items) in [
+        (
+            "missing_commands",
+            deltas.get("missing_commands").and_then(Value::as_array),
+        ),
+        (
+            "missing_flags",
+            deltas.get("missing_flags").and_then(Value::as_array),
+        ),
+        (
+            "missing_args",
+            deltas.get("missing_args").and_then(Value::as_array),
+        ),
+    ] {
+        let Some(items) = items else { continue };
+        for (i, item) in items.iter().enumerate() {
+            if item
+                .get("wrapper_level")
+                .and_then(Value::as_str)
+                .is_some_and(|s| s == "intentionally_unsupported")
+            {
+                violations.push(Violation {
+                    code: "REPORT_MISSING_INCLUDES_INTENTIONALLY_UNSUPPORTED",
+                    path: rel_path(&ctx.root, report_path),
+                    json_pointer: Some(format!("/deltas/{list_name}/{i}")),
+                    message: format!(
+                        "report {list_name} includes wrapper_level=intentionally_unsupported"
+                    ),
+                    unit: Some("reports"),
+                    command_path: item.get("path").and_then(Value::as_array).map(|arr| {
+                        arr.iter()
+                            .filter_map(Value::as_str)
+                            .collect::<Vec<_>>()
+                            .join(" ")
+                    }),
+                    key_or_name: item
+                        .get("key")
+                        .and_then(Value::as_str)
+                        .or_else(|| item.get("name").and_then(Value::as_str))
+                        .map(|s| s.to_string()),
+                    field: Some(list_name),
+                    target_triple: None,
+                    details: None,
+                });
+            }
+        }
+    }
+
+    let Some(iu_items) = deltas
+        .get("intentionally_unsupported")
+        .and_then(Value::as_array)
+    else {
+        return;
+    };
+
+    let mut keys = Vec::new();
+    for (i, item) in iu_items.iter().enumerate() {
+        let path = item.get("path").and_then(Value::as_array).map(|arr| {
+            arr.iter()
+                .filter_map(Value::as_str)
+                .map(str::to_string)
+                .collect::<Vec<_>>()
+        });
+        let Some(path) = path else { continue };
+
+        let kind_rank = if item.get("key").is_some() {
+            1u8
+        } else if item.get("name").is_some() {
+            2u8
+        } else {
+            0u8
+        };
+
+        let key_or_name = item
+            .get("key")
+            .and_then(Value::as_str)
+            .or_else(|| item.get("name").and_then(Value::as_str))
+            .unwrap_or("")
+            .to_string();
+
+        if item.get("wrapper_level").and_then(Value::as_str) != Some("intentionally_unsupported") {
+            violations.push(Violation {
+                code: "REPORT_IU_NOTE_MISSING",
+                path: rel_path(&ctx.root, report_path),
+                json_pointer: Some(format!("/deltas/intentionally_unsupported/{i}/wrapper_level")),
+                message:
+                    "intentionally_unsupported entry must have wrapper_level=intentionally_unsupported"
+                        .to_string(),
+                unit: Some("reports"),
+                command_path: Some(format_command_path(&path)),
+                key_or_name: if key_or_name.is_empty() {
+                    None
+                } else {
+                    Some(key_or_name.clone())
+                },
+                field: Some("intentionally_unsupported"),
+                target_triple: None,
+                details: None,
+            });
+        }
+
+        if item
+            .get("note")
+            .and_then(Value::as_str)
+            .unwrap_or("")
+            .trim()
+            .is_empty()
+        {
+            violations.push(Violation {
+                code: "REPORT_IU_NOTE_MISSING",
+                path: rel_path(&ctx.root, report_path),
+                json_pointer: Some(format!("/deltas/intentionally_unsupported/{i}/note")),
+                message: "intentionally_unsupported entry requires non-empty note".to_string(),
+                unit: Some("reports"),
+                command_path: Some(format_command_path(&path)),
+                key_or_name: if key_or_name.is_empty() {
+                    None
+                } else {
+                    Some(key_or_name.clone())
+                },
+                field: Some("note"),
+                target_triple: None,
+                details: None,
+            });
+        }
+
+        keys.push(IuSortKey {
+            kind_rank,
+            path,
+            key_or_name,
+        });
+    }
+
+    let mut sorted = keys.clone();
+    sorted.sort_by(cmp_iu_sort_key);
+    if keys != sorted {
+        violations.push(Violation {
+            code: "REPORT_IU_NOT_SORTED",
+            path: rel_path(&ctx.root, report_path),
+            json_pointer: Some("/deltas/intentionally_unsupported".to_string()),
+            message:
+                "deltas.intentionally_unsupported must be stable-sorted by (kind,path,key_or_name)"
+                    .to_string(),
+            unit: Some("reports"),
+            command_path: None,
+            key_or_name: None,
+            field: Some("intentionally_unsupported"),
+            target_triple: None,
+            details: None,
+        });
+    }
+}
diff --git a/crates/xtask/src/codex_validate/schema.rs b/crates/xtask/src/codex_validate/schema.rs
new file mode 100644
index 0000000..e7e70ec
--- /dev/null
+++ b/crates/xtask/src/codex_validate/schema.rs
@@ -0,0 +1,114 @@
+use std::{fs, io, path::Path};
+
+use jsonschema::JSONSchema;
+use serde_json::Value;
+
+use super::{rel_path, FatalError, ValidateCtx, Violation};
+
+pub(super) fn absolutize_schema_id(
+    schema: &mut Value,
+    schema_path: &Path,
+) -> Result<(), FatalError> {
+    let Some(id) = schema.get("$id").and_then(|v| v.as_str()) else {
+        return Ok(());
+    };
+
+    // `jsonschema` expects `$id` to be an absolute URI. Our committed schemas use
+    // repo-relative `$id` values (e.g. `cli_manifests/codex/SCHEMA.json`) for
+    // readability, so rewrite them to a file URI at runtime.
+    if id.contains("://") {
+        return Ok(());
+    }
+
+    let abs = fs::canonicalize(schema_path)?;
+    let abs_str = abs.to_string_lossy();
+    let file_uri = if abs_str.starts_with('/') {
+        format!("file://{abs_str}")
+    } else {
+        format!("file:///{abs_str}")
+    };
+
+    if let Some(obj) = schema.as_object_mut() {
+        obj.insert("$id".to_string(), Value::String(file_uri));
+    }
+
+    Ok(())
+}
+
+pub(super) fn schema_validate(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    schema: &JSONSchema,
+    instance: &Value,
+    path: &Path,
+    code: &'static str,
+) {
+    if let Err(errors) = schema.validate(instance) {
+        let mut errs = errors
+            .map(|e| {
+                let ptr = e.instance_path.to_string();
+                (ptr, e.to_string())
+            })
+            .collect::<Vec<_>>();
+        errs.sort_by(|a, b| a.0.cmp(&b.0).then_with(|| a.1.cmp(&b.1)));
+        for (ptr, msg) in errs {
+            violations.push(Violation {
+                code,
+                path: rel_path(&ctx.root, path),
+                json_pointer: if ptr.is_empty() { None } else { Some(ptr) },
+                message: msg,
+                unit: Some("schemas"),
+                command_path: None,
+                key_or_name: None,
+                field: Some("schema"),
+                target_triple: None,
+                details: None,
+            });
+        }
+    }
+}
+
+pub(super) fn read_json_file(
+    root: &Path,
+    path: &Path,
+    violations: &mut Vec<Violation>,
+    code_invalid_json: &'static str,
+) -> Option<Value> {
+    let bytes = match fs::read(path) {
+        Ok(b) => b,
+        Err(e) if e.kind() == io::ErrorKind::NotFound => return None,
+        Err(e) => {
+            violations.push(Violation {
+                code: "FILE_UNREADABLE",
+                path: rel_path(root, path),
+                json_pointer: None,
+                message: format!("failed to read file: {e}"),
+                unit: None,
+                command_path: None,
+                key_or_name: None,
+                field: None,
+                target_triple: None,
+                details: None,
+            });
+            return None;
+        }
+    };
+    match serde_json::from_slice::<Value>(&bytes) {
+        Ok(v) => Some(v),
+        Err(e) => {
+            violations.push(Violation {
+                code: code_invalid_json,
+                path: rel_path(root, path),
+                json_pointer: None,
+                message: format!("invalid JSON: {e}"),
+                unit: Some("schemas"),
+                command_path: None,
+                key_or_name: None,
+                field: Some("json"),
+                target_triple: None,
+                details: None,
+            });
+            None
+        }
+    }
+}
diff --git a/crates/xtask/src/codex_validate/wrapper_coverage.rs b/crates/xtask/src/codex_validate/wrapper_coverage.rs
new file mode 100644
index 0000000..bb1ad3d
--- /dev/null
+++ b/crates/xtask/src/codex_validate/wrapper_coverage.rs
@@ -0,0 +1,476 @@
+use std::{
+    collections::{BTreeMap, BTreeSet},
+    path::Path,
+};
+
+use serde_json::json;
+
+use super::{
+    format_command_path, rel_path, schema, ValidateCtx, Violation, WrapperCoverageFile,
+    WrapperScope,
+};
+
+pub(super) fn validate_wrapper_coverage(ctx: &mut ValidateCtx, violations: &mut Vec<Violation>) {
+    let path = ctx.root.join("wrapper_coverage.json");
+    let value = match schema::read_json_file(
+        &ctx.root,
+        &path,
+        violations,
+        "WRAPPER_COVERAGE_INVALID_JSON",
+    ) {
+        Some(v) => {
+            schema::schema_validate(
+                ctx,
+                violations,
+                &ctx.schema,
+                &v,
+                &path,
+                "WRAPPER_COVERAGE_SCHEMA_INVALID",
+            );
+            v
+        }
+        None => {
+            if path.exists() {
+                return;
+            }
+            violations.push(Violation {
+                code: "WRAPPER_COVERAGE_MISSING",
+                path: rel_path(&ctx.root, &path),
+                json_pointer: None,
+                message: "missing required file: wrapper_coverage.json".to_string(),
+                unit: Some("wrapper_coverage"),
+                command_path: None,
+                key_or_name: None,
+                field: Some("wrapper_coverage"),
+                target_triple: None,
+                details: None,
+            });
+            return;
+        }
+    };
+
+    let parsed: WrapperCoverageFile = match serde_json::from_value(value) {
+        Ok(v) => v,
+        Err(e) => {
+            violations.push(Violation {
+                code: "WRAPPER_COVERAGE_PARSE_FAILED",
+                path: rel_path(&ctx.root, &path),
+                json_pointer: None,
+                message: format!("failed to parse wrapper_coverage.json for semantic checks: {e}"),
+                unit: Some("wrapper_coverage"),
+                command_path: None,
+                key_or_name: None,
+                field: Some("wrapper_coverage"),
+                target_triple: None,
+                details: None,
+            });
+            return;
+        }
+    };
+
+    if parsed.schema_version != 1 {
+        violations.push(Violation {
+            code: "WRAPPER_COVERAGE_SCHEMA_VERSION",
+            path: rel_path(&ctx.root, &path),
+            json_pointer: Some("/schema_version".to_string()),
+            message: format!(
+                "wrapper_coverage.json schema_version must be 1 (got {})",
+                parsed.schema_version
+            ),
+            unit: Some("wrapper_coverage"),
+            command_path: None,
+            key_or_name: None,
+            field: Some("schema_version"),
+            target_triple: None,
+            details: None,
+        });
+    }
+
+    validate_wrapper_coverage_exclusions(ctx, violations, &parsed, &path);
+    validate_wrapper_iu_notes(ctx, violations, &parsed, &path);
+    validate_wrapper_scope_overlaps(ctx, violations, &parsed, &path);
+}
+
+fn validate_wrapper_iu_notes(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    wc: &WrapperCoverageFile,
+    path: &Path,
+) {
+    for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
+        if cmd.level == "intentionally_unsupported"
+            && cmd.note.as_deref().unwrap_or("").trim().is_empty()
+        {
+            violations.push(Violation {
+                code: "IU_NOTE_MISSING",
+                path: rel_path(&ctx.root, path),
+                json_pointer: Some(format!("/coverage/{cmd_idx}/note")),
+                message: format!(
+                    "intentionally_unsupported requires non-empty note (unit=command command_path={})",
+                    format_command_path(&cmd.path)
+                ),
+                unit: Some("wrapper_command"),
+                command_path: Some(format_command_path(&cmd.path)),
+                key_or_name: None,
+                field: Some("note"),
+                target_triple: None,
+                details: None,
+            });
+        }
+        for (flag_idx, flag) in cmd.flags.as_deref().unwrap_or(&[]).iter().enumerate() {
+            if flag.level == "intentionally_unsupported"
+                && flag.note.as_deref().unwrap_or("").trim().is_empty()
+            {
+                violations.push(Violation {
+                    code: "IU_NOTE_MISSING",
+                    path: rel_path(&ctx.root, path),
+                    json_pointer: Some(format!("/coverage/{cmd_idx}/flags/{flag_idx}/note")),
+                    message: format!(
+                        "intentionally_unsupported requires non-empty note (unit=flag command_path={} key={})",
+                        format_command_path(&cmd.path),
+                        flag.key
+                    ),
+                    unit: Some("wrapper_flag"),
+                    command_path: Some(format_command_path(&cmd.path)),
+                    key_or_name: Some(flag.key.clone()),
+                    field: Some("note"),
+                    target_triple: None,
+                    details: None,
+                });
+            }
+        }
+        for (arg_idx, arg) in cmd.args.as_deref().unwrap_or(&[]).iter().enumerate() {
+            if arg.level == "intentionally_unsupported"
+                && arg.note.as_deref().unwrap_or("").trim().is_empty()
+            {
+                violations.push(Violation {
+                    code: "IU_NOTE_MISSING",
+                    path: rel_path(&ctx.root, path),
+                    json_pointer: Some(format!("/coverage/{cmd_idx}/args/{arg_idx}/note")),
+                    message: format!(
+                        "intentionally_unsupported requires non-empty note (unit=arg command_path={} name={})",
+                        format_command_path(&cmd.path),
+                        arg.name
+                    ),
+                    unit: Some("wrapper_arg"),
+                    command_path: Some(format_command_path(&cmd.path)),
+                    key_or_name: Some(arg.name.clone()),
+                    field: Some("note"),
+                    target_triple: None,
+                    details: None,
+                });
+            }
+        }
+    }
+}
+
+fn validate_wrapper_scope_overlaps(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    wc: &WrapperCoverageFile,
+    path: &Path,
+) {
+    if !ctx.wrapper_rules.validation.disallow_overlapping_scopes {
+        return;
+    }
+
+    let expected = ctx
+        .expected_targets
+        .iter()
+        .cloned()
+        .collect::<BTreeSet<_>>();
+
+    // command_path overlap
+    if ctx
+        .wrapper_rules
+        .validation
+        .overlap_units
+        .iter()
+        .any(|u| u == "command_path")
+    {
+        let mut by_cmd = BTreeMap::<String, Vec<super::ScopedEntry>>::new();
+        for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
+            let cmd_targets = scope_to_targets(ctx, &expected, cmd.scope.as_ref());
+            by_cmd
+                .entry(format_command_path(&cmd.path))
+                .or_default()
+                .push(super::ScopedEntry {
+                    index: format!("coverage[{cmd_idx}]"),
+                    scope_kind: scope_kind(cmd.scope.as_ref()),
+                    targets: cmd_targets,
+                });
+        }
+        for (cmd_path, entries) in by_cmd {
+            detect_overlaps(
+                ctx,
+                violations,
+                path,
+                "WRAPPER_SCOPE_OVERLAP",
+                "command_path",
+                &cmd_path,
+                None,
+                entries,
+            );
+        }
+    }
+
+    // command_flag_key overlap
+    if ctx
+        .wrapper_rules
+        .validation
+        .overlap_units
+        .iter()
+        .any(|u| u == "command_flag_key")
+    {
+        let mut by_flag = BTreeMap::<(String, String), Vec<super::ScopedEntry>>::new();
+        for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
+            let cmd_targets = scope_to_targets(ctx, &expected, cmd.scope.as_ref());
+            for (flag_idx, flag) in cmd.flags.as_deref().unwrap_or(&[]).iter().enumerate() {
+                let flag_targets = scope_to_targets(ctx, &expected, flag.scope.as_ref());
+                let effective = intersect(&cmd_targets, &flag_targets);
+                by_flag
+                    .entry((format_command_path(&cmd.path), flag.key.clone()))
+                    .or_default()
+                    .push(super::ScopedEntry {
+                        index: format!("coverage[{cmd_idx}].flags[{flag_idx}]"),
+                        scope_kind: scope_kind(flag.scope.as_ref()),
+                        targets: effective,
+                    });
+            }
+        }
+        for ((cmd_path, key), entries) in by_flag {
+            detect_overlaps(
+                ctx,
+                violations,
+                path,
+                "WRAPPER_SCOPE_OVERLAP",
+                "flag",
+                &cmd_path,
+                Some(key),
+                entries,
+            );
+        }
+    }
+
+    // command_arg_name overlap
+    if ctx
+        .wrapper_rules
+        .validation
+        .overlap_units
+        .iter()
+        .any(|u| u == "command_arg_name")
+    {
+        let mut by_arg = BTreeMap::<(String, String), Vec<super::ScopedEntry>>::new();
+        for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
+            let cmd_targets = scope_to_targets(ctx, &expected, cmd.scope.as_ref());
+            for (arg_idx, arg) in cmd.args.as_deref().unwrap_or(&[]).iter().enumerate() {
+                let arg_targets = scope_to_targets(ctx, &expected, arg.scope.as_ref());
+                let effective = intersect(&cmd_targets, &arg_targets);
+                by_arg
+                    .entry((format_command_path(&cmd.path), arg.name.clone()))
+                    .or_default()
+                    .push(super::ScopedEntry {
+                        index: format!("coverage[{cmd_idx}].args[{arg_idx}]"),
+                        scope_kind: scope_kind(arg.scope.as_ref()),
+                        targets: effective,
+                    });
+            }
+        }
+        for ((cmd_path, name), entries) in by_arg {
+            detect_overlaps(
+                ctx,
+                violations,
+                path,
+                "WRAPPER_SCOPE_OVERLAP",
+                "arg",
+                &cmd_path,
+                Some(name),
+                entries,
+            );
+        }
+    }
+}
+
+#[allow(clippy::too_many_arguments)]
+fn detect_overlaps(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    path: &Path,
+    code: &'static str,
+    unit: &'static str,
+    cmd_path: &str,
+    key_or_name: Option<String>,
+    entries: Vec<super::ScopedEntry>,
+) {
+    if entries.len() <= 1 {
+        return;
+    }
+    for target in &ctx.expected_targets {
+        let matching = entries
+            .iter()
+            .filter(|e| e.targets.contains(target))
+            .collect::<Vec<_>>();
+        if matching.len() <= 1 {
+            continue;
+        }
+        let indexes = matching
+            .iter()
+            .map(|e| e.index.as_str())
+            .collect::<Vec<_>>()
+            .join(",");
+        let mut msg = format!(
+            "overlapping wrapper_coverage scopes are manifest-invalid (unit={unit} command_path={cmd_path} target_triple={target} matching_entry_indexes=[{indexes}])"
+        );
+        if let Some(k) = key_or_name.as_deref() {
+            msg.push_str(&format!(" key_or_name={k}"));
+        }
+        violations.push(Violation {
+            code,
+            path: rel_path(&ctx.root, path),
+            json_pointer: None,
+            message: msg,
+            unit: Some("wrapper_coverage"),
+            command_path: Some(cmd_path.to_string()),
+            key_or_name: key_or_name.clone(),
+            field: Some("scope"),
+            target_triple: Some(target.to_string()),
+            details: Some(json!({
+                "matching_entry_indexes": matching.iter().map(|e| e.index.clone()).collect::<Vec<_>>(),
+                "matching_entry_scope_kinds": matching.iter().map(|e| e.scope_kind).collect::<Vec<_>>(),
+            })),
+        });
+    }
+}
+
+fn scope_kind(scope: Option<&WrapperScope>) -> &'static str {
+    let Some(scope) = scope else {
+        return "no_scope";
+    };
+    if scope.target_triples.as_ref().is_some_and(|v| !v.is_empty()) {
+        return "target_triples";
+    }
+    if scope.platforms.as_ref().is_some_and(|v| !v.is_empty()) {
+        return "platforms";
+    }
+    "no_scope"
+}
+
+fn scope_to_targets(
+    ctx: &ValidateCtx,
+    expected: &BTreeSet<String>,
+    scope: Option<&WrapperScope>,
+) -> BTreeSet<String> {
+    let Some(scope) = scope else {
+        return expected.clone();
+    };
+
+    let mut out = BTreeSet::<String>::new();
+    if let Some(tt) = scope.target_triples.as_ref() {
+        for t in tt {
+            if expected.contains(t) {
+                out.insert(t.clone());
+            }
+        }
+    }
+    if let Some(platforms) = scope.platforms.as_ref() {
+        if ctx
+            .wrapper_rules
+            .scope_semantics
+            .platforms_expand_to_expected_targets
+        {
+            for t in expected {
+                if let Some(p) = ctx.platform_mapping.get(t) {
+                    if platforms.iter().any(|pl| pl == p) {
+                        out.insert(t.clone());
+                    }
+                }
+            }
+        }
+    }
+
+    if out.is_empty() {
+        // Treat an empty/unknown scope as applying to no expected targets.
+        return BTreeSet::new();
+    }
+    out
+}
+
+fn intersect(a: &BTreeSet<String>, b: &BTreeSet<String>) -> BTreeSet<String> {
+    a.intersection(b).cloned().collect()
+}
+
+fn validate_wrapper_coverage_exclusions(
+    ctx: &ValidateCtx,
+    violations: &mut Vec<Violation>,
+    wc: &WrapperCoverageFile,
+    wc_path: &Path,
+) {
+    let Some(index) = ctx.parity_exclusions.as_ref() else {
+        return;
+    };
+
+    for (cmd_idx, cmd) in wc.coverage.iter().enumerate() {
+        if let Some(ex) = index.commands.get(&cmd.path) {
+            violations.push(Violation {
+                code: "WRAPPER_COVERAGE_INCLUDES_EXCLUDED",
+                path: rel_path(&ctx.root, wc_path),
+                json_pointer: Some(format!("/coverage/{cmd_idx}")),
+                message: format!(
+                    "wrapper_coverage includes excluded command_path={} (note={})",
+                    format_command_path(&cmd.path),
+                    ex.note
+                ),
+                unit: Some("wrapper_command"),
+                command_path: Some(format_command_path(&cmd.path)),
+                key_or_name: None,
+                field: Some("coverage"),
+                target_triple: None,
+                details: None,
+            });
+        }
+
+        for (flag_idx, flag) in cmd.flags.as_deref().unwrap_or(&[]).iter().enumerate() {
+            if let Some(ex) = index.flags.get(&(cmd.path.clone(), flag.key.clone())) {
+                violations.push(Violation {
+                    code: "WRAPPER_COVERAGE_INCLUDES_EXCLUDED",
+                    path: rel_path(&ctx.root, wc_path),
+                    json_pointer: Some(format!("/coverage/{cmd_idx}/flags/{flag_idx}")),
+                    message: format!(
+                        "wrapper_coverage includes excluded flag (command_path={} key={} note={})",
+                        format_command_path(&cmd.path),
+                        flag.key,
+                        ex.note
+                    ),
+                    unit: Some("wrapper_flag"),
+                    command_path: Some(format_command_path(&cmd.path)),
+                    key_or_name: Some(flag.key.clone()),
+                    field: Some("flags"),
+                    target_triple: None,
+                    details: None,
+                });
+            }
+        }
+
+        for (arg_idx, arg) in cmd.args.as_deref().unwrap_or(&[]).iter().enumerate() {
+            if let Some(ex) = index.args.get(&(cmd.path.clone(), arg.name.clone())) {
+                violations.push(Violation {
+                    code: "WRAPPER_COVERAGE_INCLUDES_EXCLUDED",
+                    path: rel_path(&ctx.root, wc_path),
+                    json_pointer: Some(format!("/coverage/{cmd_idx}/args/{arg_idx}")),
+                    message: format!(
+                        "wrapper_coverage includes excluded arg (command_path={} name={} note={})",
+                        format_command_path(&cmd.path),
+                        arg.name,
+                        ex.note
+                    ),
+                    unit: Some("wrapper_arg"),
+                    command_path: Some(format_command_path(&cmd.path)),
+                    key_or_name: Some(arg.name.clone()),
+                    field: Some("args"),
+                    target_triple: None,
+                    details: None,
+                });
+            }
+        }
+    }
+}
