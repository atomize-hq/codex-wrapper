diff --git a/crates/codex/src/builder/cli_overrides.rs b/crates/codex/src/builder/cli_overrides.rs
new file mode 100644
index 0000000..f1604c6
--- /dev/null
+++ b/crates/codex/src/builder/cli_overrides.rs
@@ -0,0 +1,204 @@
+use std::{ffi::OsString, path::PathBuf};
+
+use tokio::process::Command;
+
+use super::{
+    ApprovalPolicy, CliOverrides, CliOverridesPatch, ConfigOverride, FeatureToggles, FlagState,
+    LocalProvider, SafetyOverride, SandboxMode,
+};
+
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5: &[(&str, &str)] = &[
+    ("model_reasoning_effort", "medium"),
+    ("model_reasoning_summary", "auto"),
+    ("model_verbosity", "low"),
+];
+
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5_CODEX: &[(&str, &str)] = &[
+    ("model_reasoning_effort", "medium"),
+    ("model_reasoning_summary", "auto"),
+    ("model_verbosity", "low"),
+];
+
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5_1: &[(&str, &str)] = &[
+    ("model_reasoning_effort", "medium"),
+    ("model_reasoning_summary", "auto"),
+    ("model_verbosity", "low"),
+];
+
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub(crate) struct ResolvedCliOverrides {
+    pub(crate) config_overrides: Vec<ConfigOverride>,
+    pub(crate) feature_toggles: FeatureToggles,
+    pub(crate) approval_policy: Option<ApprovalPolicy>,
+    pub(crate) sandbox_mode: Option<SandboxMode>,
+    pub(crate) safety_override: SafetyOverride,
+    pub(crate) profile: Option<String>,
+    pub(crate) cd: Option<PathBuf>,
+    pub(crate) local_provider: Option<LocalProvider>,
+    pub(crate) oss: bool,
+    pub(crate) search: FlagState,
+}
+
+impl ResolvedCliOverrides {
+    fn search_enabled(&self) -> bool {
+        matches!(self.search, FlagState::Enable)
+    }
+}
+
+pub(super) fn reasoning_config_for(
+    model: Option<&str>,
+) -> Option<&'static [(&'static str, &'static str)]> {
+    let name = model.map(|value| value.to_ascii_lowercase())?;
+    match name.as_str() {
+        name if name.starts_with("gpt-5.1-codex") => Some(DEFAULT_REASONING_CONFIG_GPT5_1),
+        name if name.starts_with("gpt-5.1") => Some(DEFAULT_REASONING_CONFIG_GPT5_1),
+        "gpt-5-codex" => Some(DEFAULT_REASONING_CONFIG_GPT5_CODEX),
+        name if name.starts_with("gpt-5") => Some(DEFAULT_REASONING_CONFIG_GPT5),
+        _ => None,
+    }
+}
+
+fn has_reasoning_config_override(overrides: &[ConfigOverride]) -> bool {
+    overrides.iter().any(ConfigOverride::is_reasoning_key)
+}
+
+pub(super) fn resolve_cli_overrides(
+    builder: &CliOverrides,
+    patch: &CliOverridesPatch,
+    model: Option<&str>,
+) -> ResolvedCliOverrides {
+    let auto_reasoning_defaults = patch
+        .auto_reasoning_defaults
+        .unwrap_or(builder.auto_reasoning_defaults);
+
+    let has_reasoning_overrides = builder.reasoning.has_overrides()
+        || patch.reasoning.has_overrides()
+        || has_reasoning_config_override(&builder.config_overrides)
+        || has_reasoning_config_override(&patch.config_overrides);
+
+    let mut config_overrides = Vec::new();
+    if auto_reasoning_defaults && !has_reasoning_overrides {
+        if let Some(defaults) = reasoning_config_for(model) {
+            for (key, value) in defaults {
+                config_overrides.push(ConfigOverride::new(*key, *value));
+            }
+        }
+    }
+
+    config_overrides.extend(builder.config_overrides.clone());
+    builder.reasoning.append_overrides(&mut config_overrides);
+    config_overrides.extend(patch.config_overrides.clone());
+    patch.reasoning.append_overrides(&mut config_overrides);
+
+    let approval_policy = patch.approval_policy.or(builder.approval_policy);
+    let sandbox_mode = patch.sandbox_mode.or(builder.sandbox_mode);
+    let safety_override = patch.safety_override.unwrap_or(builder.safety_override);
+    let profile = patch.profile.clone().or_else(|| builder.profile.clone());
+    let cd = patch.cd.clone().or_else(|| builder.cd.clone());
+    let local_provider = patch.local_provider.or(builder.local_provider);
+    let search = match patch.search {
+        FlagState::Inherit => builder.search,
+        other => other,
+    };
+    let oss = match patch.oss {
+        FlagState::Inherit => builder.oss,
+        other => other,
+    };
+    let mut feature_toggles = builder.feature_toggles.clone();
+    feature_toggles
+        .enable
+        .extend(patch.feature_toggles.enable.iter().cloned());
+    feature_toggles
+        .disable
+        .extend(patch.feature_toggles.disable.iter().cloned());
+
+    ResolvedCliOverrides {
+        config_overrides,
+        feature_toggles,
+        approval_policy,
+        sandbox_mode,
+        safety_override,
+        profile,
+        cd,
+        local_provider,
+        oss: matches!(oss, FlagState::Enable),
+        search,
+    }
+}
+
+pub(super) fn cli_override_args(
+    resolved: &ResolvedCliOverrides,
+    include_search: bool,
+) -> Vec<OsString> {
+    let mut args = Vec::new();
+    for config in &resolved.config_overrides {
+        args.push(OsString::from("--config"));
+        args.push(OsString::from(format!("{}={}", config.key, config.value)));
+    }
+
+    for feature in &resolved.feature_toggles.enable {
+        args.push(OsString::from("--enable"));
+        args.push(OsString::from(feature));
+    }
+
+    for feature in &resolved.feature_toggles.disable {
+        args.push(OsString::from("--disable"));
+        args.push(OsString::from(feature));
+    }
+
+    if let Some(profile) = &resolved.profile {
+        args.push(OsString::from("--profile"));
+        args.push(OsString::from(profile));
+    }
+
+    match resolved.safety_override {
+        SafetyOverride::DangerouslyBypass => {
+            args.push(OsString::from("--dangerously-bypass-approvals-and-sandbox"));
+        }
+        other => {
+            if let Some(policy) = resolved.approval_policy {
+                args.push(OsString::from("--ask-for-approval"));
+                args.push(OsString::from(policy.as_str()));
+            }
+
+            if let Some(mode) = resolved.sandbox_mode {
+                args.push(OsString::from("--sandbox"));
+                args.push(OsString::from(mode.as_str()));
+            } else if resolved.approval_policy.is_none()
+                && matches!(other, SafetyOverride::FullAuto)
+            {
+                args.push(OsString::from("--full-auto"));
+            }
+        }
+    }
+
+    if let Some(cd) = &resolved.cd {
+        args.push(OsString::from("--cd"));
+        args.push(cd.as_os_str().to_os_string());
+    }
+
+    if let Some(provider) = resolved.local_provider {
+        args.push(OsString::from("--local-provider"));
+        args.push(OsString::from(provider.as_str()));
+    }
+
+    if resolved.oss {
+        args.push(OsString::from("--oss"));
+    }
+
+    if include_search && resolved.search_enabled() {
+        args.push(OsString::from("--search"));
+    }
+
+    args
+}
+
+pub(super) fn apply_cli_overrides(
+    command: &mut Command,
+    resolved: &ResolvedCliOverrides,
+    include_search: bool,
+) {
+    for arg in cli_override_args(resolved, include_search) {
+        command.arg(arg);
+    }
+}
diff --git a/crates/codex/src/builder.rs b/crates/codex/src/builder/mod.rs
similarity index 52%
rename from crates/codex/src/builder.rs
rename to crates/codex/src/builder/mod.rs
index afb6530..c69d160 100644
--- a/crates/codex/src/builder.rs
+++ b/crates/codex/src/builder/mod.rs
@@ -1,26 +1,62 @@
-use std::{ffi::OsString, path::PathBuf, time::Duration};
+use std::{path::PathBuf, time::Duration};
 
-use tokio::process::Command;
+#[cfg(test)]
+use std::ffi::OsString;
 
 use crate::home::CommandEnvironment;
+use tokio::process::Command;
+
+mod cli_overrides;
+mod types;
 
-pub(super) const DEFAULT_REASONING_CONFIG_GPT5: &[(&str, &str)] = &[
-    ("model_reasoning_effort", "medium"),
-    ("model_reasoning_summary", "auto"),
-    ("model_verbosity", "low"),
-];
+pub use types::{
+    ApprovalPolicy, CliOverrides, CliOverridesPatch, ColorMode, ConfigOverride, FeatureToggles,
+    FlagState, LocalProvider, ModelVerbosity, ReasoningEffort, ReasoningOverrides,
+    ReasoningSummary, ReasoningSummaryFormat, SafetyOverride, SandboxMode,
+};
 
-pub(super) const DEFAULT_REASONING_CONFIG_GPT5_CODEX: &[(&str, &str)] = &[
-    ("model_reasoning_effort", "medium"),
-    ("model_reasoning_summary", "auto"),
-    ("model_verbosity", "low"),
-];
+pub(super) type ResolvedCliOverrides = cli_overrides::ResolvedCliOverrides;
+
+#[cfg(test)]
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5: &[(&str, &str)] =
+    cli_overrides::DEFAULT_REASONING_CONFIG_GPT5;
+#[cfg(test)]
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5_CODEX: &[(&str, &str)] =
+    cli_overrides::DEFAULT_REASONING_CONFIG_GPT5_CODEX;
+#[cfg(test)]
+pub(super) const DEFAULT_REASONING_CONFIG_GPT5_1: &[(&str, &str)] =
+    cli_overrides::DEFAULT_REASONING_CONFIG_GPT5_1;
+
+#[cfg(test)]
+pub(super) fn reasoning_config_for(
+    model: Option<&str>,
+) -> Option<&'static [(&'static str, &'static str)]> {
+    cli_overrides::reasoning_config_for(model)
+}
+
+pub(super) fn resolve_cli_overrides(
+    builder: &CliOverrides,
+    patch: &CliOverridesPatch,
+    model: Option<&str>,
+) -> ResolvedCliOverrides {
+    cli_overrides::resolve_cli_overrides(builder, patch, model)
+}
 
-pub(super) const DEFAULT_REASONING_CONFIG_GPT5_1: &[(&str, &str)] = &[
-    ("model_reasoning_effort", "medium"),
-    ("model_reasoning_summary", "auto"),
-    ("model_verbosity", "low"),
-];
+#[cfg(test)]
+pub(super) fn cli_override_args(
+    resolved: &ResolvedCliOverrides,
+    include_search: bool,
+) -> Vec<OsString> {
+    cli_overrides::cli_override_args(resolved, include_search)
+}
+
+pub(super) fn apply_cli_overrides(
+    command: &mut Command,
+    resolved: &ResolvedCliOverrides,
+    include_search: bool,
+) {
+    cli_overrides::apply_cli_overrides(command, resolved, include_search);
+}
 
 /// Builder for [`crate::CodexClient`].
 ///
@@ -427,497 +463,3 @@ impl Default for CodexClientBuilder {
         }
     }
 }
-
-/// ANSI color behavior for `codex exec` output.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ColorMode {
-    /// Match upstream defaults: use color codes when stdout/stderr look like terminals.
-    Auto,
-    /// Force colorful output even when piping.
-    Always,
-    /// Fully disable ANSI sequences for deterministic parsing/logging (default).
-    Never,
-}
-
-impl ColorMode {
-    pub(super) const fn as_str(self) -> &'static str {
-        match self {
-            ColorMode::Auto => "auto",
-            ColorMode::Always => "always",
-            ColorMode::Never => "never",
-        }
-    }
-}
-
-/// Approval policy used by `--ask-for-approval`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ApprovalPolicy {
-    Untrusted,
-    OnFailure,
-    OnRequest,
-    Never,
-}
-
-impl ApprovalPolicy {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ApprovalPolicy::Untrusted => "untrusted",
-            ApprovalPolicy::OnFailure => "on-failure",
-            ApprovalPolicy::OnRequest => "on-request",
-            ApprovalPolicy::Never => "never",
-        }
-    }
-}
-
-/// Sandbox isolation level.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum SandboxMode {
-    ReadOnly,
-    WorkspaceWrite,
-    DangerFullAccess,
-}
-
-impl SandboxMode {
-    const fn as_str(self) -> &'static str {
-        match self {
-            SandboxMode::ReadOnly => "read-only",
-            SandboxMode::WorkspaceWrite => "workspace-write",
-            SandboxMode::DangerFullAccess => "danger-full-access",
-        }
-    }
-}
-
-/// Safety overrides that collapse approval/sandbox behavior.
-#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
-pub enum SafetyOverride {
-    #[default]
-    Inherit,
-    FullAuto,
-    DangerouslyBypass,
-}
-
-/// Local provider selection for OSS backends.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum LocalProvider {
-    LmStudio,
-    Ollama,
-    Custom,
-}
-
-impl LocalProvider {
-    const fn as_str(self) -> &'static str {
-        match self {
-            LocalProvider::LmStudio => "lmstudio",
-            LocalProvider::Ollama => "ollama",
-            LocalProvider::Custom => "custom",
-        }
-    }
-}
-
-/// Three-state flag used when requests can override builder defaults.
-#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
-pub enum FlagState {
-    #[default]
-    Inherit,
-    Enable,
-    Disable,
-}
-
-/// Feature toggles forwarded to `--enable/--disable`.
-#[derive(Clone, Debug, Default, Eq, PartialEq)]
-pub struct FeatureToggles {
-    pub enable: Vec<String>,
-    pub disable: Vec<String>,
-}
-
-/// Config values for `model_reasoning_effort`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ReasoningEffort {
-    Minimal,
-    Low,
-    Medium,
-    High,
-}
-
-impl ReasoningEffort {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ReasoningEffort::Minimal => "minimal",
-            ReasoningEffort::Low => "low",
-            ReasoningEffort::Medium => "medium",
-            ReasoningEffort::High => "high",
-        }
-    }
-}
-
-/// Config values for `model_reasoning_summary`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ReasoningSummary {
-    Auto,
-    Concise,
-    Detailed,
-    None,
-}
-
-impl ReasoningSummary {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ReasoningSummary::Auto => "auto",
-            ReasoningSummary::Concise => "concise",
-            ReasoningSummary::Detailed => "detailed",
-            ReasoningSummary::None => "none",
-        }
-    }
-}
-
-/// Config values for `model_verbosity`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ModelVerbosity {
-    Low,
-    Medium,
-    High,
-}
-
-impl ModelVerbosity {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ModelVerbosity::Low => "low",
-            ModelVerbosity::Medium => "medium",
-            ModelVerbosity::High => "high",
-        }
-    }
-}
-
-/// Config values for `model_reasoning_summary_format`.
-#[derive(Clone, Copy, Debug, Eq, PartialEq)]
-pub enum ReasoningSummaryFormat {
-    None,
-    Experimental,
-}
-
-impl ReasoningSummaryFormat {
-    const fn as_str(self) -> &'static str {
-        match self {
-            ReasoningSummaryFormat::None => "none",
-            ReasoningSummaryFormat::Experimental => "experimental",
-        }
-    }
-}
-
-/// Represents a single `--config key=value` override.
-#[derive(Clone, Debug, Eq, PartialEq)]
-pub struct ConfigOverride {
-    pub key: String,
-    pub value: String,
-}
-
-impl ConfigOverride {
-    pub fn new(key: impl Into<String>, value: impl Into<String>) -> Self {
-        Self {
-            key: key.into(),
-            value: value.into(),
-        }
-    }
-
-    pub fn from_raw(raw: impl Into<String>) -> Self {
-        let raw = raw.into();
-        let (key, value) = raw
-            .split_once('=')
-            .map(|(key, value)| (key.to_string(), value.to_string()))
-            .unwrap_or_else(|| (raw.clone(), String::new()));
-        ConfigOverride { key, value }
-    }
-
-    fn is_reasoning_key(&self) -> bool {
-        REASONING_CONFIG_KEYS.contains(&self.key.as_str())
-    }
-}
-
-/// Structured reasoning overrides converted into config entries.
-#[derive(Clone, Debug, Default, Eq, PartialEq)]
-pub struct ReasoningOverrides {
-    pub effort: Option<ReasoningEffort>,
-    pub summary: Option<ReasoningSummary>,
-    pub verbosity: Option<ModelVerbosity>,
-    pub summary_format: Option<ReasoningSummaryFormat>,
-    pub supports_summaries: Option<bool>,
-}
-
-impl ReasoningOverrides {
-    pub(super) fn has_overrides(&self) -> bool {
-        self.effort.is_some()
-            || self.summary.is_some()
-            || self.verbosity.is_some()
-            || self.summary_format.is_some()
-            || self.supports_summaries.is_some()
-    }
-
-    fn append_overrides(&self, configs: &mut Vec<ConfigOverride>) {
-        if let Some(value) = self.effort {
-            configs.push(ConfigOverride::new(
-                "model_reasoning_effort",
-                value.as_str(),
-            ));
-        }
-        if let Some(value) = self.summary {
-            configs.push(ConfigOverride::new(
-                "model_reasoning_summary",
-                value.as_str(),
-            ));
-        }
-        if let Some(value) = self.verbosity {
-            configs.push(ConfigOverride::new("model_verbosity", value.as_str()));
-        }
-        if let Some(value) = self.summary_format {
-            configs.push(ConfigOverride::new(
-                "model_reasoning_summary_format",
-                value.as_str(),
-            ));
-        }
-        if let Some(value) = self.supports_summaries {
-            configs.push(ConfigOverride::new(
-                "model_supports_reasoning_summaries",
-                value.to_string(),
-            ));
-        }
-    }
-}
-
-/// Builder-scoped CLI overrides.
-#[derive(Clone, Debug, Eq, PartialEq)]
-pub struct CliOverrides {
-    pub config_overrides: Vec<ConfigOverride>,
-    pub feature_toggles: FeatureToggles,
-    pub reasoning: ReasoningOverrides,
-    pub approval_policy: Option<ApprovalPolicy>,
-    pub sandbox_mode: Option<SandboxMode>,
-    pub safety_override: SafetyOverride,
-    pub profile: Option<String>,
-    pub cd: Option<PathBuf>,
-    pub local_provider: Option<LocalProvider>,
-    pub oss: FlagState,
-    pub search: FlagState,
-    pub auto_reasoning_defaults: bool,
-}
-
-impl Default for CliOverrides {
-    fn default() -> Self {
-        Self {
-            config_overrides: Vec::new(),
-            feature_toggles: FeatureToggles::default(),
-            reasoning: ReasoningOverrides::default(),
-            approval_policy: None,
-            sandbox_mode: None,
-            safety_override: SafetyOverride::Inherit,
-            profile: None,
-            cd: None,
-            local_provider: None,
-            oss: FlagState::Inherit,
-            search: FlagState::Inherit,
-            auto_reasoning_defaults: true,
-        }
-    }
-}
-
-/// Request-level overlay of builder overrides.
-#[derive(Clone, Debug, Default, Eq, PartialEq)]
-pub struct CliOverridesPatch {
-    pub config_overrides: Vec<ConfigOverride>,
-    pub feature_toggles: FeatureToggles,
-    pub reasoning: ReasoningOverrides,
-    pub approval_policy: Option<ApprovalPolicy>,
-    pub sandbox_mode: Option<SandboxMode>,
-    pub safety_override: Option<SafetyOverride>,
-    pub profile: Option<String>,
-    pub cd: Option<PathBuf>,
-    pub local_provider: Option<LocalProvider>,
-    pub oss: FlagState,
-    pub search: FlagState,
-    pub auto_reasoning_defaults: Option<bool>,
-}
-
-#[derive(Clone, Debug, Eq, PartialEq)]
-pub(super) struct ResolvedCliOverrides {
-    pub(super) config_overrides: Vec<ConfigOverride>,
-    pub(super) feature_toggles: FeatureToggles,
-    pub(super) approval_policy: Option<ApprovalPolicy>,
-    pub(super) sandbox_mode: Option<SandboxMode>,
-    pub(super) safety_override: SafetyOverride,
-    pub(super) profile: Option<String>,
-    pub(super) cd: Option<PathBuf>,
-    pub(super) local_provider: Option<LocalProvider>,
-    pub(super) oss: bool,
-    pub(super) search: FlagState,
-}
-
-impl ResolvedCliOverrides {
-    fn search_enabled(&self) -> bool {
-        matches!(self.search, FlagState::Enable)
-    }
-}
-
-const REASONING_CONFIG_KEYS: &[&str] = &[
-    "model_reasoning_effort",
-    "model_reasoning_summary",
-    "model_verbosity",
-    "model_reasoning_summary_format",
-    "model_supports_reasoning_summaries",
-];
-
-pub(super) fn reasoning_config_for(
-    model: Option<&str>,
-) -> Option<&'static [(&'static str, &'static str)]> {
-    let name = model.map(|value| value.to_ascii_lowercase())?;
-    match name.as_str() {
-        name if name.starts_with("gpt-5.1-codex") => Some(DEFAULT_REASONING_CONFIG_GPT5_1),
-        name if name.starts_with("gpt-5.1") => Some(DEFAULT_REASONING_CONFIG_GPT5_1),
-        "gpt-5-codex" => Some(DEFAULT_REASONING_CONFIG_GPT5_CODEX),
-        name if name.starts_with("gpt-5") => Some(DEFAULT_REASONING_CONFIG_GPT5),
-        _ => None,
-    }
-}
-
-fn has_reasoning_config_override(overrides: &[ConfigOverride]) -> bool {
-    overrides.iter().any(ConfigOverride::is_reasoning_key)
-}
-
-pub(super) fn resolve_cli_overrides(
-    builder: &CliOverrides,
-    patch: &CliOverridesPatch,
-    model: Option<&str>,
-) -> ResolvedCliOverrides {
-    let auto_reasoning_defaults = patch
-        .auto_reasoning_defaults
-        .unwrap_or(builder.auto_reasoning_defaults);
-
-    let has_reasoning_overrides = builder.reasoning.has_overrides()
-        || patch.reasoning.has_overrides()
-        || has_reasoning_config_override(&builder.config_overrides)
-        || has_reasoning_config_override(&patch.config_overrides);
-
-    let mut config_overrides = Vec::new();
-    if auto_reasoning_defaults && !has_reasoning_overrides {
-        if let Some(defaults) = reasoning_config_for(model) {
-            for (key, value) in defaults {
-                config_overrides.push(ConfigOverride::new(*key, *value));
-            }
-        }
-    }
-
-    config_overrides.extend(builder.config_overrides.clone());
-    builder.reasoning.append_overrides(&mut config_overrides);
-    config_overrides.extend(patch.config_overrides.clone());
-    patch.reasoning.append_overrides(&mut config_overrides);
-
-    let approval_policy = patch.approval_policy.or(builder.approval_policy);
-    let sandbox_mode = patch.sandbox_mode.or(builder.sandbox_mode);
-    let safety_override = patch.safety_override.unwrap_or(builder.safety_override);
-    let profile = patch.profile.clone().or_else(|| builder.profile.clone());
-    let cd = patch.cd.clone().or_else(|| builder.cd.clone());
-    let local_provider = patch.local_provider.or(builder.local_provider);
-    let search = match patch.search {
-        FlagState::Inherit => builder.search,
-        other => other,
-    };
-    let oss = match patch.oss {
-        FlagState::Inherit => builder.oss,
-        other => other,
-    };
-    let mut feature_toggles = builder.feature_toggles.clone();
-    feature_toggles
-        .enable
-        .extend(patch.feature_toggles.enable.iter().cloned());
-    feature_toggles
-        .disable
-        .extend(patch.feature_toggles.disable.iter().cloned());
-
-    ResolvedCliOverrides {
-        config_overrides,
-        feature_toggles,
-        approval_policy,
-        sandbox_mode,
-        safety_override,
-        profile,
-        cd,
-        local_provider,
-        oss: matches!(oss, FlagState::Enable),
-        search,
-    }
-}
-
-pub(super) fn cli_override_args(
-    resolved: &ResolvedCliOverrides,
-    include_search: bool,
-) -> Vec<OsString> {
-    let mut args = Vec::new();
-    for config in &resolved.config_overrides {
-        args.push(OsString::from("--config"));
-        args.push(OsString::from(format!("{}={}", config.key, config.value)));
-    }
-
-    for feature in &resolved.feature_toggles.enable {
-        args.push(OsString::from("--enable"));
-        args.push(OsString::from(feature));
-    }
-
-    for feature in &resolved.feature_toggles.disable {
-        args.push(OsString::from("--disable"));
-        args.push(OsString::from(feature));
-    }
-
-    if let Some(profile) = &resolved.profile {
-        args.push(OsString::from("--profile"));
-        args.push(OsString::from(profile));
-    }
-
-    match resolved.safety_override {
-        SafetyOverride::DangerouslyBypass => {
-            args.push(OsString::from("--dangerously-bypass-approvals-and-sandbox"));
-        }
-        other => {
-            if let Some(policy) = resolved.approval_policy {
-                args.push(OsString::from("--ask-for-approval"));
-                args.push(OsString::from(policy.as_str()));
-            }
-
-            if let Some(mode) = resolved.sandbox_mode {
-                args.push(OsString::from("--sandbox"));
-                args.push(OsString::from(mode.as_str()));
-            } else if resolved.approval_policy.is_none()
-                && matches!(other, SafetyOverride::FullAuto)
-            {
-                args.push(OsString::from("--full-auto"));
-            }
-        }
-    }
-
-    if let Some(cd) = &resolved.cd {
-        args.push(OsString::from("--cd"));
-        args.push(cd.as_os_str().to_os_string());
-    }
-
-    if let Some(provider) = resolved.local_provider {
-        args.push(OsString::from("--local-provider"));
-        args.push(OsString::from(provider.as_str()));
-    }
-
-    if resolved.oss {
-        args.push(OsString::from("--oss"));
-    }
-
-    if include_search && resolved.search_enabled() {
-        args.push(OsString::from("--search"));
-    }
-
-    args
-}
-
-pub(super) fn apply_cli_overrides(
-    command: &mut Command,
-    resolved: &ResolvedCliOverrides,
-    include_search: bool,
-) {
-    for arg in cli_override_args(resolved, include_search) {
-        command.arg(arg);
-    }
-}
diff --git a/crates/codex/src/builder/types.rs b/crates/codex/src/builder/types.rs
new file mode 100644
index 0000000..aecc3b1
--- /dev/null
+++ b/crates/codex/src/builder/types.rs
@@ -0,0 +1,317 @@
+use std::path::PathBuf;
+
+const REASONING_CONFIG_KEYS: &[&str] = &[
+    "model_reasoning_effort",
+    "model_reasoning_summary",
+    "model_verbosity",
+    "model_reasoning_summary_format",
+    "model_supports_reasoning_summaries",
+];
+
+/// ANSI color behavior for `codex exec` output.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ColorMode {
+    /// Match upstream defaults: use color codes when stdout/stderr look like terminals.
+    Auto,
+    /// Force colorful output even when piping.
+    Always,
+    /// Fully disable ANSI sequences for deterministic parsing/logging (default).
+    Never,
+}
+
+impl ColorMode {
+    pub(crate) const fn as_str(self) -> &'static str {
+        match self {
+            ColorMode::Auto => "auto",
+            ColorMode::Always => "always",
+            ColorMode::Never => "never",
+        }
+    }
+}
+
+/// Approval policy used by `--ask-for-approval`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ApprovalPolicy {
+    Untrusted,
+    OnFailure,
+    OnRequest,
+    Never,
+}
+
+impl ApprovalPolicy {
+    pub(super) const fn as_str(self) -> &'static str {
+        match self {
+            ApprovalPolicy::Untrusted => "untrusted",
+            ApprovalPolicy::OnFailure => "on-failure",
+            ApprovalPolicy::OnRequest => "on-request",
+            ApprovalPolicy::Never => "never",
+        }
+    }
+}
+
+/// Sandbox isolation level.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum SandboxMode {
+    ReadOnly,
+    WorkspaceWrite,
+    DangerFullAccess,
+}
+
+impl SandboxMode {
+    pub(super) const fn as_str(self) -> &'static str {
+        match self {
+            SandboxMode::ReadOnly => "read-only",
+            SandboxMode::WorkspaceWrite => "workspace-write",
+            SandboxMode::DangerFullAccess => "danger-full-access",
+        }
+    }
+}
+
+/// Safety overrides that collapse approval/sandbox behavior.
+#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
+pub enum SafetyOverride {
+    #[default]
+    Inherit,
+    FullAuto,
+    DangerouslyBypass,
+}
+
+/// Local provider selection for OSS backends.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum LocalProvider {
+    LmStudio,
+    Ollama,
+    Custom,
+}
+
+impl LocalProvider {
+    pub(super) const fn as_str(self) -> &'static str {
+        match self {
+            LocalProvider::LmStudio => "lmstudio",
+            LocalProvider::Ollama => "ollama",
+            LocalProvider::Custom => "custom",
+        }
+    }
+}
+
+/// Three-state flag used when requests can override builder defaults.
+#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
+pub enum FlagState {
+    #[default]
+    Inherit,
+    Enable,
+    Disable,
+}
+
+/// Feature toggles forwarded to `--enable/--disable`.
+#[derive(Clone, Debug, Default, Eq, PartialEq)]
+pub struct FeatureToggles {
+    pub enable: Vec<String>,
+    pub disable: Vec<String>,
+}
+
+/// Config values for `model_reasoning_effort`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ReasoningEffort {
+    Minimal,
+    Low,
+    Medium,
+    High,
+}
+
+impl ReasoningEffort {
+    pub(super) const fn as_str(self) -> &'static str {
+        match self {
+            ReasoningEffort::Minimal => "minimal",
+            ReasoningEffort::Low => "low",
+            ReasoningEffort::Medium => "medium",
+            ReasoningEffort::High => "high",
+        }
+    }
+}
+
+/// Config values for `model_reasoning_summary`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ReasoningSummary {
+    Auto,
+    Concise,
+    Detailed,
+    None,
+}
+
+impl ReasoningSummary {
+    pub(super) const fn as_str(self) -> &'static str {
+        match self {
+            ReasoningSummary::Auto => "auto",
+            ReasoningSummary::Concise => "concise",
+            ReasoningSummary::Detailed => "detailed",
+            ReasoningSummary::None => "none",
+        }
+    }
+}
+
+/// Config values for `model_verbosity`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ModelVerbosity {
+    Low,
+    Medium,
+    High,
+}
+
+impl ModelVerbosity {
+    pub(super) const fn as_str(self) -> &'static str {
+        match self {
+            ModelVerbosity::Low => "low",
+            ModelVerbosity::Medium => "medium",
+            ModelVerbosity::High => "high",
+        }
+    }
+}
+
+/// Config values for `model_reasoning_summary_format`.
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ReasoningSummaryFormat {
+    None,
+    Experimental,
+}
+
+impl ReasoningSummaryFormat {
+    pub(super) const fn as_str(self) -> &'static str {
+        match self {
+            ReasoningSummaryFormat::None => "none",
+            ReasoningSummaryFormat::Experimental => "experimental",
+        }
+    }
+}
+
+/// Represents a single `--config key=value` override.
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub struct ConfigOverride {
+    pub key: String,
+    pub value: String,
+}
+
+impl ConfigOverride {
+    pub fn new(key: impl Into<String>, value: impl Into<String>) -> Self {
+        Self {
+            key: key.into(),
+            value: value.into(),
+        }
+    }
+
+    pub fn from_raw(raw: impl Into<String>) -> Self {
+        let raw = raw.into();
+        let (key, value) = raw
+            .split_once('=')
+            .map(|(key, value)| (key.to_string(), value.to_string()))
+            .unwrap_or_else(|| (raw.clone(), String::new()));
+        ConfigOverride { key, value }
+    }
+
+    pub(super) fn is_reasoning_key(&self) -> bool {
+        REASONING_CONFIG_KEYS.contains(&self.key.as_str())
+    }
+}
+
+/// Structured reasoning overrides converted into config entries.
+#[derive(Clone, Debug, Default, Eq, PartialEq)]
+pub struct ReasoningOverrides {
+    pub effort: Option<ReasoningEffort>,
+    pub summary: Option<ReasoningSummary>,
+    pub verbosity: Option<ModelVerbosity>,
+    pub summary_format: Option<ReasoningSummaryFormat>,
+    pub supports_summaries: Option<bool>,
+}
+
+impl ReasoningOverrides {
+    pub(crate) fn has_overrides(&self) -> bool {
+        self.effort.is_some()
+            || self.summary.is_some()
+            || self.verbosity.is_some()
+            || self.summary_format.is_some()
+            || self.supports_summaries.is_some()
+    }
+
+    pub(super) fn append_overrides(&self, configs: &mut Vec<ConfigOverride>) {
+        if let Some(value) = self.effort {
+            configs.push(ConfigOverride::new(
+                "model_reasoning_effort",
+                value.as_str(),
+            ));
+        }
+        if let Some(value) = self.summary {
+            configs.push(ConfigOverride::new(
+                "model_reasoning_summary",
+                value.as_str(),
+            ));
+        }
+        if let Some(value) = self.verbosity {
+            configs.push(ConfigOverride::new("model_verbosity", value.as_str()));
+        }
+        if let Some(value) = self.summary_format {
+            configs.push(ConfigOverride::new(
+                "model_reasoning_summary_format",
+                value.as_str(),
+            ));
+        }
+        if let Some(value) = self.supports_summaries {
+            configs.push(ConfigOverride::new(
+                "model_supports_reasoning_summaries",
+                value.to_string(),
+            ));
+        }
+    }
+}
+
+/// Builder-scoped CLI overrides.
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub struct CliOverrides {
+    pub config_overrides: Vec<ConfigOverride>,
+    pub feature_toggles: FeatureToggles,
+    pub reasoning: ReasoningOverrides,
+    pub approval_policy: Option<ApprovalPolicy>,
+    pub sandbox_mode: Option<SandboxMode>,
+    pub safety_override: SafetyOverride,
+    pub profile: Option<String>,
+    pub cd: Option<PathBuf>,
+    pub local_provider: Option<LocalProvider>,
+    pub oss: FlagState,
+    pub search: FlagState,
+    pub auto_reasoning_defaults: bool,
+}
+
+impl Default for CliOverrides {
+    fn default() -> Self {
+        Self {
+            config_overrides: Vec::new(),
+            feature_toggles: FeatureToggles::default(),
+            reasoning: ReasoningOverrides::default(),
+            approval_policy: None,
+            sandbox_mode: None,
+            safety_override: SafetyOverride::Inherit,
+            profile: None,
+            cd: None,
+            local_provider: None,
+            oss: FlagState::Inherit,
+            search: FlagState::Inherit,
+            auto_reasoning_defaults: true,
+        }
+    }
+}
+
+/// Request-level overlay of builder overrides.
+#[derive(Clone, Debug, Default, Eq, PartialEq)]
+pub struct CliOverridesPatch {
+    pub config_overrides: Vec<ConfigOverride>,
+    pub feature_toggles: FeatureToggles,
+    pub reasoning: ReasoningOverrides,
+    pub approval_policy: Option<ApprovalPolicy>,
+    pub sandbox_mode: Option<SandboxMode>,
+    pub safety_override: Option<SafetyOverride>,
+    pub profile: Option<String>,
+    pub cd: Option<PathBuf>,
+    pub local_provider: Option<LocalProvider>,
+    pub oss: FlagState,
+    pub search: FlagState,
+    pub auto_reasoning_defaults: Option<bool>,
+}
