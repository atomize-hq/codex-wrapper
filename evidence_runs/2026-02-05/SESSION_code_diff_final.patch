diff --git a/crates/codex/src/lib.rs b/crates/codex/src/lib.rs
index e790397..d87e18e 100644
--- a/crates/codex/src/lib.rs
+++ b/crates/codex/src/lib.rs
@@ -467,4 +467,5 @@ impl Default for CodexClient {
 }
 
 #[cfg(test)]
+#[path = "tests.rs"]
 mod tests;
diff --git a/crates/codex/src/mcp/tests_core.rs b/crates/codex/src/mcp/tests_core.rs
index f73a948..6933d83 100644
--- a/crates/codex/src/mcp/tests_core.rs
+++ b/crates/codex/src/mcp/tests_core.rs
@@ -1,982 +1,4 @@
-use super::test_support::{prelude::*, *};
-use super::*;
-
-#[tokio::test]
-async fn app_server_launch_can_enable_analytics_flag() {
-    let (dir, script) = write_fake_app_server();
-    let log_path = dir.path().join("argv.json");
-
-    let mut config = test_config(script);
-    config.app_server_analytics_default_enabled = true;
-    config.env.push((
-        OsString::from("ARGV_LOG"),
-        OsString::from(log_path.as_os_str()),
-    ));
-
-    let client = test_client();
-    let server = CodexAppServer::start(config, client)
-        .await
-        .expect("spawn app server");
-
-    let mut argv_line = None;
-    for _ in 0..50 {
-        if let Ok(contents) = fs::read_to_string(&log_path) {
-            argv_line = contents.lines().next().map(str::to_string);
-            break;
-        }
-        tokio::time::sleep(Duration::from_millis(5)).await;
-    }
-
-    let argv_line = argv_line.expect("argv log should be written");
-    let argv: Vec<String> = serde_json::from_str(&argv_line).expect("argv json");
-    assert_eq!(argv, vec!["app-server", "--analytics-default-enabled"]);
-
-    server.shutdown().await.expect("shutdown server");
-}
-
-#[test]
-fn add_stdio_server_injects_env_and_persists() {
-    let (dir, manager) = temp_config_manager();
-    let env_key = "MCP_STDIO_TEST_KEY";
-    env::remove_var(env_key);
-
-    let mut env_map = BTreeMap::new();
-    env_map.insert(env_key.to_string(), "secret".to_string());
-
-    let added = manager
-        .add_server(AddServerRequest {
-            name: "local".into(),
-            definition: stdio_definition("my-mcp"),
-            overwrite: false,
-            env: env_map,
-            bearer_token: None,
-        })
-        .expect("add server");
-
-    match added.definition.transport {
-        McpTransport::Stdio(def) => {
-            assert_eq!(def.command, "my-mcp");
-            assert_eq!(def.env.get(env_key), Some(&"secret".to_string()));
-        }
-        _ => panic!("expected stdio transport"),
-    }
-
-    let listed = manager.list_servers().expect("list servers");
-    assert_eq!(listed.len(), 1);
-    assert_eq!(listed[0].name, "local");
-
-    let fetched = manager.get_server("local").expect("get server");
-    match fetched.definition.transport {
-        McpTransport::Stdio(def) => {
-            assert_eq!(def.env.get(env_key), Some(&"secret".to_string()))
-        }
-        _ => panic!("expected stdio transport"),
-    }
-
-    let config_path = dir.path().join(DEFAULT_CONFIG_FILE);
-    let serialized = fs::read_to_string(config_path).expect("read config");
-    let value: TomlValue = serialized.parse().expect("parse toml");
-    let table = value.as_table().expect("table root");
-    let servers_table = table.get("mcp_servers").expect("mcp_servers");
-    let decoded: BTreeMap<String, McpServerDefinition> = servers_table
-        .clone()
-        .try_into()
-        .expect("decode mcp_servers");
-    let stored = decoded.get("local").expect("stored server");
-    match &stored.transport {
-        McpTransport::Stdio(def) => {
-            assert_eq!(def.env.get(env_key), Some(&"secret".to_string()))
-        }
-        _ => panic!("expected stdio transport"),
-    }
-
-    assert_eq!(env::var(env_key).unwrap(), "secret");
-    env::remove_var(env_key);
-}
-
-#[test]
-fn add_streamable_http_sets_token_and_allows_login_logout() {
-    let (_dir, manager) = temp_config_manager();
-    let env_var = "MCP_HTTP_TOKEN_E5";
-    env::remove_var(env_var);
-
-    let mut definition = streamable_definition("https://example.test/mcp", env_var);
-    if let McpTransport::StreamableHttp(ref mut http) = definition.transport {
-        http.headers.insert("X-Test".into(), "true".into());
-    }
-
-    let _added = manager
-        .add_server(AddServerRequest {
-            name: "remote".into(),
-            definition,
-            overwrite: false,
-            env: BTreeMap::new(),
-            bearer_token: Some("token-a".into()),
-        })
-        .expect("add server");
-
-    assert_eq!(env::var(env_var).unwrap(), "token-a");
-
-    let logout = manager.logout("remote").expect("logout");
-    assert_eq!(logout.env_var.as_deref(), Some(env_var));
-    assert!(logout.cleared);
-    assert!(env::var(env_var).is_err());
-
-    let login = manager.login("remote", "token-b").expect("login");
-    assert_eq!(login.env_var.as_deref(), Some(env_var));
-    assert_eq!(env::var(env_var).unwrap(), "token-b");
-
-    env::remove_var(env_var);
-}
-
-#[test]
-fn remove_server_prunes_config() {
-    let (_dir, manager) = temp_config_manager();
-
-    manager
-        .add_server(AddServerRequest {
-            name: "one".into(),
-            definition: stdio_definition("one"),
-            overwrite: false,
-            env: BTreeMap::new(),
-            bearer_token: None,
-        })
-        .expect("add first");
-
-    manager
-        .add_server(AddServerRequest {
-            name: "two".into(),
-            definition: stdio_definition("two"),
-            overwrite: false,
-            env: BTreeMap::new(),
-            bearer_token: None,
-        })
-        .expect("add second");
-
-    let removed = manager.remove_server("one").expect("remove");
-    assert!(removed.is_some());
-
-    let listed = manager.list_servers().expect("list");
-    assert_eq!(listed.len(), 1);
-    assert_eq!(listed[0].name, "two");
-
-    let config = fs::read_to_string(manager.config_path()).expect("read config");
-    let value: TomlValue = config.parse().expect("parse config");
-    let table = value.as_table().expect("table root");
-    let servers_value = table.get("mcp_servers").cloned().expect("servers");
-    let servers: BTreeMap<String, McpServerDefinition> =
-        servers_value.try_into().expect("decode servers");
-    assert!(!servers.contains_key("one"));
-    assert!(servers.contains_key("two"));
-}
-
-#[test]
-fn runtime_stdio_server_resolves_env_and_tools() {
-    let (_dir, manager) = temp_config_manager();
-    let mut definition = stdio_definition("my-mcp");
-    definition.description = Some("local mcp".into());
-    definition.tags = vec!["dev".into(), "local".into()];
-    definition.tools = Some(McpToolConfig {
-        enabled: vec!["tool-a".into()],
-        disabled: vec!["tool-b".into()],
-    });
-
-    if let McpTransport::Stdio(ref mut stdio) = definition.transport {
-        stdio.args = vec!["--flag".into()];
-        stdio.env.insert("EXAMPLE".into(), "value".into());
-        stdio.timeout_ms = Some(2500);
-    }
-
-    let mut injected = BTreeMap::new();
-    injected.insert("MCP_STDIO_INJECT_E6".into(), "yes".into());
-
-    manager
-        .add_server(AddServerRequest {
-            name: "local".into(),
-            definition,
-            overwrite: false,
-            env: injected,
-            bearer_token: None,
-        })
-        .expect("add server");
-
-    let runtime = manager.runtime_server("local").expect("runtime server");
-    assert_eq!(runtime.name, "local");
-    assert_eq!(runtime.description.as_deref(), Some("local mcp"));
-    assert_eq!(runtime.tags, vec!["dev".to_string(), "local".to_string()]);
-
-    let tools = runtime.tools.as_ref().expect("tool hints");
-    assert_eq!(tools.enabled, vec!["tool-a".to_string()]);
-    assert_eq!(tools.disabled, vec!["tool-b".to_string()]);
-
-    match &runtime.transport {
-        McpRuntimeTransport::Stdio(def) => {
-            assert_eq!(def.command, "my-mcp");
-            assert_eq!(def.args, vec!["--flag".to_string()]);
-            assert_eq!(def.timeout_ms, Some(2500));
-            assert_eq!(def.env.get("EXAMPLE").map(String::as_str), Some("value"));
-            assert_eq!(
-                def.env.get("MCP_STDIO_INJECT_E6").map(String::as_str),
-                Some("yes")
-            );
-        }
-        other => panic!("expected stdio transport, got {other:?}"),
-    }
-
-    serde_json::to_string(&runtime).expect("serialize runtime");
-    env::remove_var("MCP_STDIO_INJECT_E6");
-}
-
-#[test]
-fn runtime_http_resolves_bearer_and_sets_header() {
-    let (_dir, manager) = temp_config_manager();
-    let env_var = "MCP_HTTP_TOKEN_E6";
-    env::set_var(env_var, "token-123");
-
-    let mut definition = streamable_definition("https://example.test/mcp", env_var);
-    if let McpTransport::StreamableHttp(ref mut http) = definition.transport {
-        http.headers.insert("X-Test".into(), "true".into());
-        http.connect_timeout_ms = Some(1200);
-        http.request_timeout_ms = Some(3400);
-    }
-
-    manager
-        .add_server(AddServerRequest {
-            name: "remote".into(),
-            definition,
-            overwrite: false,
-            env: BTreeMap::new(),
-            bearer_token: None,
-        })
-        .expect("add server");
-
-    let runtime = manager.runtime_server("remote").expect("runtime server");
-    match &runtime.transport {
-        McpRuntimeTransport::StreamableHttp(def) => {
-            assert_eq!(def.url, "https://example.test/mcp");
-            assert_eq!(def.bearer_env_var.as_deref(), Some(env_var));
-            assert_eq!(def.bearer_token.as_deref(), Some("token-123"));
-            assert_eq!(def.headers.get("X-Test").map(String::as_str), Some("true"));
-            assert_eq!(
-                def.headers.get("Authorization").map(String::as_str),
-                Some("Bearer token-123")
-            );
-            assert_eq!(def.connect_timeout_ms, Some(1200));
-            assert_eq!(def.request_timeout_ms, Some(3400));
-        }
-        other => panic!("expected streamable_http transport, got {other:?}"),
-    }
-
-    let serialized = serde_json::to_value(&runtime).expect("serialize runtime");
-    assert!(serialized.get("transport").is_some());
-
-    env::remove_var(env_var);
-}
-
-#[test]
-fn runtime_http_preserves_existing_auth_header() {
-    let (_dir, manager) = temp_config_manager();
-    let env_var = "MCP_HTTP_TOKEN_E6B";
-    env::set_var(env_var, "token-override");
-
-    let mut definition = streamable_definition("https://example.test/custom", env_var);
-    if let McpTransport::StreamableHttp(ref mut http) = definition.transport {
-        http.headers
-            .insert("Authorization".into(), "Custom 123".into());
-    }
-
-    manager
-        .add_server(AddServerRequest {
-            name: "remote-custom".into(),
-            definition,
-            overwrite: false,
-            env: BTreeMap::new(),
-            bearer_token: None,
-        })
-        .expect("add server");
-
-    let runtime = manager
-        .runtime_server("remote-custom")
-        .expect("runtime server");
-    match &runtime.transport {
-        McpRuntimeTransport::StreamableHttp(def) => {
-            assert_eq!(def.bearer_token.as_deref(), Some("token-override"));
-            assert_eq!(
-                def.headers.get("Authorization").map(String::as_str),
-                Some("Custom 123")
-            );
-        }
-        other => panic!("expected streamable_http transport, got {other:?}"),
-    }
-
-    env::remove_var(env_var);
-}
-
-#[test]
-fn runtime_stdio_launcher_merges_env_timeout_and_tools() {
-    let base_dir = tempfile::tempdir().expect("tempdir");
-    let code_home = base_dir.path().join("code_home");
-
-    let defaults = StdioServerConfig {
-        binary: PathBuf::from("codex"),
-        code_home: Some(code_home.clone()),
-        current_dir: Some(base_dir.path().to_path_buf()),
-        env: vec![
-            (OsString::from("BASE_ONLY"), OsString::from("base")),
-            (OsString::from("OVERRIDE_ME"), OsString::from("base")),
-        ],
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: true,
-        startup_timeout: Duration::from_secs(5),
-    };
-
-    let mut definition = StdioServerDefinition {
-        command: "my-mcp".into(),
-        args: vec!["--flag".into()],
-        env: BTreeMap::new(),
-        timeout_ms: Some(1500),
-    };
-    definition
-        .env
-        .insert("OVERRIDE_ME".into(), "runtime".into());
-    definition
-        .env
-        .insert("RUNTIME_ONLY".into(), "runtime-env".into());
-
-    let runtime = McpRuntimeServer {
-        name: "local".into(),
-        transport: McpRuntimeTransport::Stdio(definition),
-        description: Some("example".into()),
-        tags: vec!["dev".into()],
-        tools: Some(McpToolConfig {
-            enabled: vec!["tool-1".into()],
-            disabled: vec!["tool-2".into()],
-        }),
-    };
-
-    let launcher = runtime.into_launcher(&defaults);
-    assert_eq!(launcher.name, "local");
-    assert_eq!(launcher.description.as_deref(), Some("example"));
-    assert_eq!(launcher.tags, vec!["dev".to_string()]);
-
-    let tools = launcher.tools.clone().expect("tool hints");
-    assert_eq!(tools.enabled, vec!["tool-1".to_string()]);
-    assert_eq!(tools.disabled, vec!["tool-2".to_string()]);
-
-    match launcher.transport {
-        McpServerLauncherTransport::Stdio(launch) => {
-            assert_eq!(launch.command, PathBuf::from("my-mcp"));
-            assert_eq!(launch.args, vec!["--flag".to_string()]);
-            assert_eq!(launch.current_dir.as_ref(), defaults.current_dir.as_ref());
-            assert_eq!(launch.timeout, Duration::from_millis(1500));
-            assert!(launch.mirror_stdio);
-
-            let env_map: HashMap<OsString, OsString> = launch.env.into_iter().collect();
-            assert_eq!(
-                env_map.get(&OsString::from("BASE_ONLY")),
-                Some(&OsString::from("base"))
-            );
-            assert_eq!(
-                env_map.get(&OsString::from("OVERRIDE_ME")),
-                Some(&OsString::from("runtime"))
-            );
-            assert_eq!(
-                env_map.get(&OsString::from("RUNTIME_ONLY")),
-                Some(&OsString::from("runtime-env"))
-            );
-            assert_eq!(
-                env_map.get(&OsString::from("CODEX_HOME")),
-                Some(&code_home.as_os_str().to_os_string())
-            );
-        }
-        other => panic!("expected stdio launcher, got {other:?}"),
-    }
-}
-
-#[test]
-fn streamable_http_connector_converts_timeouts_and_headers() {
-    let env_var = "MCP_HTTP_TOKEN_E7";
-    env::set_var(env_var, "token-launcher");
-
-    let mut definition = StreamableHttpDefinition {
-        url: "https://example.test/stream".into(),
-        headers: BTreeMap::new(),
-        bearer_env_var: Some(env_var.to_string()),
-        connect_timeout_ms: Some(1200),
-        request_timeout_ms: Some(3400),
-    };
-    definition.headers.insert("X-Test".into(), "true".into());
-
-    let runtime = McpRuntimeServer::from_definition(
-        "remote",
-        McpServerDefinition {
-            transport: McpTransport::StreamableHttp(definition),
-            description: None,
-            tags: vec!["http".into()],
-            tools: Some(McpToolConfig {
-                enabled: vec!["tool-a".into()],
-                disabled: vec![],
-            }),
-        },
-    );
-
-    let defaults = StdioServerConfig {
-        binary: PathBuf::from("codex"),
-        code_home: None,
-        current_dir: None,
-        env: Vec::new(),
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(2),
-    };
-
-    let launcher = runtime.into_launcher(&defaults);
-    match launcher.transport {
-        McpServerLauncherTransport::StreamableHttp(connector) => {
-            assert_eq!(connector.url, "https://example.test/stream");
-            assert_eq!(
-                connector.headers.get("X-Test").map(String::as_str),
-                Some("true")
-            );
-            assert_eq!(
-                connector.headers.get("Authorization").map(String::as_str),
-                Some("Bearer token-launcher")
-            );
-            assert_eq!(connector.connect_timeout, Some(Duration::from_millis(1200)));
-            assert_eq!(connector.request_timeout, Some(Duration::from_millis(3400)));
-            assert_eq!(connector.bearer_env_var.as_deref(), Some(env_var));
-            assert_eq!(connector.bearer_token.as_deref(), Some("token-launcher"));
-
-            let tools = launcher.tools.as_ref().expect("tool hints present");
-            assert_eq!(tools.enabled, vec!["tool-a".to_string()]);
-            assert!(tools.disabled.is_empty());
-        }
-        other => panic!("expected http connector, got {other:?}"),
-    }
-
-    env::remove_var(env_var);
-}
-
-#[tokio::test]
-async fn codex_flow_streams_events_and_response() {
-    let (_dir, server) = start_fake_mcp_server().await;
-
-    let params = CodexCallParams {
-        prompt: "hello".into(),
-        model: None,
-        cwd: None,
-        sandbox: None,
-        approval_policy: None,
-        profile: None,
-        config: BTreeMap::new(),
-    };
-
-    let mut handle = server.codex(params).await.expect("codex call");
-
-    let first_event = time::timeout(Duration::from_secs(2), handle.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("event value");
-    match first_event {
-        CodexEvent::ApprovalRequired(req) => {
-            assert!(req.approval_id.starts_with("ap-"));
-            assert_eq!(req.kind, ApprovalKind::Exec);
-        }
-        other => panic!("unexpected event: {other:?}"),
-    }
-
-    let second_event = time::timeout(Duration::from_secs(2), handle.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("event value");
-    let event_conversation = match second_event {
-        CodexEvent::TaskComplete {
-            conversation_id, ..
-        } => {
-            assert!(!conversation_id.is_empty());
-            conversation_id
-        }
-        other => panic!("unexpected event: {other:?}"),
-    };
-
-    let response = time::timeout(Duration::from_secs(2), handle.response)
-        .await
-        .expect("response timeout")
-        .expect("response recv");
-    let response = response.expect("response ok");
-    assert_eq!(
-        response.conversation_id.as_deref(),
-        Some(event_conversation.as_str())
-    );
-    assert_eq!(response.output, serde_json::json!({ "ok": true }));
-
-    let _ = server.shutdown().await;
-}
-
-#[tokio::test]
-async fn canceling_request_returns_cancelled_error() {
-    let (_dir, server) = start_fake_mcp_server().await;
-
-    let params = CodexCallParams {
-        prompt: "cancel me".into(),
-        model: None,
-        cwd: None,
-        sandbox: None,
-        approval_policy: None,
-        profile: None,
-        config: BTreeMap::new(),
-    };
-
-    let mut handle = server.codex(params).await.expect("codex call");
-    server.cancel(handle.request_id).expect("cancel send");
-
-    let expected_conversation = format!("conv-{}", handle.request_id);
-    let cancel_event = time::timeout(Duration::from_secs(2), handle.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("cancel notification");
-    match cancel_event {
-        CodexEvent::Cancelled {
-            conversation_id,
-            reason,
-        } => {
-            assert_eq!(
-                conversation_id.as_deref(),
-                Some(expected_conversation.as_str())
-            );
-            assert_eq!(reason.as_deref(), Some("client_cancel"));
-        }
-        other => panic!("expected cancellation event, got {other:?}"),
-    }
-
-    let response = time::timeout(Duration::from_secs(2), handle.response)
-        .await
-        .expect("response timeout")
-        .expect("recv");
-    assert!(matches!(response, Err(McpError::Cancelled)));
-
-    let _ = server.shutdown().await;
-}
-
-#[tokio::test]
-async fn codex_reply_streams_follow_up_notifications() {
-    let (_dir, server) = start_fake_mcp_server().await;
-
-    let params = CodexCallParams {
-        prompt: "hello".into(),
-        model: None,
-        cwd: None,
-        sandbox: None,
-        approval_policy: None,
-        profile: None,
-        config: BTreeMap::new(),
-    };
-    let first = server.codex(params).await.expect("start codex");
-    let first_response = time::timeout(Duration::from_secs(2), first.response)
-        .await
-        .expect("response timeout")
-        .expect("recv")
-        .expect("ok");
-    let conversation_id = first_response.conversation_id.expect("conversation id set");
-    assert!(!conversation_id.is_empty());
-
-    let reply_params = CodexReplyParams {
-        conversation_id: conversation_id.clone(),
-        prompt: "follow up".into(),
-    };
-    let mut reply = server.codex_reply(reply_params).await.expect("codex reply");
-
-    let expected_approval = format!("ap-{}", reply.request_id);
-    let approval = time::timeout(Duration::from_secs(2), reply.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("approval");
-    match approval {
-        CodexEvent::ApprovalRequired(req) => {
-            assert_eq!(req.approval_id, expected_approval);
-            assert_eq!(req.kind, ApprovalKind::Exec);
-        }
-        other => panic!("unexpected event: {other:?}"),
-    }
-
-    let complete = time::timeout(Duration::from_secs(2), reply.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("task completion");
-    match complete {
-        CodexEvent::TaskComplete {
-            conversation_id: event_conv,
-            ..
-        } => assert_eq!(event_conv, conversation_id),
-        other => panic!("unexpected event: {other:?}"),
-    }
-
-    let reply_response = time::timeout(Duration::from_secs(2), reply.response)
-        .await
-        .expect("response timeout")
-        .expect("recv")
-        .expect("ok");
-    assert_eq!(
-        reply_response.conversation_id.as_deref(),
-        Some(conversation_id.as_str())
-    );
-    assert_eq!(reply_response.output, serde_json::json!({ "ok": true }));
-
-    let _ = server.shutdown().await;
-}
-
-#[tokio::test]
-async fn app_flow_streams_notifications_and_response() {
-    let (_dir, server) = start_fake_app_server().await;
-
-    let thread_params = ThreadStartParams {
-        thread_id: None,
-        metadata: Value::Null,
-    };
-    let thread_handle = server
-        .thread_start(thread_params)
-        .await
-        .expect("thread start");
-    let thread_response = time::timeout(Duration::from_secs(2), thread_handle.response)
-        .await
-        .expect("thread response timeout")
-        .expect("thread response recv")
-        .expect("thread response ok");
-    let thread_id = thread_response
-        .get("thread_id")
-        .and_then(Value::as_str)
-        .unwrap_or_default()
-        .to_string();
-    assert!(!thread_id.is_empty());
-
-    let params = TurnStartParams {
-        thread_id: thread_id.clone(),
-        input: vec![TurnInput {
-            kind: "text".to_string(),
-            text: Some("hi".to_string()),
-        }],
-        model: None,
-        config: BTreeMap::new(),
-    };
-    let mut handle = server.turn_start(params).await.expect("turn start");
-
-    let first_event = time::timeout(Duration::from_secs(2), handle.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("event value");
-    let turn_id = match first_event {
-        AppNotification::Item {
-            thread_id: tid,
-            turn_id: Some(turn),
-            item,
-        } => {
-            assert_eq!(tid, thread_id);
-            assert!(item.get("message").is_some());
-            turn
-        }
-        other => panic!("unexpected event: {other:?}"),
-    };
-
-    let second_event = time::timeout(Duration::from_secs(2), handle.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("event value");
-    match second_event {
-        AppNotification::TaskComplete {
-            thread_id: tid,
-            turn_id: event_turn,
-            result,
-        } => {
-            assert_eq!(tid, thread_id);
-            assert_eq!(event_turn.as_deref(), Some(turn_id.as_str()));
-            assert_eq!(result, serde_json::json!({ "ok": true }));
-        }
-        other => panic!("unexpected event: {other:?}"),
-    }
-
-    let response = time::timeout(Duration::from_secs(2), handle.response)
-        .await
-        .expect("response timeout")
-        .expect("response recv");
-    let response = response.expect("response ok");
-    assert_eq!(
-        response
-            .get("turn_id")
-            .and_then(Value::as_str)
-            .unwrap_or_default(),
-        turn_id
-    );
-
-    let _ = server.shutdown().await;
-}
-
-#[tokio::test]
-async fn canceling_app_request_returns_cancelled_error() {
-    let (_dir, server) = start_fake_app_server().await;
-
-    let thread_params = ThreadStartParams {
-        thread_id: None,
-        metadata: Value::Null,
-    };
-    let thread_handle = server
-        .thread_start(thread_params)
-        .await
-        .expect("thread start");
-    let thread_response = time::timeout(Duration::from_secs(2), thread_handle.response)
-        .await
-        .expect("thread response timeout")
-        .expect("thread response recv")
-        .expect("thread response ok");
-    let thread_id = thread_response
-        .get("thread_id")
-        .and_then(Value::as_str)
-        .unwrap_or_default()
-        .to_string();
-
-    let params = TurnStartParams {
-        thread_id: thread_id.clone(),
-        input: vec![TurnInput {
-            kind: "text".to_string(),
-            text: Some("cancel me".to_string()),
-        }],
-        model: None,
-        config: BTreeMap::new(),
-    };
-
-    let mut handle = server.turn_start(params).await.expect("turn start");
-    server.cancel(handle.request_id).expect("send cancel");
-
-    let cancel_event = time::timeout(Duration::from_secs(2), handle.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("cancel event");
-    match cancel_event {
-        AppNotification::TaskComplete {
-            thread_id: tid,
-            turn_id,
-            result,
-        } => {
-            assert_eq!(tid, thread_id);
-            assert!(turn_id.is_some());
-            assert_eq!(result.get("cancelled"), Some(&Value::Bool(true)));
-            assert_eq!(
-                result.get("reason"),
-                Some(&Value::String("client_cancel".into()))
-            );
-        }
-        other => panic!("unexpected cancellation notification: {other:?}"),
-    }
-
-    let response = time::timeout(Duration::from_secs(2), handle.response)
-        .await
-        .expect("response timeout")
-        .expect("recv");
-    assert!(matches!(response, Err(McpError::Cancelled)));
-
-    let _ = server.shutdown().await;
-}
-
-#[tokio::test]
-async fn thread_resume_allows_follow_up_turns() {
-    let (_dir, server) = start_fake_app_server().await;
-
-    let thread_params = ThreadStartParams {
-        thread_id: None,
-        metadata: Value::Null,
-    };
-    let thread_handle = server
-        .thread_start(thread_params)
-        .await
-        .expect("thread start");
-    let thread_response = time::timeout(Duration::from_secs(2), thread_handle.response)
-        .await
-        .expect("thread response timeout")
-        .expect("recv")
-        .expect("ok");
-    let thread_id = thread_response
-        .get("thread_id")
-        .and_then(Value::as_str)
-        .unwrap_or_default()
-        .to_string();
-
-    let resume_params = ThreadResumeParams {
-        thread_id: thread_id.clone(),
-    };
-    let resume_handle = server
-        .thread_resume(resume_params)
-        .await
-        .expect("thread resume");
-    let resume_response = time::timeout(Duration::from_secs(2), resume_handle.response)
-        .await
-        .expect("resume response timeout")
-        .expect("recv")
-        .expect("ok");
-    assert_eq!(
-        resume_response
-            .get("thread_id")
-            .and_then(Value::as_str)
-            .unwrap_or_default(),
-        thread_id
-    );
-    assert!(resume_response
-        .get("resumed")
-        .and_then(Value::as_bool)
-        .unwrap_or(false));
-
-    let params = TurnStartParams {
-        thread_id: thread_id.clone(),
-        input: vec![TurnInput {
-            kind: "text".to_string(),
-            text: Some("resume flow".to_string()),
-        }],
-        model: None,
-        config: BTreeMap::new(),
-    };
-    let mut turn = server.turn_start(params).await.expect("turn start");
-
-    let item = time::timeout(Duration::from_secs(2), turn.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("item event");
-    let turn_id = match item {
-        AppNotification::Item {
-            thread_id: tid,
-            turn_id: Some(turn_id),
-            ..
-        } => {
-            assert_eq!(tid, thread_id);
-            turn_id
-        }
-        other => panic!("unexpected event: {other:?}"),
-    };
-
-    let complete = time::timeout(Duration::from_secs(2), turn.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("completion event");
-    match complete {
-        AppNotification::TaskComplete {
-            thread_id: tid,
-            turn_id: event_turn,
-            result,
-        } => {
-            assert_eq!(tid, thread_id);
-            assert_eq!(event_turn.as_deref(), Some(turn_id.as_str()));
-            assert_eq!(result, serde_json::json!({ "ok": true }));
-        }
-        other => panic!("unexpected event: {other:?}"),
-    }
-
-    let turn_response = time::timeout(Duration::from_secs(2), turn.response)
-        .await
-        .expect("response timeout")
-        .expect("recv")
-        .expect("ok");
-    assert_eq!(
-        turn_response
-            .get("turn_id")
-            .and_then(Value::as_str)
-            .unwrap_or_default(),
-        turn_id
-    );
-
-    let _ = server.shutdown().await;
-}
-
-#[tokio::test]
-async fn turn_interrupt_sends_cancel_notification() {
-    let (_dir, server) = start_fake_app_server().await;
-
-    let thread_params = ThreadStartParams {
-        thread_id: None,
-        metadata: Value::Null,
-    };
-    let thread_handle = server
-        .thread_start(thread_params)
-        .await
-        .expect("thread start");
-    let thread_response = time::timeout(Duration::from_secs(2), thread_handle.response)
-        .await
-        .expect("thread response timeout")
-        .expect("recv")
-        .expect("ok");
-    let thread_id = thread_response
-        .get("thread_id")
-        .and_then(Value::as_str)
-        .unwrap_or_default()
-        .to_string();
-
-    let params = TurnStartParams {
-        thread_id: thread_id.clone(),
-        input: vec![TurnInput {
-            kind: "text".to_string(),
-            text: Some("please interrupt".to_string()),
-        }],
-        model: None,
-        config: BTreeMap::new(),
-    };
-    let mut turn = server.turn_start(params).await.expect("turn start");
-
-    let first_event = time::timeout(Duration::from_secs(2), turn.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("event value");
-    let turn_id = match first_event {
-        AppNotification::Item {
-            thread_id: tid,
-            turn_id: Some(turn),
-            ..
-        } => {
-            assert_eq!(tid, thread_id);
-            turn
-        }
-        other => panic!("unexpected event: {other:?}"),
-    };
-
-    let interrupt = server
-        .turn_interrupt(TurnInterruptParams {
-            thread_id: Some(thread_id.clone()),
-            turn_id: turn_id.clone(),
-        })
-        .await
-        .expect("send interrupt");
-
-    let cancel_event = time::timeout(Duration::from_secs(2), turn.events.recv())
-        .await
-        .expect("event timeout")
-        .expect("cancel event");
-    match cancel_event {
-        AppNotification::TaskComplete {
-            thread_id: tid,
-            turn_id: event_turn,
-            result,
-        } => {
-            assert_eq!(tid, thread_id);
-            assert_eq!(event_turn.as_deref(), Some(turn_id.as_str()));
-            assert_eq!(result.get("cancelled"), Some(&Value::Bool(true)));
-            assert_eq!(
-                result.get("reason"),
-                Some(&Value::String("interrupted".into()))
-            );
-        }
-        other => panic!("unexpected cancel notification: {other:?}"),
-    }
-
-    let turn_response = time::timeout(Duration::from_secs(2), turn.response)
-        .await
-        .expect("response timeout")
-        .expect("recv");
-    assert!(matches!(turn_response, Err(McpError::Cancelled)));
-
-    let interrupt_response = time::timeout(Duration::from_secs(2), interrupt.response)
-        .await
-        .expect("interrupt response timeout")
-        .expect("recv")
-        .expect("ok");
-    assert!(interrupt_response
-        .get("interrupted")
-        .and_then(Value::as_bool)
-        .unwrap_or(false));
-
-    let _ = server.shutdown().await;
-}
+mod app_server_launch;
+mod app_server_rpc_flows;
+mod codex_rpc_flows;
+mod config_runtime;
diff --git a/crates/codex/src/mcp/tests_core/app_server_launch.rs b/crates/codex/src/mcp/tests_core/app_server_launch.rs
new file mode 100644
index 0000000..83740b2
--- /dev/null
+++ b/crates/codex/src/mcp/tests_core/app_server_launch.rs
@@ -0,0 +1,35 @@
+use super::super::test_support::{prelude::*, *};
+use super::super::*;
+
+#[tokio::test]
+async fn app_server_launch_can_enable_analytics_flag() {
+    let (dir, script) = write_fake_app_server();
+    let log_path = dir.path().join("argv.json");
+
+    let mut config = test_config(script);
+    config.app_server_analytics_default_enabled = true;
+    config.env.push((
+        OsString::from("ARGV_LOG"),
+        OsString::from(log_path.as_os_str()),
+    ));
+
+    let client = test_client();
+    let server = CodexAppServer::start(config, client)
+        .await
+        .expect("spawn app server");
+
+    let mut argv_line = None;
+    for _ in 0..50 {
+        if let Ok(contents) = fs::read_to_string(&log_path) {
+            argv_line = contents.lines().next().map(str::to_string);
+            break;
+        }
+        tokio::time::sleep(Duration::from_millis(5)).await;
+    }
+
+    let argv_line = argv_line.expect("argv log should be written");
+    let argv: Vec<String> = serde_json::from_str(&argv_line).expect("argv json");
+    assert_eq!(argv, vec!["app-server", "--analytics-default-enabled"]);
+
+    server.shutdown().await.expect("shutdown server");
+}
diff --git a/crates/codex/src/mcp/tests_core/app_server_rpc_flows.rs b/crates/codex/src/mcp/tests_core/app_server_rpc_flows.rs
new file mode 100644
index 0000000..ea54506
--- /dev/null
+++ b/crates/codex/src/mcp/tests_core/app_server_rpc_flows.rs
@@ -0,0 +1,358 @@
+use super::super::test_support::{prelude::*, *};
+use super::super::*;
+
+#[tokio::test]
+async fn app_flow_streams_notifications_and_response() {
+    let (_dir, server) = start_fake_app_server().await;
+
+    let thread_params = ThreadStartParams {
+        thread_id: None,
+        metadata: Value::Null,
+    };
+    let thread_handle = server
+        .thread_start(thread_params)
+        .await
+        .expect("thread start");
+    let thread_response = time::timeout(Duration::from_secs(2), thread_handle.response)
+        .await
+        .expect("thread response timeout")
+        .expect("thread response recv")
+        .expect("thread response ok");
+    let thread_id = thread_response
+        .get("thread_id")
+        .and_then(Value::as_str)
+        .unwrap_or_default()
+        .to_string();
+    assert!(!thread_id.is_empty());
+
+    let params = TurnStartParams {
+        thread_id: thread_id.clone(),
+        input: vec![TurnInput {
+            kind: "text".to_string(),
+            text: Some("hi".to_string()),
+        }],
+        model: None,
+        config: BTreeMap::new(),
+    };
+    let mut handle = server.turn_start(params).await.expect("turn start");
+
+    let first_event = time::timeout(Duration::from_secs(2), handle.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("event value");
+    let turn_id = match first_event {
+        AppNotification::Item {
+            thread_id: tid,
+            turn_id: Some(turn),
+            item,
+        } => {
+            assert_eq!(tid, thread_id);
+            assert!(item.get("message").is_some());
+            turn
+        }
+        other => panic!("unexpected event: {other:?}"),
+    };
+
+    let second_event = time::timeout(Duration::from_secs(2), handle.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("event value");
+    match second_event {
+        AppNotification::TaskComplete {
+            thread_id: tid,
+            turn_id: event_turn,
+            result,
+        } => {
+            assert_eq!(tid, thread_id);
+            assert_eq!(event_turn.as_deref(), Some(turn_id.as_str()));
+            assert_eq!(result, serde_json::json!({ "ok": true }));
+        }
+        other => panic!("unexpected event: {other:?}"),
+    }
+
+    let response = time::timeout(Duration::from_secs(2), handle.response)
+        .await
+        .expect("response timeout")
+        .expect("response recv");
+    let response = response.expect("response ok");
+    assert_eq!(
+        response
+            .get("turn_id")
+            .and_then(Value::as_str)
+            .unwrap_or_default(),
+        turn_id
+    );
+
+    let _ = server.shutdown().await;
+}
+
+#[tokio::test]
+async fn canceling_app_request_returns_cancelled_error() {
+    let (_dir, server) = start_fake_app_server().await;
+
+    let thread_params = ThreadStartParams {
+        thread_id: None,
+        metadata: Value::Null,
+    };
+    let thread_handle = server
+        .thread_start(thread_params)
+        .await
+        .expect("thread start");
+    let thread_response = time::timeout(Duration::from_secs(2), thread_handle.response)
+        .await
+        .expect("thread response timeout")
+        .expect("thread response recv")
+        .expect("thread response ok");
+    let thread_id = thread_response
+        .get("thread_id")
+        .and_then(Value::as_str)
+        .unwrap_or_default()
+        .to_string();
+
+    let params = TurnStartParams {
+        thread_id: thread_id.clone(),
+        input: vec![TurnInput {
+            kind: "text".to_string(),
+            text: Some("cancel me".to_string()),
+        }],
+        model: None,
+        config: BTreeMap::new(),
+    };
+
+    let mut handle = server.turn_start(params).await.expect("turn start");
+    server.cancel(handle.request_id).expect("send cancel");
+
+    let cancel_event = time::timeout(Duration::from_secs(2), handle.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("cancel event");
+    match cancel_event {
+        AppNotification::TaskComplete {
+            thread_id: tid,
+            turn_id,
+            result,
+        } => {
+            assert_eq!(tid, thread_id);
+            assert!(turn_id.is_some());
+            assert_eq!(result.get("cancelled"), Some(&Value::Bool(true)));
+            assert_eq!(
+                result.get("reason"),
+                Some(&Value::String("client_cancel".into()))
+            );
+        }
+        other => panic!("unexpected cancellation notification: {other:?}"),
+    }
+
+    let response = time::timeout(Duration::from_secs(2), handle.response)
+        .await
+        .expect("response timeout")
+        .expect("recv");
+    assert!(matches!(response, Err(McpError::Cancelled)));
+
+    let _ = server.shutdown().await;
+}
+
+#[tokio::test]
+async fn thread_resume_allows_follow_up_turns() {
+    let (_dir, server) = start_fake_app_server().await;
+
+    let thread_params = ThreadStartParams {
+        thread_id: None,
+        metadata: Value::Null,
+    };
+    let thread_handle = server
+        .thread_start(thread_params)
+        .await
+        .expect("thread start");
+    let thread_response = time::timeout(Duration::from_secs(2), thread_handle.response)
+        .await
+        .expect("thread response timeout")
+        .expect("recv")
+        .expect("ok");
+    let thread_id = thread_response
+        .get("thread_id")
+        .and_then(Value::as_str)
+        .unwrap_or_default()
+        .to_string();
+
+    let resume_params = ThreadResumeParams {
+        thread_id: thread_id.clone(),
+    };
+    let resume_handle = server
+        .thread_resume(resume_params)
+        .await
+        .expect("thread resume");
+    let resume_response = time::timeout(Duration::from_secs(2), resume_handle.response)
+        .await
+        .expect("resume response timeout")
+        .expect("recv")
+        .expect("ok");
+    assert_eq!(
+        resume_response
+            .get("thread_id")
+            .and_then(Value::as_str)
+            .unwrap_or_default(),
+        thread_id
+    );
+    assert!(resume_response
+        .get("resumed")
+        .and_then(Value::as_bool)
+        .unwrap_or(false));
+
+    let params = TurnStartParams {
+        thread_id: thread_id.clone(),
+        input: vec![TurnInput {
+            kind: "text".to_string(),
+            text: Some("resume flow".to_string()),
+        }],
+        model: None,
+        config: BTreeMap::new(),
+    };
+    let mut turn = server.turn_start(params).await.expect("turn start");
+
+    let item = time::timeout(Duration::from_secs(2), turn.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("item event");
+    let turn_id = match item {
+        AppNotification::Item {
+            thread_id: tid,
+            turn_id: Some(turn_id),
+            ..
+        } => {
+            assert_eq!(tid, thread_id);
+            turn_id
+        }
+        other => panic!("unexpected event: {other:?}"),
+    };
+
+    let complete = time::timeout(Duration::from_secs(2), turn.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("completion event");
+    match complete {
+        AppNotification::TaskComplete {
+            thread_id: tid,
+            turn_id: event_turn,
+            result,
+        } => {
+            assert_eq!(tid, thread_id);
+            assert_eq!(event_turn.as_deref(), Some(turn_id.as_str()));
+            assert_eq!(result, serde_json::json!({ "ok": true }));
+        }
+        other => panic!("unexpected event: {other:?}"),
+    }
+
+    let turn_response = time::timeout(Duration::from_secs(2), turn.response)
+        .await
+        .expect("response timeout")
+        .expect("recv")
+        .expect("ok");
+    assert_eq!(
+        turn_response
+            .get("turn_id")
+            .and_then(Value::as_str)
+            .unwrap_or_default(),
+        turn_id
+    );
+
+    let _ = server.shutdown().await;
+}
+
+#[tokio::test]
+async fn turn_interrupt_sends_cancel_notification() {
+    let (_dir, server) = start_fake_app_server().await;
+
+    let thread_params = ThreadStartParams {
+        thread_id: None,
+        metadata: Value::Null,
+    };
+    let thread_handle = server
+        .thread_start(thread_params)
+        .await
+        .expect("thread start");
+    let thread_response = time::timeout(Duration::from_secs(2), thread_handle.response)
+        .await
+        .expect("thread response timeout")
+        .expect("recv")
+        .expect("ok");
+    let thread_id = thread_response
+        .get("thread_id")
+        .and_then(Value::as_str)
+        .unwrap_or_default()
+        .to_string();
+
+    let params = TurnStartParams {
+        thread_id: thread_id.clone(),
+        input: vec![TurnInput {
+            kind: "text".to_string(),
+            text: Some("please interrupt".to_string()),
+        }],
+        model: None,
+        config: BTreeMap::new(),
+    };
+    let mut turn = server.turn_start(params).await.expect("turn start");
+
+    let first_event = time::timeout(Duration::from_secs(2), turn.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("event value");
+    let turn_id = match first_event {
+        AppNotification::Item {
+            thread_id: tid,
+            turn_id: Some(turn),
+            ..
+        } => {
+            assert_eq!(tid, thread_id);
+            turn
+        }
+        other => panic!("unexpected event: {other:?}"),
+    };
+
+    let interrupt = server
+        .turn_interrupt(TurnInterruptParams {
+            thread_id: Some(thread_id.clone()),
+            turn_id: turn_id.clone(),
+        })
+        .await
+        .expect("send interrupt");
+
+    let cancel_event = time::timeout(Duration::from_secs(2), turn.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("cancel event");
+    match cancel_event {
+        AppNotification::TaskComplete {
+            thread_id: tid,
+            turn_id: event_turn,
+            result,
+        } => {
+            assert_eq!(tid, thread_id);
+            assert_eq!(event_turn.as_deref(), Some(turn_id.as_str()));
+            assert_eq!(result.get("cancelled"), Some(&Value::Bool(true)));
+            assert_eq!(
+                result.get("reason"),
+                Some(&Value::String("interrupted".into()))
+            );
+        }
+        other => panic!("unexpected cancel notification: {other:?}"),
+    }
+
+    let turn_response = time::timeout(Duration::from_secs(2), turn.response)
+        .await
+        .expect("response timeout")
+        .expect("recv");
+    assert!(matches!(turn_response, Err(McpError::Cancelled)));
+
+    let interrupt_response = time::timeout(Duration::from_secs(2), interrupt.response)
+        .await
+        .expect("interrupt response timeout")
+        .expect("recv")
+        .expect("ok");
+    assert!(interrupt_response
+        .get("interrupted")
+        .and_then(Value::as_bool)
+        .unwrap_or(false));
+
+    let _ = server.shutdown().await;
+}
diff --git a/crates/codex/src/mcp/tests_core/codex_rpc_flows.rs b/crates/codex/src/mcp/tests_core/codex_rpc_flows.rs
new file mode 100644
index 0000000..c406928
--- /dev/null
+++ b/crates/codex/src/mcp/tests_core/codex_rpc_flows.rs
@@ -0,0 +1,170 @@
+use super::super::test_support::{prelude::*, *};
+use super::super::*;
+
+#[tokio::test]
+async fn codex_flow_streams_events_and_response() {
+    let (_dir, server) = start_fake_mcp_server().await;
+
+    let params = CodexCallParams {
+        prompt: "hello".into(),
+        model: None,
+        cwd: None,
+        sandbox: None,
+        approval_policy: None,
+        profile: None,
+        config: BTreeMap::new(),
+    };
+
+    let mut handle = server.codex(params).await.expect("codex call");
+
+    let first_event = time::timeout(Duration::from_secs(2), handle.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("event value");
+    match first_event {
+        CodexEvent::ApprovalRequired(req) => {
+            assert!(req.approval_id.starts_with("ap-"));
+            assert_eq!(req.kind, ApprovalKind::Exec);
+        }
+        other => panic!("unexpected event: {other:?}"),
+    }
+
+    let second_event = time::timeout(Duration::from_secs(2), handle.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("event value");
+    let event_conversation = match second_event {
+        CodexEvent::TaskComplete {
+            conversation_id, ..
+        } => {
+            assert!(!conversation_id.is_empty());
+            conversation_id
+        }
+        other => panic!("unexpected event: {other:?}"),
+    };
+
+    let response = time::timeout(Duration::from_secs(2), handle.response)
+        .await
+        .expect("response timeout")
+        .expect("response recv");
+    let response = response.expect("response ok");
+    assert_eq!(
+        response.conversation_id.as_deref(),
+        Some(event_conversation.as_str())
+    );
+    assert_eq!(response.output, serde_json::json!({ "ok": true }));
+
+    let _ = server.shutdown().await;
+}
+
+#[tokio::test]
+async fn canceling_request_returns_cancelled_error() {
+    let (_dir, server) = start_fake_mcp_server().await;
+
+    let params = CodexCallParams {
+        prompt: "cancel me".into(),
+        model: None,
+        cwd: None,
+        sandbox: None,
+        approval_policy: None,
+        profile: None,
+        config: BTreeMap::new(),
+    };
+
+    let mut handle = server.codex(params).await.expect("codex call");
+    server.cancel(handle.request_id).expect("cancel send");
+
+    let expected_conversation = format!("conv-{}", handle.request_id);
+    let cancel_event = time::timeout(Duration::from_secs(2), handle.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("cancel notification");
+    match cancel_event {
+        CodexEvent::Cancelled {
+            conversation_id,
+            reason,
+        } => {
+            assert_eq!(
+                conversation_id.as_deref(),
+                Some(expected_conversation.as_str())
+            );
+            assert_eq!(reason.as_deref(), Some("client_cancel"));
+        }
+        other => panic!("expected cancellation event, got {other:?}"),
+    }
+
+    let response = time::timeout(Duration::from_secs(2), handle.response)
+        .await
+        .expect("response timeout")
+        .expect("recv");
+    assert!(matches!(response, Err(McpError::Cancelled)));
+
+    let _ = server.shutdown().await;
+}
+
+#[tokio::test]
+async fn codex_reply_streams_follow_up_notifications() {
+    let (_dir, server) = start_fake_mcp_server().await;
+
+    let params = CodexCallParams {
+        prompt: "hello".into(),
+        model: None,
+        cwd: None,
+        sandbox: None,
+        approval_policy: None,
+        profile: None,
+        config: BTreeMap::new(),
+    };
+    let first = server.codex(params).await.expect("start codex");
+    let first_response = time::timeout(Duration::from_secs(2), first.response)
+        .await
+        .expect("response timeout")
+        .expect("recv")
+        .expect("ok");
+    let conversation_id = first_response.conversation_id.expect("conversation id set");
+    assert!(!conversation_id.is_empty());
+
+    let reply_params = CodexReplyParams {
+        conversation_id: conversation_id.clone(),
+        prompt: "follow up".into(),
+    };
+    let mut reply = server.codex_reply(reply_params).await.expect("codex reply");
+
+    let expected_approval = format!("ap-{}", reply.request_id);
+    let approval = time::timeout(Duration::from_secs(2), reply.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("approval");
+    match approval {
+        CodexEvent::ApprovalRequired(req) => {
+            assert_eq!(req.approval_id, expected_approval);
+            assert_eq!(req.kind, ApprovalKind::Exec);
+        }
+        other => panic!("unexpected event: {other:?}"),
+    }
+
+    let complete = time::timeout(Duration::from_secs(2), reply.events.recv())
+        .await
+        .expect("event timeout")
+        .expect("task completion");
+    match complete {
+        CodexEvent::TaskComplete {
+            conversation_id: event_conv,
+            ..
+        } => assert_eq!(event_conv, conversation_id),
+        other => panic!("unexpected event: {other:?}"),
+    }
+
+    let reply_response = time::timeout(Duration::from_secs(2), reply.response)
+        .await
+        .expect("response timeout")
+        .expect("recv")
+        .expect("ok");
+    assert_eq!(
+        reply_response.conversation_id.as_deref(),
+        Some(conversation_id.as_str())
+    );
+    assert_eq!(reply_response.output, serde_json::json!({ "ok": true }));
+
+    let _ = server.shutdown().await;
+}
diff --git a/crates/codex/src/mcp/tests_core/config_runtime.rs b/crates/codex/src/mcp/tests_core/config_runtime.rs
new file mode 100644
index 0000000..c447e6b
--- /dev/null
+++ b/crates/codex/src/mcp/tests_core/config_runtime.rs
@@ -0,0 +1,425 @@
+use super::super::test_support::{prelude::*, *};
+use super::super::*;
+
+#[test]
+fn add_stdio_server_injects_env_and_persists() {
+    let (dir, manager) = temp_config_manager();
+    let env_key = "MCP_STDIO_TEST_KEY";
+    env::remove_var(env_key);
+
+    let mut env_map = BTreeMap::new();
+    env_map.insert(env_key.to_string(), "secret".to_string());
+
+    let added = manager
+        .add_server(AddServerRequest {
+            name: "local".into(),
+            definition: stdio_definition("my-mcp"),
+            overwrite: false,
+            env: env_map,
+            bearer_token: None,
+        })
+        .expect("add server");
+
+    match added.definition.transport {
+        McpTransport::Stdio(def) => {
+            assert_eq!(def.command, "my-mcp");
+            assert_eq!(def.env.get(env_key), Some(&"secret".to_string()));
+        }
+        _ => panic!("expected stdio transport"),
+    }
+
+    let listed = manager.list_servers().expect("list servers");
+    assert_eq!(listed.len(), 1);
+    assert_eq!(listed[0].name, "local");
+
+    let fetched = manager.get_server("local").expect("get server");
+    match fetched.definition.transport {
+        McpTransport::Stdio(def) => {
+            assert_eq!(def.env.get(env_key), Some(&"secret".to_string()))
+        }
+        _ => panic!("expected stdio transport"),
+    }
+
+    let config_path = dir.path().join(DEFAULT_CONFIG_FILE);
+    let serialized = fs::read_to_string(config_path).expect("read config");
+    let value: TomlValue = serialized.parse().expect("parse toml");
+    let table = value.as_table().expect("table root");
+    let servers_table = table.get("mcp_servers").expect("mcp_servers");
+    let decoded: BTreeMap<String, McpServerDefinition> = servers_table
+        .clone()
+        .try_into()
+        .expect("decode mcp_servers");
+    let stored = decoded.get("local").expect("stored server");
+    match &stored.transport {
+        McpTransport::Stdio(def) => {
+            assert_eq!(def.env.get(env_key), Some(&"secret".to_string()))
+        }
+        _ => panic!("expected stdio transport"),
+    }
+
+    assert_eq!(env::var(env_key).unwrap(), "secret");
+    env::remove_var(env_key);
+}
+
+#[test]
+fn add_streamable_http_sets_token_and_allows_login_logout() {
+    let (_dir, manager) = temp_config_manager();
+    let env_var = "MCP_HTTP_TOKEN_E5";
+    env::remove_var(env_var);
+
+    let mut definition = streamable_definition("https://example.test/mcp", env_var);
+    if let McpTransport::StreamableHttp(ref mut http) = definition.transport {
+        http.headers.insert("X-Test".into(), "true".into());
+    }
+
+    let _added = manager
+        .add_server(AddServerRequest {
+            name: "remote".into(),
+            definition,
+            overwrite: false,
+            env: BTreeMap::new(),
+            bearer_token: Some("token-a".into()),
+        })
+        .expect("add server");
+
+    assert_eq!(env::var(env_var).unwrap(), "token-a");
+
+    let logout = manager.logout("remote").expect("logout");
+    assert_eq!(logout.env_var.as_deref(), Some(env_var));
+    assert!(logout.cleared);
+    assert!(env::var(env_var).is_err());
+
+    let login = manager.login("remote", "token-b").expect("login");
+    assert_eq!(login.env_var.as_deref(), Some(env_var));
+    assert_eq!(env::var(env_var).unwrap(), "token-b");
+
+    env::remove_var(env_var);
+}
+
+#[test]
+fn remove_server_prunes_config() {
+    let (_dir, manager) = temp_config_manager();
+
+    manager
+        .add_server(AddServerRequest {
+            name: "one".into(),
+            definition: stdio_definition("one"),
+            overwrite: false,
+            env: BTreeMap::new(),
+            bearer_token: None,
+        })
+        .expect("add first");
+
+    manager
+        .add_server(AddServerRequest {
+            name: "two".into(),
+            definition: stdio_definition("two"),
+            overwrite: false,
+            env: BTreeMap::new(),
+            bearer_token: None,
+        })
+        .expect("add second");
+
+    let removed = manager.remove_server("one").expect("remove");
+    assert!(removed.is_some());
+
+    let listed = manager.list_servers().expect("list");
+    assert_eq!(listed.len(), 1);
+    assert_eq!(listed[0].name, "two");
+
+    let config = fs::read_to_string(manager.config_path()).expect("read config");
+    let value: TomlValue = config.parse().expect("parse config");
+    let table = value.as_table().expect("table root");
+    let servers_value = table.get("mcp_servers").cloned().expect("servers");
+    let servers: BTreeMap<String, McpServerDefinition> =
+        servers_value.try_into().expect("decode servers");
+    assert!(!servers.contains_key("one"));
+    assert!(servers.contains_key("two"));
+}
+
+#[test]
+fn runtime_stdio_server_resolves_env_and_tools() {
+    let (_dir, manager) = temp_config_manager();
+    let mut definition = stdio_definition("my-mcp");
+    definition.description = Some("local mcp".into());
+    definition.tags = vec!["dev".into(), "local".into()];
+    definition.tools = Some(McpToolConfig {
+        enabled: vec!["tool-a".into()],
+        disabled: vec!["tool-b".into()],
+    });
+
+    if let McpTransport::Stdio(ref mut stdio) = definition.transport {
+        stdio.args = vec!["--flag".into()];
+        stdio.env.insert("EXAMPLE".into(), "value".into());
+        stdio.timeout_ms = Some(2500);
+    }
+
+    let mut injected = BTreeMap::new();
+    injected.insert("MCP_STDIO_INJECT_E6".into(), "yes".into());
+
+    manager
+        .add_server(AddServerRequest {
+            name: "local".into(),
+            definition,
+            overwrite: false,
+            env: injected,
+            bearer_token: None,
+        })
+        .expect("add server");
+
+    let runtime = manager.runtime_server("local").expect("runtime server");
+    assert_eq!(runtime.name, "local");
+    assert_eq!(runtime.description.as_deref(), Some("local mcp"));
+    assert_eq!(runtime.tags, vec!["dev".to_string(), "local".to_string()]);
+
+    let tools = runtime.tools.as_ref().expect("tool hints");
+    assert_eq!(tools.enabled, vec!["tool-a".to_string()]);
+    assert_eq!(tools.disabled, vec!["tool-b".to_string()]);
+
+    match &runtime.transport {
+        McpRuntimeTransport::Stdio(def) => {
+            assert_eq!(def.command, "my-mcp");
+            assert_eq!(def.args, vec!["--flag".to_string()]);
+            assert_eq!(def.timeout_ms, Some(2500));
+            assert_eq!(def.env.get("EXAMPLE").map(String::as_str), Some("value"));
+            assert_eq!(
+                def.env.get("MCP_STDIO_INJECT_E6").map(String::as_str),
+                Some("yes")
+            );
+        }
+        other => panic!("expected stdio transport, got {other:?}"),
+    }
+
+    serde_json::to_string(&runtime).expect("serialize runtime");
+    env::remove_var("MCP_STDIO_INJECT_E6");
+}
+
+#[test]
+fn runtime_http_resolves_bearer_and_sets_header() {
+    let (_dir, manager) = temp_config_manager();
+    let env_var = "MCP_HTTP_TOKEN_E6";
+    env::set_var(env_var, "token-123");
+
+    let mut definition = streamable_definition("https://example.test/mcp", env_var);
+    if let McpTransport::StreamableHttp(ref mut http) = definition.transport {
+        http.headers.insert("X-Test".into(), "true".into());
+        http.connect_timeout_ms = Some(1200);
+        http.request_timeout_ms = Some(3400);
+    }
+
+    manager
+        .add_server(AddServerRequest {
+            name: "remote".into(),
+            definition,
+            overwrite: false,
+            env: BTreeMap::new(),
+            bearer_token: None,
+        })
+        .expect("add server");
+
+    let runtime = manager.runtime_server("remote").expect("runtime server");
+    match &runtime.transport {
+        McpRuntimeTransport::StreamableHttp(def) => {
+            assert_eq!(def.url, "https://example.test/mcp");
+            assert_eq!(def.bearer_env_var.as_deref(), Some(env_var));
+            assert_eq!(def.bearer_token.as_deref(), Some("token-123"));
+            assert_eq!(def.headers.get("X-Test").map(String::as_str), Some("true"));
+            assert_eq!(
+                def.headers.get("Authorization").map(String::as_str),
+                Some("Bearer token-123")
+            );
+            assert_eq!(def.connect_timeout_ms, Some(1200));
+            assert_eq!(def.request_timeout_ms, Some(3400));
+        }
+        other => panic!("expected streamable_http transport, got {other:?}"),
+    }
+
+    let serialized = serde_json::to_value(&runtime).expect("serialize runtime");
+    assert!(serialized.get("transport").is_some());
+
+    env::remove_var(env_var);
+}
+
+#[test]
+fn runtime_http_preserves_existing_auth_header() {
+    let (_dir, manager) = temp_config_manager();
+    let env_var = "MCP_HTTP_TOKEN_E6B";
+    env::set_var(env_var, "token-override");
+
+    let mut definition = streamable_definition("https://example.test/custom", env_var);
+    if let McpTransport::StreamableHttp(ref mut http) = definition.transport {
+        http.headers
+            .insert("Authorization".into(), "Custom 123".into());
+    }
+
+    manager
+        .add_server(AddServerRequest {
+            name: "remote-custom".into(),
+            definition,
+            overwrite: false,
+            env: BTreeMap::new(),
+            bearer_token: None,
+        })
+        .expect("add server");
+
+    let runtime = manager
+        .runtime_server("remote-custom")
+        .expect("runtime server");
+    match &runtime.transport {
+        McpRuntimeTransport::StreamableHttp(def) => {
+            assert_eq!(def.bearer_token.as_deref(), Some("token-override"));
+            assert_eq!(
+                def.headers.get("Authorization").map(String::as_str),
+                Some("Custom 123")
+            );
+        }
+        other => panic!("expected streamable_http transport, got {other:?}"),
+    }
+
+    env::remove_var(env_var);
+}
+
+#[test]
+fn runtime_stdio_launcher_merges_env_timeout_and_tools() {
+    let base_dir = tempfile::tempdir().expect("tempdir");
+    let code_home = base_dir.path().join("code_home");
+
+    let defaults = StdioServerConfig {
+        binary: PathBuf::from("codex"),
+        code_home: Some(code_home.clone()),
+        current_dir: Some(base_dir.path().to_path_buf()),
+        env: vec![
+            (OsString::from("BASE_ONLY"), OsString::from("base")),
+            (OsString::from("OVERRIDE_ME"), OsString::from("base")),
+        ],
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: true,
+        startup_timeout: Duration::from_secs(5),
+    };
+
+    let mut definition = StdioServerDefinition {
+        command: "my-mcp".into(),
+        args: vec!["--flag".into()],
+        env: BTreeMap::new(),
+        timeout_ms: Some(1500),
+    };
+    definition
+        .env
+        .insert("OVERRIDE_ME".into(), "runtime".into());
+    definition
+        .env
+        .insert("RUNTIME_ONLY".into(), "runtime-env".into());
+
+    let runtime = McpRuntimeServer {
+        name: "local".into(),
+        transport: McpRuntimeTransport::Stdio(definition),
+        description: Some("example".into()),
+        tags: vec!["dev".into()],
+        tools: Some(McpToolConfig {
+            enabled: vec!["tool-1".into()],
+            disabled: vec!["tool-2".into()],
+        }),
+    };
+
+    let launcher = runtime.into_launcher(&defaults);
+    assert_eq!(launcher.name, "local");
+    assert_eq!(launcher.description.as_deref(), Some("example"));
+    assert_eq!(launcher.tags, vec!["dev".to_string()]);
+
+    let tools = launcher.tools.clone().expect("tool hints");
+    assert_eq!(tools.enabled, vec!["tool-1".to_string()]);
+    assert_eq!(tools.disabled, vec!["tool-2".to_string()]);
+
+    match launcher.transport {
+        McpServerLauncherTransport::Stdio(launch) => {
+            assert_eq!(launch.command, PathBuf::from("my-mcp"));
+            assert_eq!(launch.args, vec!["--flag".to_string()]);
+            assert_eq!(launch.current_dir.as_ref(), defaults.current_dir.as_ref());
+            assert_eq!(launch.timeout, Duration::from_millis(1500));
+            assert!(launch.mirror_stdio);
+
+            let env_map: HashMap<OsString, OsString> = launch.env.into_iter().collect();
+            assert_eq!(
+                env_map.get(&OsString::from("BASE_ONLY")),
+                Some(&OsString::from("base"))
+            );
+            assert_eq!(
+                env_map.get(&OsString::from("OVERRIDE_ME")),
+                Some(&OsString::from("runtime"))
+            );
+            assert_eq!(
+                env_map.get(&OsString::from("RUNTIME_ONLY")),
+                Some(&OsString::from("runtime-env"))
+            );
+            assert_eq!(
+                env_map.get(&OsString::from("CODEX_HOME")),
+                Some(&code_home.as_os_str().to_os_string())
+            );
+        }
+        other => panic!("expected stdio launcher, got {other:?}"),
+    }
+}
+
+#[test]
+fn streamable_http_connector_converts_timeouts_and_headers() {
+    let env_var = "MCP_HTTP_TOKEN_E7";
+    env::set_var(env_var, "token-launcher");
+
+    let mut definition = StreamableHttpDefinition {
+        url: "https://example.test/stream".into(),
+        headers: BTreeMap::new(),
+        bearer_env_var: Some(env_var.to_string()),
+        connect_timeout_ms: Some(1200),
+        request_timeout_ms: Some(3400),
+    };
+    definition.headers.insert("X-Test".into(), "true".into());
+
+    let runtime = McpRuntimeServer::from_definition(
+        "remote",
+        McpServerDefinition {
+            transport: McpTransport::StreamableHttp(definition),
+            description: None,
+            tags: vec!["http".into()],
+            tools: Some(McpToolConfig {
+                enabled: vec!["tool-a".into()],
+                disabled: vec![],
+            }),
+        },
+    );
+
+    let defaults = StdioServerConfig {
+        binary: PathBuf::from("codex"),
+        code_home: None,
+        current_dir: None,
+        env: Vec::new(),
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(2),
+    };
+
+    let launcher = runtime.into_launcher(&defaults);
+    match launcher.transport {
+        McpServerLauncherTransport::StreamableHttp(connector) => {
+            assert_eq!(connector.url, "https://example.test/stream");
+            assert_eq!(
+                connector.headers.get("X-Test").map(String::as_str),
+                Some("true")
+            );
+            assert_eq!(
+                connector.headers.get("Authorization").map(String::as_str),
+                Some("Bearer token-launcher")
+            );
+            assert_eq!(connector.connect_timeout, Some(Duration::from_millis(1200)));
+            assert_eq!(connector.request_timeout, Some(Duration::from_millis(3400)));
+            assert_eq!(connector.bearer_env_var.as_deref(), Some(env_var));
+            assert_eq!(connector.bearer_token.as_deref(), Some("token-launcher"));
+
+            let tools = launcher.tools.as_ref().expect("tool hints present");
+            assert_eq!(tools.enabled, vec!["tool-a".to_string()]);
+            assert!(tools.disabled.is_empty());
+        }
+        other => panic!("expected http connector, got {other:?}"),
+    }
+
+    env::remove_var(env_var);
+}
diff --git a/crates/codex/src/mcp/tests_runtime_app.rs b/crates/codex/src/mcp/tests_runtime_app.rs
index 490143a..c055dac 100644
--- a/crates/codex/src/mcp/tests_runtime_app.rs
+++ b/crates/codex/src/mcp/tests_runtime_app.rs
@@ -1,979 +1,4 @@
-use super::test_support::{prelude::*, *};
-use super::*;
-
-#[test]
-fn runtime_api_lists_launchers_without_changing_config() {
-    let (dir, manager) = temp_config_manager();
-    let stdio_env_key = "MCP_RUNTIME_API_STDIO_ENV";
-    let request_env_key = "MCP_RUNTIME_API_REQUEST_ENV";
-    let http_env_key = "MCP_RUNTIME_API_HTTP_ENV";
-    env::set_var(http_env_key, "token-api");
-
-    let mut stdio = stdio_definition("runtime-api-stdio");
-    stdio.description = Some("stdio runtime".into());
-    stdio.tags = vec!["local".into()];
-    stdio.tools = Some(McpToolConfig {
-        enabled: vec!["fmt".into()],
-        disabled: vec!["lint".into()],
-    });
-    if let McpTransport::Stdio(ref mut stdio_def) = stdio.transport {
-        stdio_def.args.push("--flag".into());
-        stdio_def
-            .env
-            .insert(stdio_env_key.into(), "runtime-env".into());
-        stdio_def.timeout_ms = Some(2400);
-    }
-
-    let mut env_map = BTreeMap::new();
-    env_map.insert(request_env_key.to_string(), "injected".to_string());
-
-    manager
-        .add_server(AddServerRequest {
-            name: "local-api".into(),
-            definition: stdio,
-            overwrite: false,
-            env: env_map,
-            bearer_token: None,
-        })
-        .expect("add stdio server");
-
-    let mut http = streamable_definition("https://example.test/runtime-api", http_env_key);
-    http.description = Some("http runtime".into());
-    http.tags = vec!["remote".into()];
-    http.tools = Some(McpToolConfig {
-        enabled: vec!["alpha".into()],
-        disabled: vec!["beta".into()],
-    });
-    if let McpTransport::StreamableHttp(ref mut http_def) = http.transport {
-        http_def.headers.insert("X-Req".into(), "true".into());
-        http_def.request_timeout_ms = Some(2200);
-    }
-
-    manager
-        .add_server(AddServerRequest {
-            name: "remote-api".into(),
-            definition: http,
-            overwrite: false,
-            env: BTreeMap::new(),
-            bearer_token: None,
-        })
-        .expect("add http server");
-
-    let before = fs::read_to_string(manager.config_path()).expect("read config before");
-    let cwd = dir.path().join("cwd");
-
-    let defaults = StdioServerConfig {
-        binary: PathBuf::from("codex"),
-        code_home: Some(dir.path().to_path_buf()),
-        current_dir: Some(cwd.clone()),
-        env: vec![
-            (OsString::from("DEFAULT_ONLY"), OsString::from("default")),
-            (
-                OsString::from(request_env_key),
-                OsString::from("base-default"),
-            ),
-        ],
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: true,
-        startup_timeout: Duration::from_secs(3),
-    };
-
-    let api = McpRuntimeApi::from_config(&manager, &defaults).expect("runtime api");
-
-    let available = api.available();
-    assert_eq!(available.len(), 2);
-
-    let stdio_summary = available
-        .iter()
-        .find(|entry| entry.name == "local-api")
-        .expect("stdio summary");
-    assert_eq!(stdio_summary.transport, McpRuntimeSummaryTransport::Stdio);
-    let stdio_tools = stdio_summary.tools.as_ref().expect("stdio tools");
-    assert_eq!(stdio_tools.enabled, vec!["fmt".to_string()]);
-    assert_eq!(stdio_tools.disabled, vec!["lint".to_string()]);
-
-    let stdio_launcher = api.stdio_launcher("local-api").expect("stdio launcher");
-    assert_eq!(stdio_launcher.args, vec!["--flag".to_string()]);
-    assert_eq!(stdio_launcher.timeout, Duration::from_millis(2400));
-    assert!(stdio_launcher.mirror_stdio);
-    assert_eq!(stdio_launcher.current_dir.as_deref(), Some(cwd.as_path()));
-
-    let env_map: HashMap<OsString, OsString> = stdio_launcher.env.into_iter().collect();
-    assert_eq!(
-        env_map.get(&OsString::from("CODEX_HOME")),
-        Some(&dir.path().as_os_str().to_os_string())
-    );
-    assert_eq!(
-        env_map.get(&OsString::from("DEFAULT_ONLY")),
-        Some(&OsString::from("default"))
-    );
-    assert_eq!(
-        env_map.get(&OsString::from(request_env_key)),
-        Some(&OsString::from("injected"))
-    );
-    assert_eq!(
-        env_map.get(&OsString::from(stdio_env_key)),
-        Some(&OsString::from("runtime-env"))
-    );
-
-    let http_connector = api.http_connector("remote-api").expect("http connector");
-    assert_eq!(http_connector.bearer_token.as_deref(), Some("token-api"));
-    assert_eq!(
-        http_connector
-            .headers
-            .get("Authorization")
-            .map(String::as_str),
-        Some("Bearer token-api")
-    );
-    assert_eq!(
-        http_connector.headers.get("X-Req").map(String::as_str),
-        Some("true")
-    );
-    assert_eq!(
-        http_connector.request_timeout,
-        Some(Duration::from_millis(2200))
-    );
-
-    let http_tools = available
-        .iter()
-        .find(|entry| entry.name == "remote-api")
-        .and_then(|entry| entry.tools.as_ref())
-        .expect("http tools");
-    assert_eq!(http_tools.enabled, vec!["alpha".to_string()]);
-    assert_eq!(http_tools.disabled, vec!["beta".to_string()]);
-
-    match api.stdio_launcher("remote-api") {
-        Err(McpRuntimeError::UnsupportedTransport {
-            name,
-            expected,
-            actual,
-        }) => {
-            assert_eq!(name, "remote-api");
-            assert_eq!(expected, "stdio");
-            assert_eq!(actual, "streamable_http");
-        }
-        other => panic!("unexpected result: {other:?}"),
-    }
-
-    match api.http_connector("local-api") {
-        Err(McpRuntimeError::UnsupportedTransport {
-            name,
-            expected,
-            actual,
-        }) => {
-            assert_eq!(name, "local-api");
-            assert_eq!(expected, "streamable_http");
-            assert_eq!(actual, "stdio");
-        }
-        other => panic!("unexpected http result: {other:?}"),
-    }
-
-    let after = fs::read_to_string(manager.config_path()).expect("read config after");
-    assert_eq!(before, after);
-
-    env::remove_var(http_env_key);
-    env::remove_var(request_env_key);
-}
-
-#[test]
-fn runtime_api_prepare_http_is_non_destructive() {
-    let (dir, manager) = temp_config_manager();
-    let env_var = "MCP_RUNTIME_API_PREPARE";
-    env::set_var(env_var, "prepare-token");
-
-    let mut http = streamable_definition("https://example.test/prepare", env_var);
-    http.tags = vec!["prepare".into()];
-    http.tools = Some(McpToolConfig {
-        enabled: vec!["delta".into()],
-        disabled: vec![],
-    });
-
-    manager
-        .add_server(AddServerRequest {
-            name: "prepare-http".into(),
-            definition: http,
-            overwrite: false,
-            env: BTreeMap::new(),
-            bearer_token: None,
-        })
-        .expect("add http server");
-
-    let before = fs::read_to_string(manager.config_path()).expect("read config before");
-
-    let defaults = StdioServerConfig {
-        binary: PathBuf::from("codex"),
-        code_home: Some(dir.path().to_path_buf()),
-        current_dir: None,
-        env: Vec::new(),
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(2),
-    };
-
-    let api = McpRuntimeApi::from_config(&manager, &defaults).expect("runtime api");
-    let handle = api.prepare("prepare-http").expect("prepare http");
-
-    match handle {
-        McpRuntimeHandle::StreamableHttp(http_handle) => {
-            assert_eq!(http_handle.name, "prepare-http");
-            assert_eq!(
-                http_handle.connector.bearer_token.as_deref(),
-                Some("prepare-token")
-            );
-            assert_eq!(
-                http_handle
-                    .connector
-                    .headers
-                    .get("Authorization")
-                    .map(String::as_str),
-                Some("Bearer prepare-token")
-            );
-            let tools = http_handle.tools.expect("tool hints");
-            assert_eq!(tools.enabled, vec!["delta".to_string()]);
-        }
-        other => panic!("expected http handle, got {other:?}"),
-    }
-
-    let after = fs::read_to_string(manager.config_path()).expect("read config after");
-    assert_eq!(before, after);
-
-    env::remove_var(env_var);
-}
-
-#[test]
-fn app_runtime_api_lists_and_merges_without_writes() {
-    let (dir, manager) = temp_config_manager();
-
-    let alpha_home = dir.path().join("app-home-a");
-    let alpha_cwd = dir.path().join("app-cwd-a");
-    let mut alpha_env = BTreeMap::new();
-    alpha_env.insert("APP_RUNTIME_ENV".into(), "alpha".into());
-    alpha_env.insert("OVERRIDE_ME".into(), "runtime".into());
-
-    manager
-        .add_app_runtime(AddAppRuntimeRequest {
-            name: "alpha".into(),
-            definition: AppRuntimeDefinition {
-                description: Some("local app".into()),
-                tags: vec!["local".into()],
-                env: alpha_env,
-                code_home: Some(alpha_home.clone()),
-                current_dir: Some(alpha_cwd.clone()),
-                mirror_stdio: Some(true),
-                startup_timeout_ms: Some(4200),
-                binary: Some(PathBuf::from("/bin/app-alpha")),
-                metadata: serde_json::json!({"thread": "t-alpha"}),
-            },
-            overwrite: false,
-        })
-        .expect("add alpha app runtime");
-
-    let mut beta_env = BTreeMap::new();
-    beta_env.insert("APP_RUNTIME_ENV".into(), "beta".into());
-
-    manager
-        .add_app_runtime(AddAppRuntimeRequest {
-            name: "beta".into(),
-            definition: AppRuntimeDefinition {
-                description: None,
-                tags: vec!["default".into()],
-                env: beta_env,
-                code_home: None,
-                current_dir: None,
-                mirror_stdio: None,
-                startup_timeout_ms: None,
-                binary: None,
-                metadata: serde_json::json!({"resume": true}),
-            },
-            overwrite: false,
-        })
-        .expect("add beta app runtime");
-
-    let before = fs::read_to_string(manager.config_path()).expect("read config before");
-
-    let default_home = dir.path().join("default-home");
-    let default_cwd = dir.path().join("default-cwd");
-    let defaults = StdioServerConfig {
-        binary: PathBuf::from("codex"),
-        code_home: Some(default_home.clone()),
-        current_dir: Some(default_cwd.clone()),
-        env: vec![
-            (OsString::from("DEFAULT_ONLY"), OsString::from("base")),
-            (OsString::from("OVERRIDE_ME"), OsString::from("base")),
-        ],
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(3),
-    };
-
-    let api = AppRuntimeApi::from_config(&manager, &defaults).expect("app runtime api");
-
-    let available = api.available();
-    assert_eq!(available.len(), 2);
-
-    let alpha_summary = available
-        .iter()
-        .find(|entry| entry.name == "alpha")
-        .expect("alpha summary");
-    assert_eq!(alpha_summary.description.as_deref(), Some("local app"));
-    assert_eq!(alpha_summary.tags, vec!["local".to_string()]);
-    assert_eq!(
-        alpha_summary.metadata,
-        serde_json::json!({"thread": "t-alpha"})
-    );
-
-    let alpha = api.prepare("alpha").expect("prepare alpha");
-    assert_eq!(alpha.name, "alpha");
-    assert_eq!(alpha.metadata, serde_json::json!({"thread": "t-alpha"}));
-    assert_eq!(alpha.config.binary, PathBuf::from("/bin/app-alpha"));
-    assert_eq!(
-        alpha.config.code_home.as_deref(),
-        Some(alpha_home.as_path())
-    );
-    assert_eq!(
-        alpha.config.current_dir.as_deref(),
-        Some(alpha_cwd.as_path())
-    );
-    assert!(alpha.config.mirror_stdio);
-    assert_eq!(alpha.config.startup_timeout, Duration::from_millis(4200));
-
-    let alpha_env: HashMap<OsString, OsString> = alpha.config.env.into_iter().collect();
-    assert_eq!(
-        alpha_env.get(&OsString::from("CODEX_HOME")),
-        Some(&alpha_home.as_os_str().to_os_string())
-    );
-    assert_eq!(
-        alpha_env.get(&OsString::from("DEFAULT_ONLY")),
-        Some(&OsString::from("base"))
-    );
-    assert_eq!(
-        alpha_env.get(&OsString::from("OVERRIDE_ME")),
-        Some(&OsString::from("runtime"))
-    );
-    assert_eq!(
-        alpha_env.get(&OsString::from("APP_RUNTIME_ENV")),
-        Some(&OsString::from("alpha"))
-    );
-
-    let beta = api.stdio_config("beta").expect("beta config");
-    assert_eq!(beta.binary, PathBuf::from("codex"));
-    assert_eq!(beta.code_home.as_deref(), Some(default_home.as_path()));
-    assert_eq!(beta.current_dir.as_deref(), Some(default_cwd.as_path()));
-    assert!(!beta.mirror_stdio);
-    assert_eq!(beta.startup_timeout, Duration::from_secs(3));
-
-    let beta_env: HashMap<OsString, OsString> = beta.env.into_iter().collect();
-    assert_eq!(
-        beta_env.get(&OsString::from("CODEX_HOME")),
-        Some(&default_home.as_os_str().to_os_string())
-    );
-    assert_eq!(
-        beta_env.get(&OsString::from("DEFAULT_ONLY")),
-        Some(&OsString::from("base"))
-    );
-    assert_eq!(
-        beta_env.get(&OsString::from("OVERRIDE_ME")),
-        Some(&OsString::from("base"))
-    );
-    assert_eq!(
-        beta_env.get(&OsString::from("APP_RUNTIME_ENV")),
-        Some(&OsString::from("beta"))
-    );
-
-    let beta_summary = available
-        .iter()
-        .find(|entry| entry.name == "beta")
-        .expect("beta summary");
-    assert_eq!(beta_summary.metadata, serde_json::json!({"resume": true}));
-
-    let after = fs::read_to_string(manager.config_path()).expect("read config after");
-    assert_eq!(before, after);
-}
-
-#[tokio::test]
-async fn app_runtime_lifecycle_starts_and_stops_without_mutation() {
-    let (config_dir, manager) = temp_config_manager();
-    let (_server_dir, server_path) = write_fake_app_server();
-    let code_home = config_dir.path().join("app-lifecycle-home");
-
-    let mut env_map = BTreeMap::new();
-    env_map.insert("APP_RUNTIME_LIFECYCLE".into(), "runtime-env".into());
-
-    let metadata = serde_json::json!({"resume_thread": "thread-lifecycle"});
-    manager
-        .add_app_runtime(AddAppRuntimeRequest {
-            name: "lifecycle".into(),
-            definition: AppRuntimeDefinition {
-                description: Some("app lifecycle".into()),
-                tags: vec!["app".into()],
-                env: env_map,
-                code_home: None,
-                current_dir: None,
-                mirror_stdio: Some(true),
-                startup_timeout_ms: Some(1500),
-                binary: None,
-                metadata: metadata.clone(),
-            },
-            overwrite: false,
-        })
-        .expect("add app runtime");
-
-    let defaults = StdioServerConfig {
-        binary: server_path.clone(),
-        code_home: Some(code_home.clone()),
-        current_dir: None,
-        env: vec![(
-            OsString::from("APP_RUNTIME_LIFECYCLE"),
-            OsString::from("default"),
-        )],
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(3),
-    };
-
-    let before = fs::read_to_string(manager.config_path()).expect("read config before");
-    let api = AppRuntimeApi::from_config(&manager, &defaults).expect("build api");
-    let client = test_client();
-
-    let runtime = api
-        .start("lifecycle", client.clone())
-        .await
-        .expect("start runtime");
-    assert_eq!(runtime.name, "lifecycle");
-    assert_eq!(runtime.metadata, metadata);
-
-    let env_values: HashMap<OsString, OsString> = runtime.config.env.iter().cloned().collect();
-    assert_eq!(
-        env_values.get(&OsString::from("CODEX_HOME")),
-        Some(&code_home.as_os_str().to_os_string())
-    );
-    assert_eq!(
-        env_values.get(&OsString::from("APP_RUNTIME_LIFECYCLE")),
-        Some(&OsString::from("runtime-env"))
-    );
-
-    let thread = runtime
-        .server
-        .thread_start(ThreadStartParams {
-            thread_id: None,
-            metadata: serde_json::json!({"from": "lifecycle"}),
-        })
-        .await
-        .expect("thread start");
-    let thread_response = time::timeout(Duration::from_secs(2), thread.response)
-        .await
-        .expect("thread response timeout")
-        .expect("recv thread response")
-        .expect("thread response ok");
-    let thread_id = thread_response
-        .get("thread_id")
-        .and_then(Value::as_str)
-        .unwrap_or_default()
-        .to_string();
-    assert!(!thread_id.is_empty());
-
-    runtime.stop().await.expect("shutdown runtime");
-
-    let after = fs::read_to_string(manager.config_path()).expect("read config after");
-    assert_eq!(before, after);
-
-    let prepared = api.prepare("lifecycle").expect("prepare after stop");
-    assert_eq!(prepared.metadata, metadata);
-}
-
-#[tokio::test]
-async fn app_runtime_api_not_found_errors() {
-    let api = AppRuntimeApi::new(Vec::new());
-    match api.prepare("missing") {
-        Err(AppRuntimeError::NotFound(name)) => assert_eq!(name, "missing"),
-        other => panic!("unexpected result: {other:?}"),
-    }
-
-    let client = test_client();
-    match api.start("missing", client).await {
-        Err(AppRuntimeError::NotFound(name)) => assert_eq!(name, "missing"),
-        other => panic!("unexpected start result: {other:?}"),
-    }
-}
-
-#[tokio::test]
-async fn app_runtime_pool_api_reuses_and_restarts_stdio() {
-    let (config_dir, manager) = temp_config_manager();
-    let (_server_dir, server_path) = write_fake_app_server();
-    let code_home = config_dir.path().join("app-pool-home");
-
-    let mut env_map = BTreeMap::new();
-    env_map.insert("APP_POOL_ENV".into(), "runtime".into());
-
-    let metadata = serde_json::json!({"resume_thread": "thread-pool"});
-    manager
-        .add_app_runtime(AddAppRuntimeRequest {
-            name: "pooled".into(),
-            definition: AppRuntimeDefinition {
-                description: Some("pooled app".into()),
-                tags: vec!["pool".into()],
-                env: env_map,
-                code_home: None,
-                current_dir: None,
-                mirror_stdio: Some(true),
-                startup_timeout_ms: Some(2000),
-                binary: None,
-                metadata: metadata.clone(),
-            },
-            overwrite: false,
-        })
-        .expect("add app runtime");
-
-    let defaults = StdioServerConfig {
-        binary: server_path.clone(),
-        code_home: Some(code_home.clone()),
-        current_dir: None,
-        env: vec![
-            (OsString::from("APP_POOL_ENV"), OsString::from("default")),
-            (OsString::from("POOL_ONLY"), OsString::from("base")),
-        ],
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(3),
-    };
-
-    let before = fs::read_to_string(manager.config_path()).expect("read config before");
-    let api = AppRuntimePoolApi::from_config(&manager, &defaults).expect("build pool api");
-    let client = test_client();
-
-    let available = api.available();
-    assert_eq!(available.len(), 1);
-    let pooled_summary = &available[0];
-    assert_eq!(pooled_summary.name, "pooled");
-    assert_eq!(pooled_summary.metadata, metadata);
-
-    let launcher = api.launcher("pooled").expect("pooled launcher");
-    assert_eq!(launcher.description.as_deref(), Some("pooled app"));
-    assert_eq!(launcher.metadata, metadata);
-
-    let launcher_config = launcher.config.clone();
-    assert_eq!(launcher_config.binary, server_path);
-    assert_eq!(
-        launcher_config.code_home.as_deref(),
-        Some(code_home.as_path())
-    );
-    assert_eq!(launcher_config.startup_timeout, Duration::from_secs(2));
-
-    let launcher_env: HashMap<OsString, OsString> = launcher_config.env.into_iter().collect();
-    assert_eq!(
-        launcher_env.get(&OsString::from("CODEX_HOME")),
-        Some(&code_home.as_os_str().to_os_string())
-    );
-    assert_eq!(
-        launcher_env.get(&OsString::from("POOL_ONLY")),
-        Some(&OsString::from("base"))
-    );
-    assert_eq!(
-        launcher_env.get(&OsString::from("APP_POOL_ENV")),
-        Some(&OsString::from("runtime"))
-    );
-
-    let stdio_config = api
-        .stdio_config("pooled")
-        .expect("pooled stdio config without starting");
-    assert_eq!(stdio_config.binary, server_path);
-    assert_eq!(stdio_config.code_home.as_deref(), Some(code_home.as_path()));
-    let stdio_env: HashMap<OsString, OsString> = stdio_config.env.into_iter().collect();
-    assert_eq!(
-        stdio_env.get(&OsString::from("POOL_ONLY")),
-        Some(&OsString::from("base"))
-    );
-    assert_eq!(
-        stdio_env.get(&OsString::from("CODEX_HOME")),
-        Some(&code_home.as_os_str().to_os_string())
-    );
-    assert_eq!(
-        stdio_env.get(&OsString::from("APP_POOL_ENV")),
-        Some(&OsString::from("runtime"))
-    );
-
-    assert!(api.running().await.is_empty());
-
-    let runtime = api
-        .start("pooled", client.clone())
-        .await
-        .expect("start pooled runtime");
-    assert_eq!(runtime.name, "pooled");
-    assert_eq!(runtime.metadata, metadata);
-
-    let env_values: HashMap<OsString, OsString> = runtime.config.env.iter().cloned().collect();
-    assert_eq!(
-        env_values.get(&OsString::from("CODEX_HOME")),
-        Some(&code_home.as_os_str().to_os_string())
-    );
-    assert_eq!(
-        env_values.get(&OsString::from("POOL_ONLY")),
-        Some(&OsString::from("base"))
-    );
-    assert_eq!(
-        env_values.get(&OsString::from("APP_POOL_ENV")),
-        Some(&OsString::from("runtime"))
-    );
-
-    let thread = runtime
-        .server
-        .thread_start(ThreadStartParams {
-            thread_id: None,
-            metadata: serde_json::json!({"from": "pool"}),
-        })
-        .await
-        .expect("thread start");
-    let response = time::timeout(Duration::from_secs(2), thread.response)
-        .await
-        .expect("thread response timeout")
-        .expect("recv thread response")
-        .expect("thread response ok");
-    let thread_id = response
-        .get("thread_id")
-        .and_then(Value::as_str)
-        .unwrap_or_default()
-        .to_string();
-    assert!(!thread_id.is_empty());
-
-    let running = api.running().await;
-    let running_summary = running
-        .iter()
-        .find(|summary| summary.name == "pooled")
-        .expect("running summary present");
-    assert_eq!(running_summary.metadata, metadata);
-
-    let reused = api
-        .start("pooled", client.clone())
-        .await
-        .expect("reuse pooled runtime");
-    assert!(Arc::ptr_eq(&runtime, &reused));
-
-    api.stop("pooled").await.expect("stop pooled runtime");
-    match api.stop("pooled").await {
-        Err(AppRuntimeError::NotFound(name)) => assert_eq!(name, "pooled"),
-        other => panic!("expected not found on second stop, got {other:?}"),
-    }
-
-    assert!(api.running().await.is_empty());
-
-    let restarted = api
-        .start("pooled", client)
-        .await
-        .expect("restart pooled runtime");
-    assert!(!Arc::ptr_eq(&runtime, &restarted));
-    assert_eq!(restarted.metadata, metadata);
-
-    let prepared = api.prepare("pooled").expect("prepare after restart");
-    assert_eq!(prepared.metadata, metadata);
-
-    let after = fs::read_to_string(manager.config_path()).expect("read config after");
-    assert_eq!(before, after);
-}
-
-#[tokio::test]
-async fn app_runtime_pool_api_stop_all_shuts_down_runtimes() {
-    let (config_dir, manager) = temp_config_manager();
-    let (_server_dir, server_path) = write_fake_app_server();
-    let code_home = config_dir.path().join("app-pool-stop-home");
-
-    let alpha_metadata = serde_json::json!({"resume_thread": "alpha"});
-    manager
-        .add_app_runtime(AddAppRuntimeRequest {
-            name: "alpha".into(),
-            definition: AppRuntimeDefinition {
-                description: Some("alpha runtime".into()),
-                tags: vec!["pool".into()],
-                env: BTreeMap::new(),
-                code_home: None,
-                current_dir: None,
-                mirror_stdio: Some(false),
-                startup_timeout_ms: Some(2000),
-                binary: None,
-                metadata: alpha_metadata.clone(),
-            },
-            overwrite: false,
-        })
-        .expect("add alpha runtime");
-
-    let beta_metadata = serde_json::json!({"resume_thread": "beta"});
-    manager
-        .add_app_runtime(AddAppRuntimeRequest {
-            name: "beta".into(),
-            definition: AppRuntimeDefinition {
-                description: Some("beta runtime".into()),
-                tags: vec!["pool".into()],
-                env: BTreeMap::new(),
-                code_home: None,
-                current_dir: None,
-                mirror_stdio: Some(false),
-                startup_timeout_ms: Some(2000),
-                binary: None,
-                metadata: beta_metadata.clone(),
-            },
-            overwrite: false,
-        })
-        .expect("add beta runtime");
-
-    let defaults = StdioServerConfig {
-        binary: server_path.clone(),
-        code_home: Some(code_home.clone()),
-        current_dir: None,
-        env: Vec::new(),
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(3),
-    };
-
-    let before = fs::read_to_string(manager.config_path()).expect("read config before");
-    let api = AppRuntimePoolApi::from_config(&manager, &defaults).expect("build pool api");
-    let client = test_client();
-
-    assert!(api.running().await.is_empty());
-
-    let alpha = api
-        .start("alpha", client.clone())
-        .await
-        .expect("start alpha runtime");
-    let beta = api
-        .start("beta", client.clone())
-        .await
-        .expect("start beta runtime");
-
-    assert_eq!(alpha.metadata, alpha_metadata);
-    assert_eq!(beta.metadata, beta_metadata);
-
-    let mut running = api.running().await;
-    running.sort_by(|a, b| a.name.cmp(&b.name));
-    assert_eq!(running.len(), 2);
-    assert_eq!(running[0].name, "alpha");
-    assert_eq!(running[0].metadata, alpha_metadata);
-    assert_eq!(running[1].name, "beta");
-    assert_eq!(running[1].metadata, beta_metadata);
-
-    let alpha_thread = alpha
-        .server
-        .thread_start(ThreadStartParams {
-            thread_id: None,
-            metadata: serde_json::json!({"from": "alpha"}),
-        })
-        .await
-        .expect("alpha thread start");
-    let _ = time::timeout(Duration::from_secs(2), alpha_thread.response)
-        .await
-        .expect("alpha thread response timeout")
-        .expect("alpha response recv")
-        .expect("alpha ok");
-
-    api.stop_all().await.expect("stop all runtimes");
-    assert!(api.running().await.is_empty());
-
-    let restarted_alpha = api
-        .start("alpha", client.clone())
-        .await
-        .expect("restart alpha");
-    assert!(!Arc::ptr_eq(&alpha, &restarted_alpha));
-    assert_eq!(restarted_alpha.metadata, alpha_metadata);
-
-    let restarted_beta = api.start("beta", client).await.expect("restart beta");
-    assert!(!Arc::ptr_eq(&beta, &restarted_beta));
-    assert_eq!(restarted_beta.metadata, beta_metadata);
-
-    let prepared_alpha = api.prepare("alpha").expect("prepare alpha");
-    assert_eq!(prepared_alpha.metadata, alpha_metadata);
-    let prepared_beta = api.prepare("beta").expect("prepare beta");
-    assert_eq!(prepared_beta.metadata, beta_metadata);
-
-    let after = fs::read_to_string(manager.config_path()).expect("read config after");
-    assert_eq!(before, after);
-}
-
-#[tokio::test]
-async fn runtime_manager_starts_and_stops_stdio() {
-    let (_dir, script) = write_env_probe_server("MCP_RUNTIME_ENV_E8");
-    let code_home = tempfile::tempdir().expect("code_home");
-
-    let defaults = StdioServerConfig {
-        binary: PathBuf::from("codex"),
-        code_home: Some(code_home.path().to_path_buf()),
-        current_dir: None,
-        env: vec![(
-            OsString::from("MCP_RUNTIME_ENV_E8"),
-            OsString::from("manager-ok"),
-        )],
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(5),
-    };
-
-    let runtime = McpRuntimeServer {
-        name: "env-probe".into(),
-        transport: McpRuntimeTransport::Stdio(StdioServerDefinition {
-            command: script.to_string_lossy().to_string(),
-            args: Vec::new(),
-            env: BTreeMap::new(),
-            timeout_ms: Some(1500),
-        }),
-        description: None,
-        tags: vec!["local".into()],
-        tools: Some(McpToolConfig {
-            enabled: vec!["tool-x".into()],
-            disabled: vec![],
-        }),
-    };
-
-    let launcher = runtime.into_launcher(&defaults);
-    let manager = McpRuntimeManager::new(vec![launcher]);
-
-    let mut handle = match manager.prepare("env-probe").expect("prepare stdio") {
-        McpRuntimeHandle::Stdio(handle) => handle,
-        other => panic!("expected stdio handle, got {other:?}"),
-    };
-
-    let mut reader = BufReader::new(handle.stdout_mut());
-    let mut line = String::new();
-    let _ = time::timeout(Duration::from_secs(2), reader.read_line(&mut line))
-        .await
-        .expect("read timeout")
-        .expect("read env line");
-    assert_eq!(line.trim(), "manager-ok");
-
-    let tools = handle.tools().expect("tool hints");
-    assert_eq!(tools.enabled, vec!["tool-x".to_string()]);
-
-    handle.stop().await.expect("stop server");
-}
-
-#[test]
-fn runtime_manager_propagates_tool_hints_for_http() {
-    let env_var = "MCP_HTTP_TOKEN_E8_HINTS";
-    env::set_var(env_var, "token-hints");
-
-    let mut http = StreamableHttpDefinition {
-        url: "https://example.test/hints".into(),
-        headers: BTreeMap::new(),
-        bearer_env_var: Some(env_var.to_string()),
-        connect_timeout_ms: Some(1200),
-        request_timeout_ms: Some(2400),
-    };
-    http.headers.insert("X-Test".into(), "true".into());
-
-    let runtime = McpRuntimeServer::from_definition(
-        "remote-http",
-        McpServerDefinition {
-            transport: McpTransport::StreamableHttp(http),
-            description: Some("http runtime".into()),
-            tags: vec!["http".into()],
-            tools: Some(McpToolConfig {
-                enabled: vec!["alpha".into()],
-                disabled: vec!["beta".into()],
-            }),
-        },
-    );
-
-    let defaults = StdioServerConfig {
-        binary: PathBuf::from("codex"),
-        code_home: None,
-        current_dir: None,
-        env: Vec::new(),
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(2),
-    };
-
-    let launcher = runtime.into_launcher(&defaults);
-    let manager = McpRuntimeManager::new(vec![launcher]);
-
-    let available = manager.available();
-    assert_eq!(available.len(), 1);
-    let summary = &available[0];
-    assert_eq!(summary.name, "remote-http");
-    assert_eq!(
-        summary.transport,
-        McpRuntimeSummaryTransport::StreamableHttp
-    );
-    let summary_tools = summary.tools.as_ref().expect("tool hints present");
-    assert_eq!(summary_tools.enabled, vec!["alpha".to_string()]);
-    assert_eq!(summary_tools.disabled, vec!["beta".to_string()]);
-
-    match manager.prepare("remote-http").expect("prepare http") {
-        McpRuntimeHandle::StreamableHttp(http_handle) => {
-            let tools = http_handle.tools.as_ref().expect("tool hints on handle");
-            assert_eq!(tools.enabled, vec!["alpha".to_string()]);
-            assert_eq!(tools.disabled, vec!["beta".to_string()]);
-            assert_eq!(
-                http_handle.connector.bearer_token.as_deref(),
-                Some("token-hints")
-            );
-        }
-        other => panic!("expected http handle, got {other:?}"),
-    }
-
-    env::remove_var(env_var);
-}
-
-#[test]
-fn http_connector_retrieval_is_non_destructive() {
-    let env_var = "MCP_HTTP_TOKEN_E8_REUSE";
-    env::set_var(env_var, "token-reuse");
-
-    let runtime = McpRuntimeServer::from_definition(
-        "remote-reuse",
-        McpServerDefinition {
-            transport: McpTransport::StreamableHttp(StreamableHttpDefinition {
-                url: "https://example.test/reuse".into(),
-                headers: BTreeMap::new(),
-                bearer_env_var: Some(env_var.to_string()),
-                connect_timeout_ms: Some(1500),
-                request_timeout_ms: Some(3200),
-            }),
-            description: None,
-            tags: vec!["http".into()],
-            tools: Some(McpToolConfig {
-                enabled: vec!["one".into()],
-                disabled: vec![],
-            }),
-        },
-    );
-
-    let defaults = StdioServerConfig {
-        binary: PathBuf::from("codex"),
-        code_home: None,
-        current_dir: None,
-        env: Vec::new(),
-        app_server_analytics_default_enabled: false,
-        mirror_stdio: false,
-        startup_timeout: Duration::from_secs(2),
-    };
-
-    let launcher = runtime.into_launcher(&defaults);
-    let manager = McpRuntimeManager::new(vec![launcher]);
-
-    let first = manager.prepare("remote-reuse").expect("first prepare");
-    let second = manager.prepare("remote-reuse").expect("second prepare");
-
-    let first_token = match first {
-        McpRuntimeHandle::StreamableHttp(handle) => handle.connector.bearer_token,
-        other => panic!("expected http handle, got {other:?}"),
-    };
-    let second_token = match second {
-        McpRuntimeHandle::StreamableHttp(handle) => handle.connector.bearer_token,
-        other => panic!("expected http handle, got {other:?}"),
-    };
-
-    assert_eq!(first_token.as_deref(), Some("token-reuse"));
-    assert_eq!(second_token.as_deref(), Some("token-reuse"));
-
-    let summary = manager
-        .available()
-        .into_iter()
-        .find(|s| s.name == "remote-reuse")
-        .expect("summary present");
-    assert_eq!(
-        summary.transport,
-        McpRuntimeSummaryTransport::StreamableHttp
-    );
-    let tools = summary.tools.as_ref().expect("tool hints preserved");
-    assert_eq!(tools.enabled, vec!["one".to_string()]);
-
-    env::remove_var(env_var);
-}
+mod app_runtime_api;
+mod app_runtime_pool_api;
+mod runtime_api;
+mod runtime_manager;
diff --git a/crates/codex/src/mcp/tests_runtime_app/app_runtime_api.rs b/crates/codex/src/mcp/tests_runtime_app/app_runtime_api.rs
new file mode 100644
index 0000000..2e71f15
--- /dev/null
+++ b/crates/codex/src/mcp/tests_runtime_app/app_runtime_api.rs
@@ -0,0 +1,258 @@
+use super::super::test_support::{prelude::*, *};
+use super::super::*;
+
+#[test]
+fn app_runtime_api_lists_and_merges_without_writes() {
+    let (dir, manager) = temp_config_manager();
+
+    let alpha_home = dir.path().join("app-home-a");
+    let alpha_cwd = dir.path().join("app-cwd-a");
+    let mut alpha_env = BTreeMap::new();
+    alpha_env.insert("APP_RUNTIME_ENV".into(), "alpha".into());
+    alpha_env.insert("OVERRIDE_ME".into(), "runtime".into());
+
+    manager
+        .add_app_runtime(AddAppRuntimeRequest {
+            name: "alpha".into(),
+            definition: AppRuntimeDefinition {
+                description: Some("local app".into()),
+                tags: vec!["local".into()],
+                env: alpha_env,
+                code_home: Some(alpha_home.clone()),
+                current_dir: Some(alpha_cwd.clone()),
+                mirror_stdio: Some(true),
+                startup_timeout_ms: Some(4200),
+                binary: Some(PathBuf::from("/bin/app-alpha")),
+                metadata: serde_json::json!({"thread": "t-alpha"}),
+            },
+            overwrite: false,
+        })
+        .expect("add alpha app runtime");
+
+    let mut beta_env = BTreeMap::new();
+    beta_env.insert("APP_RUNTIME_ENV".into(), "beta".into());
+
+    manager
+        .add_app_runtime(AddAppRuntimeRequest {
+            name: "beta".into(),
+            definition: AppRuntimeDefinition {
+                description: None,
+                tags: vec!["default".into()],
+                env: beta_env,
+                code_home: None,
+                current_dir: None,
+                mirror_stdio: None,
+                startup_timeout_ms: None,
+                binary: None,
+                metadata: serde_json::json!({"resume": true}),
+            },
+            overwrite: false,
+        })
+        .expect("add beta app runtime");
+
+    let before = fs::read_to_string(manager.config_path()).expect("read config before");
+
+    let default_home = dir.path().join("default-home");
+    let default_cwd = dir.path().join("default-cwd");
+    let defaults = StdioServerConfig {
+        binary: PathBuf::from("codex"),
+        code_home: Some(default_home.clone()),
+        current_dir: Some(default_cwd.clone()),
+        env: vec![
+            (OsString::from("DEFAULT_ONLY"), OsString::from("base")),
+            (OsString::from("OVERRIDE_ME"), OsString::from("base")),
+        ],
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(3),
+    };
+
+    let api = AppRuntimeApi::from_config(&manager, &defaults).expect("app runtime api");
+
+    let available = api.available();
+    assert_eq!(available.len(), 2);
+
+    let alpha_summary = available
+        .iter()
+        .find(|entry| entry.name == "alpha")
+        .expect("alpha summary");
+    assert_eq!(alpha_summary.description.as_deref(), Some("local app"));
+    assert_eq!(alpha_summary.tags, vec!["local".to_string()]);
+    assert_eq!(
+        alpha_summary.metadata,
+        serde_json::json!({"thread": "t-alpha"})
+    );
+
+    let alpha = api.prepare("alpha").expect("prepare alpha");
+    assert_eq!(alpha.name, "alpha");
+    assert_eq!(alpha.metadata, serde_json::json!({"thread": "t-alpha"}));
+    assert_eq!(alpha.config.binary, PathBuf::from("/bin/app-alpha"));
+    assert_eq!(
+        alpha.config.code_home.as_deref(),
+        Some(alpha_home.as_path())
+    );
+    assert_eq!(
+        alpha.config.current_dir.as_deref(),
+        Some(alpha_cwd.as_path())
+    );
+    assert!(alpha.config.mirror_stdio);
+    assert_eq!(alpha.config.startup_timeout, Duration::from_millis(4200));
+
+    let alpha_env: HashMap<OsString, OsString> = alpha.config.env.into_iter().collect();
+    assert_eq!(
+        alpha_env.get(&OsString::from("CODEX_HOME")),
+        Some(&alpha_home.as_os_str().to_os_string())
+    );
+    assert_eq!(
+        alpha_env.get(&OsString::from("DEFAULT_ONLY")),
+        Some(&OsString::from("base"))
+    );
+    assert_eq!(
+        alpha_env.get(&OsString::from("OVERRIDE_ME")),
+        Some(&OsString::from("runtime"))
+    );
+    assert_eq!(
+        alpha_env.get(&OsString::from("APP_RUNTIME_ENV")),
+        Some(&OsString::from("alpha"))
+    );
+
+    let beta = api.stdio_config("beta").expect("beta config");
+    assert_eq!(beta.binary, PathBuf::from("codex"));
+    assert_eq!(beta.code_home.as_deref(), Some(default_home.as_path()));
+    assert_eq!(beta.current_dir.as_deref(), Some(default_cwd.as_path()));
+    assert!(!beta.mirror_stdio);
+    assert_eq!(beta.startup_timeout, Duration::from_secs(3));
+
+    let beta_env: HashMap<OsString, OsString> = beta.env.into_iter().collect();
+    assert_eq!(
+        beta_env.get(&OsString::from("CODEX_HOME")),
+        Some(&default_home.as_os_str().to_os_string())
+    );
+    assert_eq!(
+        beta_env.get(&OsString::from("DEFAULT_ONLY")),
+        Some(&OsString::from("base"))
+    );
+    assert_eq!(
+        beta_env.get(&OsString::from("OVERRIDE_ME")),
+        Some(&OsString::from("base"))
+    );
+    assert_eq!(
+        beta_env.get(&OsString::from("APP_RUNTIME_ENV")),
+        Some(&OsString::from("beta"))
+    );
+
+    let beta_summary = available
+        .iter()
+        .find(|entry| entry.name == "beta")
+        .expect("beta summary");
+    assert_eq!(beta_summary.metadata, serde_json::json!({"resume": true}));
+
+    let after = fs::read_to_string(manager.config_path()).expect("read config after");
+    assert_eq!(before, after);
+}
+
+#[tokio::test]
+async fn app_runtime_lifecycle_starts_and_stops_without_mutation() {
+    let (config_dir, manager) = temp_config_manager();
+    let (_server_dir, server_path) = write_fake_app_server();
+    let code_home = config_dir.path().join("app-lifecycle-home");
+
+    let mut env_map = BTreeMap::new();
+    env_map.insert("APP_RUNTIME_LIFECYCLE".into(), "runtime-env".into());
+
+    let metadata = serde_json::json!({"resume_thread": "thread-lifecycle"});
+    manager
+        .add_app_runtime(AddAppRuntimeRequest {
+            name: "lifecycle".into(),
+            definition: AppRuntimeDefinition {
+                description: Some("app lifecycle".into()),
+                tags: vec!["app".into()],
+                env: env_map,
+                code_home: None,
+                current_dir: None,
+                mirror_stdio: Some(true),
+                startup_timeout_ms: Some(1500),
+                binary: None,
+                metadata: metadata.clone(),
+            },
+            overwrite: false,
+        })
+        .expect("add app runtime");
+
+    let defaults = StdioServerConfig {
+        binary: server_path.clone(),
+        code_home: Some(code_home.clone()),
+        current_dir: None,
+        env: vec![(
+            OsString::from("APP_RUNTIME_LIFECYCLE"),
+            OsString::from("default"),
+        )],
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(3),
+    };
+
+    let before = fs::read_to_string(manager.config_path()).expect("read config before");
+    let api = AppRuntimeApi::from_config(&manager, &defaults).expect("build api");
+    let client = test_client();
+
+    let runtime = api
+        .start("lifecycle", client.clone())
+        .await
+        .expect("start runtime");
+    assert_eq!(runtime.name, "lifecycle");
+    assert_eq!(runtime.metadata, metadata);
+
+    let env_values: HashMap<OsString, OsString> = runtime.config.env.iter().cloned().collect();
+    assert_eq!(
+        env_values.get(&OsString::from("CODEX_HOME")),
+        Some(&code_home.as_os_str().to_os_string())
+    );
+    assert_eq!(
+        env_values.get(&OsString::from("APP_RUNTIME_LIFECYCLE")),
+        Some(&OsString::from("runtime-env"))
+    );
+
+    let thread = runtime
+        .server
+        .thread_start(ThreadStartParams {
+            thread_id: None,
+            metadata: serde_json::json!({"from": "lifecycle"}),
+        })
+        .await
+        .expect("thread start");
+    let thread_response = time::timeout(Duration::from_secs(2), thread.response)
+        .await
+        .expect("thread response timeout")
+        .expect("recv thread response")
+        .expect("thread response ok");
+    let thread_id = thread_response
+        .get("thread_id")
+        .and_then(Value::as_str)
+        .unwrap_or_default()
+        .to_string();
+    assert!(!thread_id.is_empty());
+
+    runtime.stop().await.expect("shutdown runtime");
+
+    let after = fs::read_to_string(manager.config_path()).expect("read config after");
+    assert_eq!(before, after);
+
+    let prepared = api.prepare("lifecycle").expect("prepare after stop");
+    assert_eq!(prepared.metadata, metadata);
+}
+
+#[tokio::test]
+async fn app_runtime_api_not_found_errors() {
+    let api = AppRuntimeApi::new(Vec::new());
+    match api.prepare("missing") {
+        Err(AppRuntimeError::NotFound(name)) => assert_eq!(name, "missing"),
+        other => panic!("unexpected result: {other:?}"),
+    }
+
+    let client = test_client();
+    match api.start("missing", client).await {
+        Err(AppRuntimeError::NotFound(name)) => assert_eq!(name, "missing"),
+        other => panic!("unexpected start result: {other:?}"),
+    }
+}
diff --git a/crates/codex/src/mcp/tests_runtime_app/app_runtime_pool_api.rs b/crates/codex/src/mcp/tests_runtime_app/app_runtime_pool_api.rs
new file mode 100644
index 0000000..c22154d
--- /dev/null
+++ b/crates/codex/src/mcp/tests_runtime_app/app_runtime_pool_api.rs
@@ -0,0 +1,293 @@
+use super::super::test_support::{prelude::*, *};
+use super::super::*;
+
+#[tokio::test]
+async fn app_runtime_pool_api_reuses_and_restarts_stdio() {
+    let (config_dir, manager) = temp_config_manager();
+    let (_server_dir, server_path) = write_fake_app_server();
+    let code_home = config_dir.path().join("app-pool-home");
+
+    let mut env_map = BTreeMap::new();
+    env_map.insert("APP_POOL_ENV".into(), "runtime".into());
+
+    let metadata = serde_json::json!({"resume_thread": "thread-pool"});
+    manager
+        .add_app_runtime(AddAppRuntimeRequest {
+            name: "pooled".into(),
+            definition: AppRuntimeDefinition {
+                description: Some("pooled app".into()),
+                tags: vec!["pool".into()],
+                env: env_map,
+                code_home: None,
+                current_dir: None,
+                mirror_stdio: Some(true),
+                startup_timeout_ms: Some(2000),
+                binary: None,
+                metadata: metadata.clone(),
+            },
+            overwrite: false,
+        })
+        .expect("add app runtime");
+
+    let defaults = StdioServerConfig {
+        binary: server_path.clone(),
+        code_home: Some(code_home.clone()),
+        current_dir: None,
+        env: vec![
+            (OsString::from("APP_POOL_ENV"), OsString::from("default")),
+            (OsString::from("POOL_ONLY"), OsString::from("base")),
+        ],
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(3),
+    };
+
+    let before = fs::read_to_string(manager.config_path()).expect("read config before");
+    let api = AppRuntimePoolApi::from_config(&manager, &defaults).expect("build pool api");
+    let client = test_client();
+
+    let available = api.available();
+    assert_eq!(available.len(), 1);
+    let pooled_summary = &available[0];
+    assert_eq!(pooled_summary.name, "pooled");
+    assert_eq!(pooled_summary.metadata, metadata);
+
+    let launcher = api.launcher("pooled").expect("pooled launcher");
+    assert_eq!(launcher.description.as_deref(), Some("pooled app"));
+    assert_eq!(launcher.metadata, metadata);
+
+    let launcher_config = launcher.config.clone();
+    assert_eq!(launcher_config.binary, server_path);
+    assert_eq!(
+        launcher_config.code_home.as_deref(),
+        Some(code_home.as_path())
+    );
+    assert_eq!(launcher_config.startup_timeout, Duration::from_secs(2));
+
+    let launcher_env: HashMap<OsString, OsString> = launcher_config.env.into_iter().collect();
+    assert_eq!(
+        launcher_env.get(&OsString::from("CODEX_HOME")),
+        Some(&code_home.as_os_str().to_os_string())
+    );
+    assert_eq!(
+        launcher_env.get(&OsString::from("POOL_ONLY")),
+        Some(&OsString::from("base"))
+    );
+    assert_eq!(
+        launcher_env.get(&OsString::from("APP_POOL_ENV")),
+        Some(&OsString::from("runtime"))
+    );
+
+    let stdio_config = api
+        .stdio_config("pooled")
+        .expect("pooled stdio config without starting");
+    assert_eq!(stdio_config.binary, server_path);
+    assert_eq!(stdio_config.code_home.as_deref(), Some(code_home.as_path()));
+    let stdio_env: HashMap<OsString, OsString> = stdio_config.env.into_iter().collect();
+    assert_eq!(
+        stdio_env.get(&OsString::from("POOL_ONLY")),
+        Some(&OsString::from("base"))
+    );
+    assert_eq!(
+        stdio_env.get(&OsString::from("CODEX_HOME")),
+        Some(&code_home.as_os_str().to_os_string())
+    );
+    assert_eq!(
+        stdio_env.get(&OsString::from("APP_POOL_ENV")),
+        Some(&OsString::from("runtime"))
+    );
+
+    assert!(api.running().await.is_empty());
+
+    let runtime = api
+        .start("pooled", client.clone())
+        .await
+        .expect("start pooled runtime");
+    assert_eq!(runtime.name, "pooled");
+    assert_eq!(runtime.metadata, metadata);
+
+    let env_values: HashMap<OsString, OsString> = runtime.config.env.iter().cloned().collect();
+    assert_eq!(
+        env_values.get(&OsString::from("CODEX_HOME")),
+        Some(&code_home.as_os_str().to_os_string())
+    );
+    assert_eq!(
+        env_values.get(&OsString::from("POOL_ONLY")),
+        Some(&OsString::from("base"))
+    );
+    assert_eq!(
+        env_values.get(&OsString::from("APP_POOL_ENV")),
+        Some(&OsString::from("runtime"))
+    );
+
+    let thread = runtime
+        .server
+        .thread_start(ThreadStartParams {
+            thread_id: None,
+            metadata: serde_json::json!({"from": "pool"}),
+        })
+        .await
+        .expect("thread start");
+    let response = time::timeout(Duration::from_secs(2), thread.response)
+        .await
+        .expect("thread response timeout")
+        .expect("recv thread response")
+        .expect("thread response ok");
+    let thread_id = response
+        .get("thread_id")
+        .and_then(Value::as_str)
+        .unwrap_or_default()
+        .to_string();
+    assert!(!thread_id.is_empty());
+
+    let running = api.running().await;
+    let running_summary = running
+        .iter()
+        .find(|summary| summary.name == "pooled")
+        .expect("running summary present");
+    assert_eq!(running_summary.metadata, metadata);
+
+    let reused = api
+        .start("pooled", client.clone())
+        .await
+        .expect("reuse pooled runtime");
+    assert!(Arc::ptr_eq(&runtime, &reused));
+
+    api.stop("pooled").await.expect("stop pooled runtime");
+    match api.stop("pooled").await {
+        Err(AppRuntimeError::NotFound(name)) => assert_eq!(name, "pooled"),
+        other => panic!("expected not found on second stop, got {other:?}"),
+    }
+
+    assert!(api.running().await.is_empty());
+
+    let restarted = api
+        .start("pooled", client)
+        .await
+        .expect("restart pooled runtime");
+    assert!(!Arc::ptr_eq(&runtime, &restarted));
+    assert_eq!(restarted.metadata, metadata);
+
+    let prepared = api.prepare("pooled").expect("prepare after restart");
+    assert_eq!(prepared.metadata, metadata);
+
+    let after = fs::read_to_string(manager.config_path()).expect("read config after");
+    assert_eq!(before, after);
+}
+
+#[tokio::test]
+async fn app_runtime_pool_api_stop_all_shuts_down_runtimes() {
+    let (config_dir, manager) = temp_config_manager();
+    let (_server_dir, server_path) = write_fake_app_server();
+    let code_home = config_dir.path().join("app-pool-stop-home");
+
+    let alpha_metadata = serde_json::json!({"resume_thread": "alpha"});
+    manager
+        .add_app_runtime(AddAppRuntimeRequest {
+            name: "alpha".into(),
+            definition: AppRuntimeDefinition {
+                description: Some("alpha runtime".into()),
+                tags: vec!["pool".into()],
+                env: BTreeMap::new(),
+                code_home: None,
+                current_dir: None,
+                mirror_stdio: Some(false),
+                startup_timeout_ms: Some(2000),
+                binary: None,
+                metadata: alpha_metadata.clone(),
+            },
+            overwrite: false,
+        })
+        .expect("add alpha runtime");
+
+    let beta_metadata = serde_json::json!({"resume_thread": "beta"});
+    manager
+        .add_app_runtime(AddAppRuntimeRequest {
+            name: "beta".into(),
+            definition: AppRuntimeDefinition {
+                description: Some("beta runtime".into()),
+                tags: vec!["pool".into()],
+                env: BTreeMap::new(),
+                code_home: None,
+                current_dir: None,
+                mirror_stdio: Some(false),
+                startup_timeout_ms: Some(2000),
+                binary: None,
+                metadata: beta_metadata.clone(),
+            },
+            overwrite: false,
+        })
+        .expect("add beta runtime");
+
+    let defaults = StdioServerConfig {
+        binary: server_path.clone(),
+        code_home: Some(code_home.clone()),
+        current_dir: None,
+        env: Vec::new(),
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(3),
+    };
+
+    let before = fs::read_to_string(manager.config_path()).expect("read config before");
+    let api = AppRuntimePoolApi::from_config(&manager, &defaults).expect("build pool api");
+    let client = test_client();
+
+    assert!(api.running().await.is_empty());
+
+    let alpha = api
+        .start("alpha", client.clone())
+        .await
+        .expect("start alpha runtime");
+    let beta = api
+        .start("beta", client.clone())
+        .await
+        .expect("start beta runtime");
+
+    assert_eq!(alpha.metadata, alpha_metadata);
+    assert_eq!(beta.metadata, beta_metadata);
+
+    let mut running = api.running().await;
+    running.sort_by(|a, b| a.name.cmp(&b.name));
+    assert_eq!(running.len(), 2);
+    assert_eq!(running[0].name, "alpha");
+    assert_eq!(running[0].metadata, alpha_metadata);
+    assert_eq!(running[1].name, "beta");
+    assert_eq!(running[1].metadata, beta_metadata);
+
+    let alpha_thread = alpha
+        .server
+        .thread_start(ThreadStartParams {
+            thread_id: None,
+            metadata: serde_json::json!({"from": "alpha"}),
+        })
+        .await
+        .expect("alpha thread start");
+    let _ = time::timeout(Duration::from_secs(2), alpha_thread.response)
+        .await
+        .expect("alpha thread response timeout")
+        .expect("alpha response recv")
+        .expect("alpha ok");
+
+    api.stop_all().await.expect("stop all runtimes");
+    assert!(api.running().await.is_empty());
+
+    let restarted_alpha = api
+        .start("alpha", client.clone())
+        .await
+        .expect("restart alpha");
+    assert!(!Arc::ptr_eq(&alpha, &restarted_alpha));
+    assert_eq!(restarted_alpha.metadata, alpha_metadata);
+
+    let restarted_beta = api.start("beta", client).await.expect("restart beta");
+    assert!(!Arc::ptr_eq(&beta, &restarted_beta));
+    assert_eq!(restarted_beta.metadata, beta_metadata);
+
+    let prepared_alpha = api.prepare("alpha").expect("prepare alpha");
+    assert_eq!(prepared_alpha.metadata, alpha_metadata);
+    let prepared_beta = api.prepare("beta").expect("prepare beta");
+    assert_eq!(prepared_beta.metadata, beta_metadata);
+
+    let after = fs::read_to_string(manager.config_path()).expect("read config after");
+    assert_eq!(before, after);
+}
diff --git a/crates/codex/src/mcp/tests_runtime_app/runtime_api.rs b/crates/codex/src/mcp/tests_runtime_app/runtime_api.rs
new file mode 100644
index 0000000..e4a425d
--- /dev/null
+++ b/crates/codex/src/mcp/tests_runtime_app/runtime_api.rs
@@ -0,0 +1,241 @@
+use super::super::test_support::{prelude::*, *};
+use super::super::*;
+
+#[test]
+fn runtime_api_lists_launchers_without_changing_config() {
+    let (dir, manager) = temp_config_manager();
+    let stdio_env_key = "MCP_RUNTIME_API_STDIO_ENV";
+    let request_env_key = "MCP_RUNTIME_API_REQUEST_ENV";
+    let http_env_key = "MCP_RUNTIME_API_HTTP_ENV";
+    env::set_var(http_env_key, "token-api");
+
+    let mut stdio = stdio_definition("runtime-api-stdio");
+    stdio.description = Some("stdio runtime".into());
+    stdio.tags = vec!["local".into()];
+    stdio.tools = Some(McpToolConfig {
+        enabled: vec!["fmt".into()],
+        disabled: vec!["lint".into()],
+    });
+    if let McpTransport::Stdio(ref mut stdio_def) = stdio.transport {
+        stdio_def.args.push("--flag".into());
+        stdio_def
+            .env
+            .insert(stdio_env_key.into(), "runtime-env".into());
+        stdio_def.timeout_ms = Some(2400);
+    }
+
+    let mut env_map = BTreeMap::new();
+    env_map.insert(request_env_key.to_string(), "injected".to_string());
+
+    manager
+        .add_server(AddServerRequest {
+            name: "local-api".into(),
+            definition: stdio,
+            overwrite: false,
+            env: env_map,
+            bearer_token: None,
+        })
+        .expect("add stdio server");
+
+    let mut http = streamable_definition("https://example.test/runtime-api", http_env_key);
+    http.description = Some("http runtime".into());
+    http.tags = vec!["remote".into()];
+    http.tools = Some(McpToolConfig {
+        enabled: vec!["alpha".into()],
+        disabled: vec!["beta".into()],
+    });
+    if let McpTransport::StreamableHttp(ref mut http_def) = http.transport {
+        http_def.headers.insert("X-Req".into(), "true".into());
+        http_def.request_timeout_ms = Some(2200);
+    }
+
+    manager
+        .add_server(AddServerRequest {
+            name: "remote-api".into(),
+            definition: http,
+            overwrite: false,
+            env: BTreeMap::new(),
+            bearer_token: None,
+        })
+        .expect("add http server");
+
+    let before = fs::read_to_string(manager.config_path()).expect("read config before");
+    let cwd = dir.path().join("cwd");
+
+    let defaults = StdioServerConfig {
+        binary: PathBuf::from("codex"),
+        code_home: Some(dir.path().to_path_buf()),
+        current_dir: Some(cwd.clone()),
+        env: vec![
+            (OsString::from("DEFAULT_ONLY"), OsString::from("default")),
+            (
+                OsString::from(request_env_key),
+                OsString::from("base-default"),
+            ),
+        ],
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: true,
+        startup_timeout: Duration::from_secs(3),
+    };
+
+    let api = McpRuntimeApi::from_config(&manager, &defaults).expect("runtime api");
+
+    let available = api.available();
+    assert_eq!(available.len(), 2);
+
+    let stdio_summary = available
+        .iter()
+        .find(|entry| entry.name == "local-api")
+        .expect("stdio summary");
+    assert_eq!(stdio_summary.transport, McpRuntimeSummaryTransport::Stdio);
+    let stdio_tools = stdio_summary.tools.as_ref().expect("stdio tools");
+    assert_eq!(stdio_tools.enabled, vec!["fmt".to_string()]);
+    assert_eq!(stdio_tools.disabled, vec!["lint".to_string()]);
+
+    let stdio_launcher = api.stdio_launcher("local-api").expect("stdio launcher");
+    assert_eq!(stdio_launcher.args, vec!["--flag".to_string()]);
+    assert_eq!(stdio_launcher.timeout, Duration::from_millis(2400));
+    assert!(stdio_launcher.mirror_stdio);
+    assert_eq!(stdio_launcher.current_dir.as_deref(), Some(cwd.as_path()));
+
+    let env_map: HashMap<OsString, OsString> = stdio_launcher.env.into_iter().collect();
+    assert_eq!(
+        env_map.get(&OsString::from("CODEX_HOME")),
+        Some(&dir.path().as_os_str().to_os_string())
+    );
+    assert_eq!(
+        env_map.get(&OsString::from("DEFAULT_ONLY")),
+        Some(&OsString::from("default"))
+    );
+    assert_eq!(
+        env_map.get(&OsString::from(request_env_key)),
+        Some(&OsString::from("injected"))
+    );
+    assert_eq!(
+        env_map.get(&OsString::from(stdio_env_key)),
+        Some(&OsString::from("runtime-env"))
+    );
+
+    let http_connector = api.http_connector("remote-api").expect("http connector");
+    assert_eq!(http_connector.bearer_token.as_deref(), Some("token-api"));
+    assert_eq!(
+        http_connector
+            .headers
+            .get("Authorization")
+            .map(String::as_str),
+        Some("Bearer token-api")
+    );
+    assert_eq!(
+        http_connector.headers.get("X-Req").map(String::as_str),
+        Some("true")
+    );
+    assert_eq!(
+        http_connector.request_timeout,
+        Some(Duration::from_millis(2200))
+    );
+
+    let http_tools = available
+        .iter()
+        .find(|entry| entry.name == "remote-api")
+        .and_then(|entry| entry.tools.as_ref())
+        .expect("http tools");
+    assert_eq!(http_tools.enabled, vec!["alpha".to_string()]);
+    assert_eq!(http_tools.disabled, vec!["beta".to_string()]);
+
+    match api.stdio_launcher("remote-api") {
+        Err(McpRuntimeError::UnsupportedTransport {
+            name,
+            expected,
+            actual,
+        }) => {
+            assert_eq!(name, "remote-api");
+            assert_eq!(expected, "stdio");
+            assert_eq!(actual, "streamable_http");
+        }
+        other => panic!("unexpected result: {other:?}"),
+    }
+
+    match api.http_connector("local-api") {
+        Err(McpRuntimeError::UnsupportedTransport {
+            name,
+            expected,
+            actual,
+        }) => {
+            assert_eq!(name, "local-api");
+            assert_eq!(expected, "streamable_http");
+            assert_eq!(actual, "stdio");
+        }
+        other => panic!("unexpected http result: {other:?}"),
+    }
+
+    let after = fs::read_to_string(manager.config_path()).expect("read config after");
+    assert_eq!(before, after);
+
+    env::remove_var(http_env_key);
+    env::remove_var(request_env_key);
+}
+
+#[test]
+fn runtime_api_prepare_http_is_non_destructive() {
+    let (dir, manager) = temp_config_manager();
+    let env_var = "MCP_RUNTIME_API_PREPARE";
+    env::set_var(env_var, "prepare-token");
+
+    let mut http = streamable_definition("https://example.test/prepare", env_var);
+    http.tags = vec!["prepare".into()];
+    http.tools = Some(McpToolConfig {
+        enabled: vec!["delta".into()],
+        disabled: vec![],
+    });
+
+    manager
+        .add_server(AddServerRequest {
+            name: "prepare-http".into(),
+            definition: http,
+            overwrite: false,
+            env: BTreeMap::new(),
+            bearer_token: None,
+        })
+        .expect("add http server");
+
+    let before = fs::read_to_string(manager.config_path()).expect("read config before");
+
+    let defaults = StdioServerConfig {
+        binary: PathBuf::from("codex"),
+        code_home: Some(dir.path().to_path_buf()),
+        current_dir: None,
+        env: Vec::new(),
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(2),
+    };
+
+    let api = McpRuntimeApi::from_config(&manager, &defaults).expect("runtime api");
+    let handle = api.prepare("prepare-http").expect("prepare http");
+
+    match handle {
+        McpRuntimeHandle::StreamableHttp(http_handle) => {
+            assert_eq!(http_handle.name, "prepare-http");
+            assert_eq!(
+                http_handle.connector.bearer_token.as_deref(),
+                Some("prepare-token")
+            );
+            assert_eq!(
+                http_handle
+                    .connector
+                    .headers
+                    .get("Authorization")
+                    .map(String::as_str),
+                Some("Bearer prepare-token")
+            );
+            let tools = http_handle.tools.expect("tool hints");
+            assert_eq!(tools.enabled, vec!["delta".to_string()]);
+        }
+        other => panic!("expected http handle, got {other:?}"),
+    }
+
+    let after = fs::read_to_string(manager.config_path()).expect("read config after");
+    assert_eq!(before, after);
+
+    env::remove_var(env_var);
+}
diff --git a/crates/codex/src/mcp/tests_runtime_app/runtime_manager.rs b/crates/codex/src/mcp/tests_runtime_app/runtime_manager.rs
new file mode 100644
index 0000000..2278cb0
--- /dev/null
+++ b/crates/codex/src/mcp/tests_runtime_app/runtime_manager.rs
@@ -0,0 +1,193 @@
+use super::super::test_support::{prelude::*, *};
+use super::super::*;
+
+#[tokio::test]
+async fn runtime_manager_starts_and_stops_stdio() {
+    let (_dir, script) = write_env_probe_server("MCP_RUNTIME_ENV_E8");
+    let code_home = tempfile::tempdir().expect("code_home");
+
+    let defaults = StdioServerConfig {
+        binary: PathBuf::from("codex"),
+        code_home: Some(code_home.path().to_path_buf()),
+        current_dir: None,
+        env: vec![(
+            OsString::from("MCP_RUNTIME_ENV_E8"),
+            OsString::from("manager-ok"),
+        )],
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(5),
+    };
+
+    let runtime = McpRuntimeServer {
+        name: "env-probe".into(),
+        transport: McpRuntimeTransport::Stdio(StdioServerDefinition {
+            command: script.to_string_lossy().to_string(),
+            args: Vec::new(),
+            env: BTreeMap::new(),
+            timeout_ms: Some(1500),
+        }),
+        description: None,
+        tags: vec!["local".into()],
+        tools: Some(McpToolConfig {
+            enabled: vec!["tool-x".into()],
+            disabled: vec![],
+        }),
+    };
+
+    let launcher = runtime.into_launcher(&defaults);
+    let manager = McpRuntimeManager::new(vec![launcher]);
+
+    let mut handle = match manager.prepare("env-probe").expect("prepare stdio") {
+        McpRuntimeHandle::Stdio(handle) => handle,
+        other => panic!("expected stdio handle, got {other:?}"),
+    };
+
+    let mut reader = BufReader::new(handle.stdout_mut());
+    let mut line = String::new();
+    let _ = time::timeout(Duration::from_secs(2), reader.read_line(&mut line))
+        .await
+        .expect("read timeout")
+        .expect("read env line");
+    assert_eq!(line.trim(), "manager-ok");
+
+    let tools = handle.tools().expect("tool hints");
+    assert_eq!(tools.enabled, vec!["tool-x".to_string()]);
+
+    handle.stop().await.expect("stop server");
+}
+
+#[test]
+fn runtime_manager_propagates_tool_hints_for_http() {
+    let env_var = "MCP_HTTP_TOKEN_E8_HINTS";
+    env::set_var(env_var, "token-hints");
+
+    let mut http = StreamableHttpDefinition {
+        url: "https://example.test/hints".into(),
+        headers: BTreeMap::new(),
+        bearer_env_var: Some(env_var.to_string()),
+        connect_timeout_ms: Some(1200),
+        request_timeout_ms: Some(2400),
+    };
+    http.headers.insert("X-Test".into(), "true".into());
+
+    let runtime = McpRuntimeServer::from_definition(
+        "remote-http",
+        McpServerDefinition {
+            transport: McpTransport::StreamableHttp(http),
+            description: Some("http runtime".into()),
+            tags: vec!["http".into()],
+            tools: Some(McpToolConfig {
+                enabled: vec!["alpha".into()],
+                disabled: vec!["beta".into()],
+            }),
+        },
+    );
+
+    let defaults = StdioServerConfig {
+        binary: PathBuf::from("codex"),
+        code_home: None,
+        current_dir: None,
+        env: Vec::new(),
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(2),
+    };
+
+    let launcher = runtime.into_launcher(&defaults);
+    let manager = McpRuntimeManager::new(vec![launcher]);
+
+    let available = manager.available();
+    assert_eq!(available.len(), 1);
+    let summary = &available[0];
+    assert_eq!(summary.name, "remote-http");
+    assert_eq!(
+        summary.transport,
+        McpRuntimeSummaryTransport::StreamableHttp
+    );
+    let summary_tools = summary.tools.as_ref().expect("tool hints present");
+    assert_eq!(summary_tools.enabled, vec!["alpha".to_string()]);
+    assert_eq!(summary_tools.disabled, vec!["beta".to_string()]);
+
+    match manager.prepare("remote-http").expect("prepare http") {
+        McpRuntimeHandle::StreamableHttp(http_handle) => {
+            let tools = http_handle.tools.as_ref().expect("tool hints on handle");
+            assert_eq!(tools.enabled, vec!["alpha".to_string()]);
+            assert_eq!(tools.disabled, vec!["beta".to_string()]);
+            assert_eq!(
+                http_handle.connector.bearer_token.as_deref(),
+                Some("token-hints")
+            );
+        }
+        other => panic!("expected http handle, got {other:?}"),
+    }
+
+    env::remove_var(env_var);
+}
+
+#[test]
+fn http_connector_retrieval_is_non_destructive() {
+    let env_var = "MCP_HTTP_TOKEN_E8_REUSE";
+    env::set_var(env_var, "token-reuse");
+
+    let runtime = McpRuntimeServer::from_definition(
+        "remote-reuse",
+        McpServerDefinition {
+            transport: McpTransport::StreamableHttp(StreamableHttpDefinition {
+                url: "https://example.test/reuse".into(),
+                headers: BTreeMap::new(),
+                bearer_env_var: Some(env_var.to_string()),
+                connect_timeout_ms: Some(1500),
+                request_timeout_ms: Some(3200),
+            }),
+            description: None,
+            tags: vec!["http".into()],
+            tools: Some(McpToolConfig {
+                enabled: vec!["one".into()],
+                disabled: vec![],
+            }),
+        },
+    );
+
+    let defaults = StdioServerConfig {
+        binary: PathBuf::from("codex"),
+        code_home: None,
+        current_dir: None,
+        env: Vec::new(),
+        app_server_analytics_default_enabled: false,
+        mirror_stdio: false,
+        startup_timeout: Duration::from_secs(2),
+    };
+
+    let launcher = runtime.into_launcher(&defaults);
+    let manager = McpRuntimeManager::new(vec![launcher]);
+
+    let first = manager.prepare("remote-reuse").expect("first prepare");
+    let second = manager.prepare("remote-reuse").expect("second prepare");
+
+    let first_token = match first {
+        McpRuntimeHandle::StreamableHttp(handle) => handle.connector.bearer_token,
+        other => panic!("expected http handle, got {other:?}"),
+    };
+    let second_token = match second {
+        McpRuntimeHandle::StreamableHttp(handle) => handle.connector.bearer_token,
+        other => panic!("expected http handle, got {other:?}"),
+    };
+
+    assert_eq!(first_token.as_deref(), Some("token-reuse"));
+    assert_eq!(second_token.as_deref(), Some("token-reuse"));
+
+    let summary = manager
+        .available()
+        .into_iter()
+        .find(|s| s.name == "remote-reuse")
+        .expect("summary present");
+    assert_eq!(
+        summary.transport,
+        McpRuntimeSummaryTransport::StreamableHttp
+    );
+    let tools = summary.tools.as_ref().expect("tool hints preserved");
+    assert_eq!(tools.enabled, vec!["one".to_string()]);
+
+    env::remove_var(env_var);
+}
diff --git a/crates/codex/src/tests.rs b/crates/codex/src/tests.rs
index e968684..75e3e29 100644
--- a/crates/codex/src/tests.rs
+++ b/crates/codex/src/tests.rs
@@ -1,3555 +1,4 @@
-use super::*;
-use crate::auth::parse_login_success;
-use crate::builder::ResolvedCliOverrides;
-use crate::defaults::{
-    default_binary_path, default_rust_log_value, CODEX_BINARY_ENV, CODEX_HOME_ENV,
-    DEFAULT_RUST_LOG, DEFAULT_TIMEOUT, RUST_LOG_ENV,
-};
-use futures_util::{pin_mut, StreamExt};
-use semver::Version;
-use serde_json::json;
-use std::collections::HashMap;
-use std::env;
-use std::fs as std_fs;
-#[cfg(unix)]
-use std::os::unix::fs::PermissionsExt;
-use std::sync::OnceLock;
-use std::time::{Duration, SystemTime};
-use tokio::{
-    fs,
-    io::{AsyncBufReadExt, AsyncWriteExt, BufReader},
-};
+pub(super) use super::*;
 
-fn env_mutex() -> &'static tokio::sync::Mutex<()> {
-    static ENV_MUTEX: OnceLock<tokio::sync::Mutex<()>> = OnceLock::new();
-    ENV_MUTEX.get_or_init(|| tokio::sync::Mutex::new(()))
-}
-
-fn env_guard() -> tokio::sync::MutexGuard<'static, ()> {
-    env_mutex().blocking_lock()
-}
-
-async fn env_guard_async() -> tokio::sync::MutexGuard<'static, ()> {
-    env_mutex().lock().await
-}
-
-#[tokio::test]
-async fn json_stream_preserves_order_and_parses_tool_calls() {
-    let lines = [
-        r#"{"type":"thread.started","thread_id":"thread-1"}"#.to_string(),
-        serde_json::to_string(&json!({
-            "type": "item.started",
-            "thread_id": "thread-1",
-            "turn_id": "turn-1",
-            "item_id": "item-1",
-            "item_type": "mcp_tool_call",
-            "content": {
-                "server_name": "files",
-                "tool_name": "list",
-                "status": "running"
-            }
-        }))
-        .unwrap(),
-        serde_json::to_string(&json!({
-            "type": "item.delta",
-            "thread_id": "thread-1",
-            "turn_id": "turn-1",
-            "item_id": "item-1",
-            "item_type": "mcp_tool_call",
-            "delta": {
-                "result": {"paths": ["foo.rs"]},
-                "status": "completed"
-            }
-        }))
-        .unwrap(),
-    ];
-
-    let (mut writer, reader) = tokio::io::duplex(4096);
-    let (tx, rx) = mpsc::channel(8);
-    let forward_handle = tokio::spawn(crate::jsonl::forward_json_events(reader, tx, false, None));
-
-    for line in &lines {
-        writer.write_all(line.as_bytes()).await.unwrap();
-        writer.write_all(b"\n").await.unwrap();
-    }
-    writer.shutdown().await.unwrap();
-
-    let stream = crate::jsonl::EventChannelStream::new(rx, None);
-    pin_mut!(stream);
-    let events: Vec<_> = stream.collect().await;
-    forward_handle.await.unwrap().unwrap();
-
-    assert_eq!(events.len(), lines.len(), "events: {events:?}");
-
-    match &events[0] {
-        Ok(ThreadEvent::ThreadStarted(event)) => {
-            assert_eq!(event.thread_id, "thread-1");
-        }
-        other => panic!("unexpected first event: {other:?}"),
-    }
-
-    match &events[1] {
-        Ok(ThreadEvent::ItemStarted(envelope)) => {
-            assert_eq!(envelope.thread_id, "thread-1");
-            assert_eq!(envelope.turn_id, "turn-1");
-            match &envelope.item.payload {
-                ItemPayload::McpToolCall(state) => {
-                    assert_eq!(state.server_name, "files");
-                    assert_eq!(state.tool_name, "list");
-                    assert_eq!(state.status, ToolCallStatus::Running);
-                }
-                other => panic!("unexpected payload: {other:?}"),
-            }
-        }
-        other => panic!("unexpected second event: {other:?}"),
-    }
-
-    match &events[2] {
-        Ok(ThreadEvent::ItemDelta(delta)) => {
-            assert_eq!(delta.item_id, "item-1");
-            match &delta.delta {
-                ItemDeltaPayload::McpToolCall(call_delta) => {
-                    assert_eq!(call_delta.status, ToolCallStatus::Completed);
-                    let result = call_delta
-                        .result
-                        .as_ref()
-                        .expect("tool call delta result is captured");
-                    assert_eq!(result["paths"][0], "foo.rs");
-                }
-                other => panic!("unexpected delta payload: {other:?}"),
-            }
-        }
-        other => panic!("unexpected third event: {other:?}"),
-    }
-}
-
-#[tokio::test]
-async fn json_stream_propagates_parse_errors() {
-    let (mut writer, reader) = tokio::io::duplex(1024);
-    let (tx, rx) = mpsc::channel(4);
-    let forward_handle = tokio::spawn(crate::jsonl::forward_json_events(reader, tx, false, None));
-
-    writer
-        .write_all(br#"{"type":"thread.started","thread_id":"thread-err"}"#)
-        .await
-        .unwrap();
-    writer.write_all(b"\nthis is not json\n").await.unwrap();
-    writer.shutdown().await.unwrap();
-
-    let stream = crate::jsonl::EventChannelStream::new(rx, None);
-    pin_mut!(stream);
-    let events: Vec<_> = stream.collect().await;
-    forward_handle.await.unwrap().unwrap();
-
-    assert_eq!(events.len(), 2);
-    assert!(matches!(
-        events[0],
-        Ok(ThreadEvent::ThreadStarted(ThreadStarted { ref thread_id, .. }))
-            if thread_id == "thread-err"
-    ));
-    match &events[1] {
-        Err(ExecStreamError::Parse { line, .. }) => assert_eq!(line, "this is not json"),
-        other => panic!("expected parse error, got {other:?}"),
-    }
-}
-
-#[tokio::test]
-async fn json_stream_tees_logs_before_forwarding() {
-    let lines = [
-        r#"{"type":"thread.started","thread_id":"tee-thread"}"#.to_string(),
-        r#"{"type":"turn.started","thread_id":"tee-thread","turn_id":"turn-tee"}"#.to_string(),
-    ];
-
-    let dir = tempfile::tempdir().unwrap();
-    let log_path = dir.path().join("events.log");
-
-    let (mut writer, reader) = tokio::io::duplex(2048);
-    let (tx, rx) = mpsc::channel(4);
-    let log_sink = crate::jsonl::JsonLogSink::new(log_path.clone())
-        .await
-        .unwrap();
-    let forward_handle = tokio::spawn(crate::jsonl::forward_json_events(
-        reader,
-        tx,
-        false,
-        Some(log_sink),
-    ));
-
-    let stream = crate::jsonl::EventChannelStream::new(rx, None);
-    pin_mut!(stream);
-
-    writer.write_all(lines[0].as_bytes()).await.unwrap();
-    writer.write_all(b"\n").await.unwrap();
-
-    let first = stream.next().await.unwrap().unwrap();
-    assert!(matches!(first, ThreadEvent::ThreadStarted(_)));
-
-    let logged = fs::read_to_string(&log_path).await.unwrap();
-    assert_eq!(logged, format!("{}\n", lines[0]));
-
-    writer.write_all(lines[1].as_bytes()).await.unwrap();
-    writer.write_all(b"\n").await.unwrap();
-    writer.shutdown().await.unwrap();
-
-    let second = stream.next().await.unwrap().unwrap();
-    assert!(matches!(second, ThreadEvent::TurnStarted(_)));
-    assert!(stream.next().await.is_none());
-
-    forward_handle.await.unwrap().unwrap();
-
-    let final_log = fs::read_to_string(&log_path).await.unwrap();
-    assert_eq!(final_log, format!("{}\n{}\n", lines[0], lines[1]));
-}
-
-#[tokio::test]
-async fn json_event_log_captures_apply_diff_and_tool_payloads() {
-    let diff = "@@ -1 +1 @@\n-fn foo() {}\n+fn bar() {}";
-    let lines = vec![
-        r#"{"type":"thread.started","thread_id":"log-thread"}"#.to_string(),
-        serde_json::to_string(&json!({
-            "type": "item.started",
-            "thread_id": "log-thread",
-            "turn_id": "turn-log",
-            "item_id": "apply-1",
-            "item_type": "file_change",
-            "content": {
-                "path": "src/main.rs",
-                "change": "apply",
-                "diff": diff,
-                "stdout": "patched\n"
-            }
-        }))
-        .unwrap(),
-        serde_json::to_string(&json!({
-            "type": "item.delta",
-            "thread_id": "log-thread",
-            "turn_id": "turn-log",
-            "item_id": "apply-1",
-            "item_type": "file_change",
-            "delta": {
-                "diff": diff,
-                "stderr": "warning",
-                "exit_code": 2
-            }
-        }))
-        .unwrap(),
-        serde_json::to_string(&json!({
-            "type": "item.delta",
-            "thread_id": "log-thread",
-            "turn_id": "turn-log",
-            "item_id": "tool-1",
-            "item_type": "mcp_tool_call",
-            "delta": {
-                "result": {"paths": ["a.rs", "b.rs"]},
-                "status": "completed"
-            }
-        }))
-        .unwrap(),
-    ];
-
-    let dir = tempfile::tempdir().unwrap();
-    let log_path = dir.path().join("json.log");
-
-    let (mut writer, reader) = tokio::io::duplex(4096);
-    let (tx, rx) = mpsc::channel(8);
-    let log_sink = crate::jsonl::JsonLogSink::new(log_path.clone())
-        .await
-        .unwrap();
-    let forward_handle = tokio::spawn(crate::jsonl::forward_json_events(
-        reader,
-        tx,
-        false,
-        Some(log_sink),
-    ));
-
-    for line in &lines {
-        writer.write_all(line.as_bytes()).await.unwrap();
-        writer.write_all(b"\n").await.unwrap();
-    }
-    writer.shutdown().await.unwrap();
-
-    let stream = crate::jsonl::EventChannelStream::new(rx, None);
-    pin_mut!(stream);
-    let events: Vec<_> = stream.collect().await;
-    forward_handle.await.unwrap().unwrap();
-
-    assert_eq!(events.len(), lines.len());
-
-    let log_contents = fs::read_to_string(&log_path).await.unwrap();
-    assert_eq!(log_contents, lines.join("\n") + "\n");
-}
-
-#[tokio::test]
-async fn event_channel_stream_times_out_when_idle() {
-    let (_tx, rx) = mpsc::channel(1);
-    let stream = crate::jsonl::EventChannelStream::new(rx, Some(Duration::from_millis(5)));
-    pin_mut!(stream);
-
-    let next = stream.next().await;
-    match next {
-        Some(Err(ExecStreamError::IdleTimeout { idle_for })) => {
-            assert_eq!(idle_for, Duration::from_millis(5));
-        }
-        other => panic!("expected idle timeout, got {other:?}"),
-    }
-}
-
-fn write_executable(dir: &Path, name: &str, script: &str) -> PathBuf {
-    let path = dir.join(name);
-    std_fs::write(&path, script).unwrap();
-    let mut perms = std_fs::metadata(&path).unwrap().permissions();
-    #[cfg(unix)]
-    {
-        perms.set_mode(0o755);
-    }
-    std_fs::set_permissions(&path, perms).unwrap();
-    path
-}
-
-fn write_fake_codex(dir: &Path, script: &str) -> PathBuf {
-    write_executable(dir, "codex", script)
-}
-
-fn write_fake_bundled_codex(dir: &Path, platform: &str, script: &str) -> PathBuf {
-    write_executable(dir, bundled_binary_filename(platform), script)
-}
-
-#[test]
-fn resolve_bundled_binary_defaults_to_runtime_platform() {
-    let temp = tempfile::tempdir().unwrap();
-    let platform = default_bundled_platform_label();
-    let version = "1.2.3";
-    let version_dir = temp.path().join(&platform).join(version);
-    std_fs::create_dir_all(&version_dir).unwrap();
-    let binary = write_fake_bundled_codex(&version_dir, &platform, "#!/usr/bin/env bash\necho ok");
-
-    let resolved = resolve_bundled_binary(BundledBinarySpec {
-        bundle_root: temp.path(),
-        version,
-        platform: None,
-    })
-    .unwrap();
-
-    assert_eq!(resolved.platform, platform);
-    assert_eq!(resolved.version, version);
-    assert_eq!(resolved.binary_path, std_fs::canonicalize(&binary).unwrap());
-}
-
-#[test]
-fn resolve_bundled_binary_honors_platform_override() {
-    let temp = tempfile::tempdir().unwrap();
-    let platform = "windows-x64";
-    let version = "5.6.7";
-    let version_dir = temp.path().join(platform).join(version);
-    std_fs::create_dir_all(&version_dir).unwrap();
-    let binary = write_fake_bundled_codex(&version_dir, platform, "#!/usr/bin/env bash\necho win");
-
-    let resolved = resolve_bundled_binary(BundledBinarySpec {
-        bundle_root: temp.path(),
-        version,
-        platform: Some(platform),
-    })
-    .unwrap();
-
-    assert_eq!(resolved.platform, platform);
-    assert_eq!(resolved.version, version);
-    assert_eq!(resolved.binary_path, std_fs::canonicalize(&binary).unwrap());
-    assert_eq!(
-        resolved
-            .binary_path
-            .file_name()
-            .and_then(|name| name.to_str()),
-        Some("codex.exe")
-    );
-}
-
-#[test]
-fn resolve_bundled_binary_errors_when_binary_missing() {
-    let temp = tempfile::tempdir().unwrap();
-    let platform = default_bundled_platform_label();
-    let version = "0.0.1";
-    let version_dir = temp.path().join(&platform).join(version);
-    std_fs::create_dir_all(&version_dir).unwrap();
-
-    let err = resolve_bundled_binary(BundledBinarySpec {
-        bundle_root: temp.path(),
-        version,
-        platform: None,
-    })
-    .unwrap_err();
-
-    match err {
-        BundledBinaryError::BinaryUnreadable { binary, .. }
-        | BundledBinaryError::BinaryNotFile { binary }
-        | BundledBinaryError::BinaryNotExecutable { binary } => {
-            assert_eq!(binary, version_dir.join(bundled_binary_filename(&platform)));
-        }
-        other => panic!("unexpected error: {other:?}"),
-    }
-}
-
-#[test]
-fn resolve_bundled_binary_rejects_empty_version() {
-    let temp = tempfile::tempdir().unwrap();
-    let err = resolve_bundled_binary(BundledBinarySpec {
-        bundle_root: temp.path(),
-        version: "  ",
-        platform: None,
-    })
-    .unwrap_err();
-    assert!(matches!(err, BundledBinaryError::EmptyVersion));
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn sandbox_maps_platform_flags_and_command() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-echo "$PWD"
-printf "%s\n" "$@"
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let request = SandboxCommandRequest::new(
-        SandboxPlatform::Linux,
-        [OsString::from("echo"), OsString::from("hello world")],
-    )
-    .full_auto(true)
-    .log_denials(true)
-    .config_override("foo", "bar")
-    .enable_feature("alpha")
-    .disable_feature("beta");
-
-    let run = client.run_sandbox(request).await.unwrap();
-    let mut lines = run.stdout.lines();
-    let pwd = lines.next().unwrap();
-    assert_eq!(Path::new(pwd), env::current_dir().unwrap().as_path());
-
-    let args: Vec<_> = lines.map(str::to_string).collect();
-    assert!(!args.contains(&"--log-denials".to_string()));
-    assert_eq!(
-        args,
-        vec![
-            "sandbox",
-            "linux",
-            "--full-auto",
-            "--config",
-            "foo=bar",
-            "--enable",
-            "alpha",
-            "--disable",
-            "beta",
-            "--",
-            "echo",
-            "hello world"
-        ]
-    );
-    assert!(run.status.success());
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn sandbox_includes_log_denials_on_macos() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-printf "%s\n" "$@"
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let run = client
-        .run_sandbox(SandboxCommandRequest::new(SandboxPlatform::Macos, ["ls"]).log_denials(true))
-        .await
-        .unwrap();
-    let args: Vec<_> = run.stdout.lines().collect();
-    assert!(args.contains(&"--log-denials"));
-    assert_eq!(args[0], "sandbox");
-    assert_eq!(args[1], "macos");
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn sandbox_honors_working_dir_precedence() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-echo "$PWD"
-"#,
-    );
-
-    let request_dir = dir.path().join("request_cwd");
-    let builder_dir = dir.path().join("builder_cwd");
-    std_fs::create_dir_all(&request_dir).unwrap();
-    std_fs::create_dir_all(&builder_dir).unwrap();
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .working_dir(&builder_dir)
-        .build();
-
-    let run_request = client
-        .run_sandbox(
-            SandboxCommandRequest::new(SandboxPlatform::Windows, ["echo", "cwd"])
-                .working_dir(&request_dir),
-        )
-        .await
-        .unwrap();
-    let request_pwd = run_request.stdout.lines().next().unwrap();
-    assert_eq!(Path::new(request_pwd), request_dir.as_path());
-
-    let run_builder = client
-        .run_sandbox(SandboxCommandRequest::new(
-            SandboxPlatform::Windows,
-            ["echo", "builder"],
-        ))
-        .await
-        .unwrap();
-    let builder_pwd = run_builder.stdout.lines().next().unwrap();
-    assert_eq!(Path::new(builder_pwd), builder_dir.as_path());
-
-    let client_default = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-    let run_default = client_default
-        .run_sandbox(SandboxCommandRequest::new(
-            SandboxPlatform::Windows,
-            ["echo", "default"],
-        ))
-        .await
-        .unwrap();
-    let default_pwd = run_default.stdout.lines().next().unwrap();
-    assert_eq!(
-        Path::new(default_pwd),
-        env::current_dir().unwrap().as_path()
-    );
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn sandbox_returns_non_zero_status_without_error() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-echo "failing"
-exit 7
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-    let run = client
-        .run_sandbox(SandboxCommandRequest::new(
-            SandboxPlatform::Linux,
-            ["false"],
-        ))
-        .await
-        .unwrap();
-
-    assert!(!run.status.success());
-    assert_eq!(run.status.code(), Some(7));
-    assert_eq!(run.stdout.trim(), "failing");
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn execpolicy_maps_policies_and_overrides() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = dir.path().join("codex-execpolicy");
-    std_fs::write(
-        &script_path,
-        r#"#!/usr/bin/env bash
-printf "%s\n" "$PWD" "$@" 1>&2
-cat <<'JSON'
-{"match":{"decision":"prompt","rules":[{"name":"rule1","decision":"forbidden"}]}}
-JSON
-"#,
-    )
-    .unwrap();
-    let mut perms = std_fs::metadata(&script_path).unwrap().permissions();
-    perms.set_mode(0o755);
-    std_fs::set_permissions(&script_path, perms).unwrap();
-
-    let workdir = dir.path().join("workdir");
-    std_fs::create_dir_all(&workdir).unwrap();
-    let policy_one = dir.path().join("policy_a.codexpolicy");
-    let policy_two = dir.path().join("policy_b.codexpolicy");
-    std_fs::write(&policy_one, "").unwrap();
-    std_fs::write(&policy_two, "").unwrap();
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .working_dir(&workdir)
-        .approval_policy(ApprovalPolicy::OnRequest)
-        .build();
-
-    let result = client
-        .check_execpolicy(
-            ExecPolicyCheckRequest::new([
-                OsString::from("bash"),
-                OsString::from("-lc"),
-                OsString::from("echo ok"),
-            ])
-            .policies([&policy_one, &policy_two])
-            .pretty(true)
-            .profile("dev")
-            .config_override("features.execpolicy", "true"),
-        )
-        .await
-        .unwrap();
-
-    assert_eq!(result.decision(), Some(ExecPolicyDecision::Prompt));
-    let match_result = result.evaluation.match_result.unwrap();
-    assert_eq!(match_result.rules.len(), 1);
-    assert_eq!(match_result.rules[0].name.as_deref(), Some("rule1"));
-    assert_eq!(
-        match_result.rules[0].decision,
-        Some(ExecPolicyDecision::Forbidden)
-    );
-
-    let mut lines = result.stderr.lines();
-    let pwd = lines.next().unwrap();
-    assert_eq!(Path::new(pwd), workdir.as_path());
-
-    let args: Vec<_> = lines.map(str::to_string).collect();
-    assert_eq!(
-        args,
-        vec![
-            "execpolicy",
-            "check",
-            "--policy",
-            policy_one.to_string_lossy().as_ref(),
-            "--policy",
-            policy_two.to_string_lossy().as_ref(),
-            "--pretty",
-            "--config",
-            "features.execpolicy=true",
-            "--profile",
-            "dev",
-            "--ask-for-approval",
-            "on-request",
-            "--",
-            "bash",
-            "-lc",
-            "echo ok"
-        ]
-    );
-}
-
-#[tokio::test]
-async fn execpolicy_rejects_empty_command() {
-    let client = CodexClient::builder().build();
-    let request = ExecPolicyCheckRequest::new(Vec::<OsString>::new());
-    let err = client.check_execpolicy(request).await.unwrap_err();
-    assert!(matches!(err, CodexError::EmptyExecPolicyCommand));
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn execpolicy_surfaces_parse_errors() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = dir.path().join("codex-execpolicy-bad");
-    std_fs::write(
-        &script_path,
-        r#"#!/usr/bin/env bash
-echo "not-json"
-"#,
-    )
-    .unwrap();
-    let mut perms = std_fs::metadata(&script_path).unwrap().permissions();
-    perms.set_mode(0o755);
-    std_fs::set_permissions(&script_path, perms).unwrap();
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let err = client
-        .check_execpolicy(
-            ExecPolicyCheckRequest::new([OsString::from("echo"), OsString::from("noop")])
-                .policy(dir.path().join("policy.codexpolicy")),
-        )
-        .await
-        .unwrap_err();
-
-    match err {
-        CodexError::ExecPolicyParse { stdout, .. } => assert!(stdout.contains("not-json")),
-        other => panic!("expected ExecPolicyParse, got {other:?}"),
-    }
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn features_list_maps_overrides_and_json_flag() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-echo "$PWD" 1>&2
-printf "%s\n" "$@" 1>&2
-cat <<'JSON'
-[{"name":"json-stream","stage":"stable","enabled":true},{"name":"cloud-exec","stage":"experimental","enabled":false}]
-JSON
-"#,
-    );
-
-    let workdir = dir.path().join("features-workdir");
-    std_fs::create_dir_all(&workdir).unwrap();
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .working_dir(&workdir)
-        .approval_policy(ApprovalPolicy::OnRequest)
-        .search(true)
-        .build();
-
-    let output = client
-        .list_features(
-            FeaturesListRequest::new()
-                .json(true)
-                .profile("dev")
-                .config_override("features.extras", "true"),
-        )
-        .await
-        .unwrap();
-
-    assert_eq!(output.format, FeaturesListFormat::Json);
-    assert_eq!(output.features.len(), 2);
-    assert_eq!(output.features[0].stage, Some(CodexFeatureStage::Stable));
-    assert!(output.features[0].enabled);
-    assert!(!output.features[1].enabled);
-
-    let mut lines = output.stderr.lines();
-    let pwd = lines.next().unwrap();
-    assert_eq!(Path::new(pwd), workdir.as_path());
-
-    let args: Vec<_> = lines.map(str::to_string).collect();
-    assert_eq!(
-        args,
-        vec![
-            "features",
-            "list",
-            "--config",
-            "features.extras=true",
-            "--profile",
-            "dev",
-            "--ask-for-approval",
-            "on-request",
-            "--search",
-            "--json"
-        ]
-    );
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn supports_help_review_fork_resume_and_features_commands() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-printf "%s\n" "$@"
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let features = client
-        .features(FeaturesCommandRequest::new())
-        .await
-        .unwrap();
-    assert_eq!(
-        features.stdout.lines().collect::<Vec<_>>(),
-        vec!["features"]
-    );
-
-    let help = client
-        .help(HelpCommandRequest::new(HelpScope::Root).command(["exec", "review"]))
-        .await
-        .unwrap();
-    assert_eq!(
-        help.stdout.lines().collect::<Vec<_>>(),
-        vec!["help", "exec", "review"]
-    );
-
-    let review = client
-        .review(
-            ReviewCommandRequest::new()
-                .base("main")
-                .commit("abc123")
-                .title("hello")
-                .uncommitted(true)
-                .prompt("please review"),
-        )
-        .await
-        .unwrap();
-    assert_eq!(
-        review.stdout.lines().collect::<Vec<_>>(),
-        vec![
-            "review",
-            "--base",
-            "main",
-            "--commit",
-            "abc123",
-            "--title",
-            "hello",
-            "--uncommitted",
-            "please review"
-        ]
-    );
-
-    let exec_review = client
-        .exec_review(
-            ExecReviewCommandRequest::new()
-                .base("main")
-                .commit("abc123")
-                .title("hello")
-                .uncommitted(true)
-                .json(true)
-                .prompt("please review"),
-        )
-        .await
-        .unwrap();
-    assert_eq!(
-        exec_review.stdout.lines().collect::<Vec<_>>(),
-        vec![
-            "exec",
-            "review",
-            "--base",
-            "main",
-            "--commit",
-            "abc123",
-            "--json",
-            "--skip-git-repo-check",
-            "--title",
-            "hello",
-            "--uncommitted",
-            "please review"
-        ]
-    );
-
-    let resume = client
-        .resume_session(
-            ResumeSessionRequest::new()
-                .all(true)
-                .last(true)
-                .session_id("sess-1")
-                .prompt("resume prompt"),
-        )
-        .await
-        .unwrap();
-    assert_eq!(
-        resume.stdout.lines().collect::<Vec<_>>(),
-        vec!["resume", "--all", "--last", "sess-1", "resume prompt"]
-    );
-
-    let fork = client
-        .fork_session(
-            ForkSessionRequest::new()
-                .all(true)
-                .last(true)
-                .session_id("sess-1")
-                .prompt("fork prompt"),
-        )
-        .await
-        .unwrap();
-    assert_eq!(
-        fork.stdout.lines().collect::<Vec<_>>(),
-        vec!["fork", "--all", "--last", "sess-1", "fork prompt"]
-    );
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn cloud_list_parses_json_and_maps_args() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-printf "%s\n" "$@" 1>&2
-cat <<'JSON'
-{"tasks":[],"cursor":null}
-JSON
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let output = client
-        .cloud_list(
-            CloudListRequest::new()
-                .json(true)
-                .env_id("env-1")
-                .limit(3)
-                .cursor("cur-1"),
-        )
-        .await
-        .unwrap();
-
-    assert_eq!(output.json, Some(json!({"tasks": [], "cursor": null})));
-    assert_eq!(
-        output.stderr.lines().collect::<Vec<_>>(),
-        vec!["cloud", "list", "--env", "env-1", "--limit", "3", "--cursor", "cur-1", "--json"]
-    );
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn cloud_exec_maps_args_and_rejects_empty_env_id() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-printf "%s\n" "$@"
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let output = client
-        .cloud_exec(
-            CloudExecRequest::new("env-1")
-                .attempts(2)
-                .branch("main")
-                .query("hello"),
-        )
-        .await
-        .unwrap();
-    assert_eq!(
-        output.stdout.lines().collect::<Vec<_>>(),
-        vec![
-            "cloud",
-            "exec",
-            "--env",
-            "env-1",
-            "--attempts",
-            "2",
-            "--branch",
-            "main",
-            "hello"
-        ]
-    );
-
-    let err = client
-        .cloud_exec(CloudExecRequest::new("  "))
-        .await
-        .unwrap_err();
-    assert!(matches!(err, CodexError::EmptyEnvId));
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn mcp_list_get_and_add_map_args_and_parse_json() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-printf "%s\n" "$@" 1>&2
-cat <<'JSON'
-{"servers":[{"name":"files"}]}
-JSON
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let list = client
-        .mcp_list(McpListRequest::new().json(true))
-        .await
-        .unwrap();
-    assert_eq!(list.json, Some(json!({"servers": [{"name": "files"}]})));
-    assert_eq!(
-        list.stderr.lines().collect::<Vec<_>>(),
-        vec!["mcp", "list", "--json"]
-    );
-
-    let get = client
-        .mcp_get(McpGetRequest::new("files").json(true))
-        .await
-        .unwrap();
-    assert_eq!(get.json, Some(json!({"servers": [{"name": "files"}]})));
-    assert_eq!(
-        get.stderr.lines().collect::<Vec<_>>(),
-        vec!["mcp", "get", "--json", "files"]
-    );
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn mcp_add_maps_transports_and_validates_required_fields() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-printf "%s\n" "$@"
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let stdio = client
-        .mcp_add(
-            McpAddRequest::stdio("files", vec![OsString::from("node"), OsString::from("srv")])
-                .env("TOKEN", "abc"),
-        )
-        .await
-        .unwrap();
-    assert_eq!(
-        stdio.stdout.lines().collect::<Vec<_>>(),
-        vec![
-            "mcp",
-            "add",
-            "files",
-            "--env",
-            "TOKEN=abc",
-            "--",
-            "node",
-            "srv"
-        ]
-    );
-
-    let http = client
-        .mcp_add(
-            McpAddRequest::streamable_http("http", "https://example.test")
-                .bearer_token_env_var("TOKEN_ENV"),
-        )
-        .await
-        .unwrap();
-    assert_eq!(
-        http.stdout.lines().collect::<Vec<_>>(),
-        vec![
-            "mcp",
-            "add",
-            "http",
-            "--url",
-            "https://example.test",
-            "--bearer-token-env-var",
-            "TOKEN_ENV"
-        ]
-    );
-
-    let err = client
-        .mcp_add(McpAddRequest::stdio("files", Vec::new()))
-        .await
-        .unwrap_err();
-    assert!(matches!(err, CodexError::EmptyMcpCommand));
-
-    let err = client
-        .mcp_add(McpAddRequest::streamable_http("bad", "  "))
-        .await
-        .unwrap_err();
-    assert!(matches!(err, CodexError::EmptyMcpUrl));
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn app_server_codegen_maps_overrides_and_prettier() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-echo "$PWD"
-printf "%s\n" "$@"
-"#,
-    );
-
-    let workdir = dir.path().join("workdir");
-    std_fs::create_dir_all(&workdir).unwrap();
-    let out_dir = dir.path().join("out/ts");
-    let prettier = dir.path().join("bin/prettier.js");
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .working_dir(&workdir)
-        .approval_policy(ApprovalPolicy::OnRequest)
-        .search(true)
-        .build();
-
-    let result = client
-        .generate_app_server_bindings(
-            AppServerCodegenRequest::typescript(&out_dir)
-                .prettier(&prettier)
-                .profile("dev")
-                .config_override("features.codegen", "true"),
-        )
-        .await
-        .unwrap();
-
-    let mut lines = result.stdout.lines();
-    let pwd = lines.next().unwrap();
-    assert_eq!(Path::new(pwd), workdir.as_path());
-
-    let args: Vec<_> = lines.map(str::to_string).collect();
-    assert_eq!(
-        args,
-        vec![
-            "app-server",
-            "generate-ts",
-            "--out",
-            out_dir.to_string_lossy().as_ref(),
-            "--config",
-            "features.codegen=true",
-            "--profile",
-            "dev",
-            "--ask-for-approval",
-            "on-request",
-            "--search",
-            "--prettier",
-            prettier.to_string_lossy().as_ref(),
-        ]
-    );
-    assert!(out_dir.is_dir());
-    assert_eq!(result.out_dir, out_dir);
-    assert!(result.status.success());
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn app_server_codegen_surfaces_non_zero_exit() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-echo "ts error"
-echo "bad format" 1>&2
-exit 5
-"#,
-    );
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let out_dir = dir.path().join("schema");
-    let err = client
-        .generate_app_server_bindings(AppServerCodegenRequest::json_schema(&out_dir))
-        .await
-        .unwrap_err();
-
-    match err {
-        CodexError::NonZeroExit { status, stderr } => {
-            assert_eq!(status.code(), Some(5));
-            assert!(stderr.contains("bad format"));
-        }
-        other => panic!("expected NonZeroExit, got {other:?}"),
-    }
-    assert!(out_dir.is_dir());
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn responses_api_proxy_maps_flags_and_parses_server_info() {
-    let dir = tempfile::tempdir().unwrap();
-    let server_info = dir.path().join("server-info.json");
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-echo "$PWD"
-printf "%s\n" "$@"
-info_path=""
-while [[ $# -gt 0 ]]; do
-  if [[ $1 == "--server-info" ]]; then
-info_path=$2
-  fi
-  shift
-done
-read -r key || exit 1
-echo "key:${key}"
-if [[ -n "$info_path" ]]; then
-  printf '{"port":4567,"pid":1234}\n' > "$info_path"
-fi
-"#,
-    );
-
-    let workdir = dir.path().join("responses-workdir");
-    std_fs::create_dir_all(&workdir).unwrap();
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .working_dir(&workdir)
-        .build();
-
-    let mut proxy = client
-        .start_responses_api_proxy(
-            ResponsesApiProxyRequest::new("sk-test-123")
-                .port(8080)
-                .server_info(&server_info)
-                .http_shutdown(true)
-                .upstream_url("https://example.com/v1/responses"),
-        )
-        .await
-        .unwrap();
-
-    assert_eq!(
-        proxy.server_info_path.as_deref(),
-        Some(server_info.as_path())
-    );
-
-    let stdout = proxy.child.stdout.take().unwrap();
-    let mut lines = BufReader::new(stdout).lines();
-
-    let pwd = lines.next_line().await.unwrap().unwrap();
-    assert_eq!(Path::new(&pwd), workdir.as_path());
-
-    let mut args = Vec::new();
-    for _ in 0..8 {
-        args.push(lines.next_line().await.unwrap().unwrap());
-    }
-    assert_eq!(
-        args,
-        vec![
-            "responses-api-proxy",
-            "--port",
-            "8080",
-            "--server-info",
-            server_info.to_string_lossy().as_ref(),
-            "--http-shutdown",
-            "--upstream-url",
-            "https://example.com/v1/responses",
-        ]
-    );
-
-    let api_key_line = lines.next_line().await.unwrap().unwrap();
-    assert_eq!(api_key_line, "key:sk-test-123");
-
-    let info = proxy.read_server_info().await.unwrap().unwrap();
-    assert_eq!(info.port, 4567);
-    assert_eq!(info.pid, 1234);
-
-    let status = proxy.child.wait().await.unwrap();
-    assert!(status.success());
-}
-
-#[tokio::test]
-async fn responses_api_proxy_rejects_empty_api_key() {
-    let client = CodexClient::builder().build();
-    let err = client
-        .start_responses_api_proxy(ResponsesApiProxyRequest::new("  "))
-        .await
-        .unwrap_err();
-    assert!(matches!(err, CodexError::EmptyApiKey));
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn stdio_to_uds_maps_args_and_pipes_stdio() {
-    let dir = tempfile::tempdir().unwrap();
-    let socket_path = dir.path().join("bridge.sock");
-    let script_path = write_fake_codex(
-        dir.path(),
-        r#"#!/usr/bin/env bash
-echo "$PWD"
-printf "%s\n" "$@"
-while read -r line; do
-  echo "relay:${line}"
-done
-"#,
-    );
-
-    let workdir = dir.path().join("uds-workdir");
-    std_fs::create_dir_all(&workdir).unwrap();
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .working_dir(&workdir)
-        .build();
-
-    let request = StdioToUdsRequest::new(&socket_path).working_dir(&workdir);
-    let mut child = match client.stdio_to_uds(request.clone()) {
-        Ok(child) => child,
-        Err(CodexError::Spawn { source, .. }) if source.raw_os_error() == Some(26) => {
-            time::sleep(Duration::from_millis(25)).await;
-            client.stdio_to_uds(request).unwrap()
-        }
-        Err(other) => panic!("unexpected spawn error: {other:?}"),
-    };
-
-    let stdout = child.stdout.take().unwrap();
-    let mut lines = BufReader::new(stdout).lines();
-
-    let pwd = lines.next_line().await.unwrap().unwrap();
-    assert_eq!(Path::new(&pwd), workdir.as_path());
-
-    let arg_one = lines.next_line().await.unwrap().unwrap();
-    let arg_two = lines.next_line().await.unwrap().unwrap();
-    assert_eq!(arg_one, "stdio-to-uds");
-    assert_eq!(arg_two, socket_path.to_string_lossy().as_ref());
-
-    let mut stdin = child.stdin.take().unwrap();
-    stdin.write_all(b"ping\n").await.unwrap();
-    stdin.shutdown().await.unwrap();
-    drop(stdin);
-
-    let echoed = lines.next_line().await.unwrap().unwrap();
-    assert_eq!(echoed, "relay:ping");
-
-    let status = time::timeout(Duration::from_secs(5), child.wait())
-        .await
-        .expect("stdio-to-uds wait timed out")
-        .unwrap();
-    assert!(status.success());
-}
-
-#[tokio::test]
-async fn stdio_to_uds_rejects_empty_socket_path() {
-    let client = CodexClient::builder().build();
-    let err = client
-        .stdio_to_uds(StdioToUdsRequest::new(PathBuf::new()))
-        .unwrap_err();
-    assert!(matches!(err, CodexError::EmptySocketPath));
-}
-
-#[tokio::test]
-async fn sandbox_rejects_empty_command() {
-    let client = CodexClient::builder().build();
-    let request = SandboxCommandRequest::new(SandboxPlatform::Linux, Vec::<OsString>::new());
-    let err = client.run_sandbox(request).await.unwrap_err();
-    assert!(matches!(err, CodexError::EmptySandboxCommand));
-}
-
-fn capabilities_with_version(raw_version: &str) -> CodexCapabilities {
-    CodexCapabilities {
-        cache_key: CapabilityCacheKey {
-            binary_path: PathBuf::from("codex"),
-        },
-        fingerprint: None,
-        version: Some(version::parse_version_output(raw_version)),
-        features: CodexFeatureFlags::default(),
-        probe_plan: CapabilityProbePlan::default(),
-        collected_at: SystemTime::now(),
-    }
-}
-
-fn capabilities_without_version() -> CodexCapabilities {
-    CodexCapabilities {
-        cache_key: CapabilityCacheKey {
-            binary_path: PathBuf::from("codex"),
-        },
-        fingerprint: None,
-        version: None,
-        features: CodexFeatureFlags::default(),
-        probe_plan: CapabilityProbePlan::default(),
-        collected_at: SystemTime::now(),
-    }
-}
-
-fn capabilities_with_feature_flags(features: CodexFeatureFlags) -> CodexCapabilities {
-    CodexCapabilities {
-        cache_key: CapabilityCacheKey {
-            binary_path: PathBuf::from("codex"),
-        },
-        fingerprint: None,
-        version: None,
-        features,
-        probe_plan: CapabilityProbePlan::default(),
-        collected_at: SystemTime::now(),
-    }
-}
-
-fn sample_capabilities_snapshot() -> CodexCapabilities {
-    CodexCapabilities {
-        cache_key: CapabilityCacheKey {
-            binary_path: PathBuf::from("/tmp/codex"),
-        },
-        fingerprint: Some(BinaryFingerprint {
-            canonical_path: Some(PathBuf::from("/tmp/codex")),
-            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(5)),
-            len: Some(1234),
-        }),
-        version: Some(CodexVersionInfo {
-            raw: "codex 3.4.5-beta (commit cafe)".to_string(),
-            semantic: Some((3, 4, 5)),
-            commit: Some("cafe".to_string()),
-            channel: CodexReleaseChannel::Beta,
-        }),
-        features: CodexFeatureFlags {
-            supports_features_list: true,
-            supports_output_schema: true,
-            supports_add_dir: false,
-            supports_mcp_login: true,
-        },
-        probe_plan: CapabilityProbePlan {
-            steps: vec![
-                CapabilityProbeStep::VersionFlag,
-                CapabilityProbeStep::FeaturesListJson,
-                CapabilityProbeStep::ManualOverride,
-            ],
-        },
-        collected_at: SystemTime::UNIX_EPOCH + Duration::from_secs(10),
-    }
-}
-
-fn sample_capability_overrides() -> CapabilityOverrides {
-    CapabilityOverrides {
-        snapshot: Some(sample_capabilities_snapshot()),
-        version: Some(version::parse_version_output("codex 9.9.9-nightly")),
-        features: CapabilityFeatureOverrides {
-            supports_features_list: Some(true),
-            supports_output_schema: Some(true),
-            supports_add_dir: Some(true),
-            supports_mcp_login: None,
-        },
-    }
-}
-
-fn capability_snapshot_with_metadata(
-    collected_at: SystemTime,
-    fingerprint: Option<BinaryFingerprint>,
-) -> CodexCapabilities {
-    CodexCapabilities {
-        cache_key: CapabilityCacheKey {
-            binary_path: PathBuf::from("/tmp/codex"),
-        },
-        fingerprint,
-        version: None,
-        features: CodexFeatureFlags::default(),
-        probe_plan: CapabilityProbePlan::default(),
-        collected_at,
-    }
-}
-
-#[test]
-fn builder_defaults_are_sane() {
-    let builder = CodexClient::builder();
-    assert!(builder.model.is_none());
-    assert_eq!(builder.timeout, DEFAULT_TIMEOUT);
-    assert_eq!(builder.color_mode, ColorMode::Never);
-    assert!(builder.codex_home.is_none());
-    assert!(builder.create_home_dirs);
-    assert!(builder.working_dir.is_none());
-    assert!(builder.images.is_empty());
-    assert!(!builder.json_output);
-    assert!(!builder.quiet);
-    assert!(builder.json_event_log.is_none());
-    assert!(builder.cli_overrides.config_overrides.is_empty());
-    assert!(!builder.cli_overrides.reasoning.has_overrides());
-    assert!(builder.cli_overrides.approval_policy.is_none());
-    assert!(builder.cli_overrides.sandbox_mode.is_none());
-    assert_eq!(
-        builder.cli_overrides.safety_override,
-        SafetyOverride::Inherit
-    );
-    assert!(builder.cli_overrides.cd.is_none());
-    assert!(builder.cli_overrides.local_provider.is_none());
-    assert_eq!(builder.cli_overrides.search, FlagState::Inherit);
-    assert!(builder.cli_overrides.auto_reasoning_defaults);
-    assert!(builder.capability_overrides.is_empty());
-    assert_eq!(
-        builder.capability_cache_policy,
-        CapabilityCachePolicy::PreferCache
-    );
-}
-
-#[test]
-fn builder_collects_images() {
-    let client = CodexClient::builder()
-        .image("foo.png")
-        .image("bar.jpg")
-        .build();
-    assert_eq!(client.images.len(), 2);
-    assert_eq!(client.images[0], PathBuf::from("foo.png"));
-    assert_eq!(client.images[1], PathBuf::from("bar.jpg"));
-}
-
-#[test]
-fn builder_sets_json_flag() {
-    let client = CodexClient::builder().json(true).build();
-    assert!(client.json_output);
-}
-
-#[test]
-fn builder_sets_json_event_log() {
-    let client = CodexClient::builder().json_event_log("events.log").build();
-    assert_eq!(client.json_event_log, Some(PathBuf::from("events.log")));
-}
-
-#[test]
-fn builder_sets_quiet_flag() {
-    let client = CodexClient::builder().quiet(true).build();
-    assert!(client.quiet);
-}
-
-#[test]
-fn builder_mirrors_stdout_by_default() {
-    let client = CodexClient::builder().build();
-    assert!(client.mirror_stdout);
-}
-
-#[test]
-fn builder_can_disable_stdout_mirroring() {
-    let client = CodexClient::builder().mirror_stdout(false).build();
-    assert!(!client.mirror_stdout);
-}
-
-#[test]
-fn builder_uses_env_binary_when_set() {
-    let _guard = env_guard();
-    let key = CODEX_BINARY_ENV;
-    let original = env::var_os(key);
-    env::set_var(key, "custom_codex");
-    let builder = CodexClient::builder();
-    assert_eq!(builder.binary, PathBuf::from("custom_codex"));
-    if let Some(value) = original {
-        env::set_var(key, value);
-    } else {
-        env::remove_var(key);
-    }
-}
-
-#[test]
-fn default_binary_falls_back_when_env_missing() {
-    let _guard = env_guard();
-    let key = CODEX_BINARY_ENV;
-    let original = env::var_os(key);
-    env::remove_var(key);
-
-    assert_eq!(default_binary_path(), PathBuf::from("codex"));
-
-    if let Some(value) = original {
-        env::set_var(key, value);
-    } else {
-        env::remove_var(key);
-    }
-}
-
-#[test]
-fn default_rust_log_is_error_when_unset() {
-    let _guard = env_guard();
-    let original = env::var_os("RUST_LOG");
-    env::remove_var("RUST_LOG");
-
-    assert_eq!(default_rust_log_value(), Some("error"));
-
-    if let Some(value) = original {
-        env::set_var("RUST_LOG", value);
-    } else {
-        env::remove_var("RUST_LOG");
-    }
-}
-
-#[test]
-fn default_rust_log_respects_existing_env() {
-    let _guard = env_guard();
-    let original = env::var_os("RUST_LOG");
-    env::set_var("RUST_LOG", "info");
-
-    assert_eq!(default_rust_log_value(), None);
-
-    if let Some(value) = original {
-        env::set_var("RUST_LOG", value);
-    } else {
-        env::remove_var("RUST_LOG");
-    }
-}
-
-#[test]
-fn command_env_sets_expected_overrides() {
-    let _guard = env_guard();
-    let rust_log_original = env::var_os(RUST_LOG_ENV);
-    env::remove_var(RUST_LOG_ENV);
-
-    let temp = tempfile::tempdir().unwrap();
-    let home = temp.path().join("codex_home");
-    let env_prep =
-        CommandEnvironment::new(PathBuf::from("/custom/codex"), Some(home.clone()), true);
-    let overrides = env_prep.environment_overrides().unwrap();
-    let map: HashMap<OsString, OsString> = overrides.into_iter().collect();
-
-    assert_eq!(
-        map.get(&OsString::from(CODEX_BINARY_ENV)),
-        Some(&OsString::from("/custom/codex"))
-    );
-    assert_eq!(
-        map.get(&OsString::from(CODEX_HOME_ENV)),
-        Some(&home.as_os_str().to_os_string())
-    );
-    assert_eq!(
-        map.get(&OsString::from(RUST_LOG_ENV)),
-        Some(&OsString::from(DEFAULT_RUST_LOG))
-    );
-
-    assert!(home.is_dir());
-    assert!(home.join("conversations").is_dir());
-    assert!(home.join("logs").is_dir());
-
-    match rust_log_original {
-        Some(value) => env::set_var(RUST_LOG_ENV, value),
-        None => env::remove_var(RUST_LOG_ENV),
-    }
-}
-
-#[test]
-fn command_env_applies_home_and_binary_per_command() {
-    let _guard = env_guard();
-    let binary_key = CODEX_BINARY_ENV;
-    let home_key = CODEX_HOME_ENV;
-    let rust_log_key = RUST_LOG_ENV;
-    let original_binary = env::var_os(binary_key);
-    let original_home = env::var_os(home_key);
-    let original_rust_log = env::var_os(rust_log_key);
-
-    env::set_var(binary_key, "/tmp/ignored_codex");
-    env::set_var(home_key, "/tmp/ambient_home");
-    env::remove_var(rust_log_key);
-
-    let temp = tempfile::tempdir().unwrap();
-    let home = temp.path().join("scoped_home");
-    let env_prep = CommandEnvironment::new(
-        PathBuf::from("/app/bundled/codex"),
-        Some(home.clone()),
-        true,
-    );
-
-    let mut command = Command::new("echo");
-    env_prep.apply(&mut command).unwrap();
-
-    let envs: HashMap<OsString, Option<OsString>> = command
-        .as_std()
-        .get_envs()
-        .map(|(key, value)| (key.to_os_string(), value.map(|v| v.to_os_string())))
-        .collect();
-
-    assert_eq!(
-        envs.get(&OsString::from(binary_key)),
-        Some(&Some(OsString::from("/app/bundled/codex")))
-    );
-    assert_eq!(
-        envs.get(&OsString::from(home_key)),
-        Some(&Some(home.as_os_str().to_os_string()))
-    );
-    assert_eq!(
-        envs.get(&OsString::from(rust_log_key)),
-        Some(&Some(OsString::from(DEFAULT_RUST_LOG)))
-    );
-    assert_eq!(
-        env::var_os(home_key),
-        Some(OsString::from("/tmp/ambient_home"))
-    );
-    assert!(home.is_dir());
-    assert!(home.join("conversations").is_dir());
-    assert!(home.join("logs").is_dir());
-
-    match original_binary {
-        Some(value) => env::set_var(binary_key, value),
-        None => env::remove_var(binary_key),
-    }
-    match original_home {
-        Some(value) => env::set_var(home_key, value),
-        None => env::remove_var(home_key),
-    }
-    match original_rust_log {
-        Some(value) => env::set_var(rust_log_key, value),
-        None => env::remove_var(rust_log_key),
-    }
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn apply_and_diff_capture_outputs_and_status() {
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = dir.path().join("codex");
-    std::fs::write(
-        &script_path,
-        r#"#!/usr/bin/env bash
-set -e
-cmd="$1"
-if [[ "$cmd" == "apply" ]]; then
-  echo "applied"
-  echo "apply-stderr" >&2
-  exit 0
-elif [[ "$cmd" == "cloud" && "${2:-}" == "diff" ]]; then
-  echo "diff-body"
-  echo "diff-stderr" >&2
-  exit 3
-else
-  echo "unknown $cmd" >&2
-  exit 99
-fi
-"#,
-    )
-    .unwrap();
-    let mut perms = std::fs::metadata(&script_path).unwrap().permissions();
-    perms.set_mode(0o755);
-    std::fs::set_permissions(&script_path, perms).unwrap();
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let apply = client.apply().await.unwrap();
-    assert!(apply.status.success());
-    assert_eq!(apply.stdout.trim(), "applied");
-    assert_eq!(apply.stderr.trim(), "apply-stderr");
-
-    let diff = client.diff().await.unwrap();
-    assert!(!diff.status.success());
-    assert_eq!(diff.status.code(), Some(3));
-    assert_eq!(diff.stdout.trim(), "diff-body");
-    assert_eq!(diff.stderr.trim(), "diff-stderr");
-}
-
-#[cfg(unix)]
-#[tokio::test]
-async fn apply_respects_rust_log_default() {
-    let _guard = env_guard_async().await;
-    let original = env::var_os("RUST_LOG");
-    env::remove_var("RUST_LOG");
-
-    let dir = tempfile::tempdir().unwrap();
-    let script_path = dir.path().join("codex-rust-log");
-    std::fs::write(
-        &script_path,
-        r#"#!/usr/bin/env bash
-echo "${RUST_LOG:-missing}"
-exit 0
-"#,
-    )
-    .unwrap();
-    let mut perms = std::fs::metadata(&script_path).unwrap().permissions();
-    perms.set_mode(0o755);
-    std::fs::set_permissions(&script_path, perms).unwrap();
-
-    let client = CodexClient::builder()
-        .binary(&script_path)
-        .mirror_stdout(false)
-        .quiet(true)
-        .build();
-
-    let apply = client.apply().await.unwrap();
-    assert_eq!(apply.stdout.trim(), "error");
-
-    if let Some(value) = original {
-        env::set_var("RUST_LOG", value);
-    } else {
-        env::remove_var("RUST_LOG");
-    }
-}
-
-#[test]
-fn command_env_respects_existing_rust_log() {
-    let _guard = env_guard();
-    let rust_log_original = env::var_os(RUST_LOG_ENV);
-    env::set_var(RUST_LOG_ENV, "trace");
-
-    let env_prep = CommandEnvironment::new(PathBuf::from("codex"), None, true);
-    let overrides = env_prep.environment_overrides().unwrap();
-    let map: HashMap<OsString, OsString> = overrides.into_iter().collect();
-
-    assert_eq!(
-        map.get(&OsString::from(CODEX_BINARY_ENV)),
-        Some(&OsString::from("codex"))
-    );
-    assert!(!map.contains_key(&OsString::from(RUST_LOG_ENV)));
-
-    match rust_log_original {
-        Some(value) => env::set_var(RUST_LOG_ENV, value),
-        None => env::remove_var(RUST_LOG_ENV),
-    }
-}
-
-#[test]
-fn command_env_can_skip_home_creation() {
-    let _guard = env_guard();
-    let rust_log_original = env::var_os(RUST_LOG_ENV);
-    env::remove_var(RUST_LOG_ENV);
-
-    let temp = tempfile::tempdir().unwrap();
-    let home = temp.path().join("codex_home");
-    let env_prep = CommandEnvironment::new(PathBuf::from("codex"), Some(home.clone()), false);
-    let overrides = env_prep.environment_overrides().unwrap();
-    let map: HashMap<OsString, OsString> = overrides.into_iter().collect();
-
-    assert!(!home.exists());
-    assert!(!home.join("conversations").exists());
-    assert!(!home.join("logs").exists());
-    assert_eq!(
-        map.get(&OsString::from(CODEX_HOME_ENV)),
-        Some(&home.as_os_str().to_os_string())
-    );
-
-    match rust_log_original {
-        Some(value) => env::set_var(RUST_LOG_ENV, value),
-        None => env::remove_var(RUST_LOG_ENV),
-    }
-}
-
-#[test]
-fn codex_home_layout_exposes_paths() {
-    let root = PathBuf::from("/tmp/codex_layout_root");
-    let layout = CodexHomeLayout::new(&root);
-
-    assert_eq!(layout.root(), root.as_path());
-    assert_eq!(layout.config_path(), root.join("config.toml"));
-    assert_eq!(layout.auth_path(), root.join("auth.json"));
-    assert_eq!(layout.credentials_path(), root.join(".credentials.json"));
-    assert_eq!(layout.history_path(), root.join("history.jsonl"));
-    assert_eq!(layout.conversations_dir(), root.join("conversations"));
-    assert_eq!(layout.logs_dir(), root.join("logs"));
-}
-
-#[test]
-fn codex_home_layout_respects_materialization_flag() {
-    let temp = tempfile::tempdir().unwrap();
-    let root = temp.path().join("codex_home_layout");
-    let layout = CodexHomeLayout::new(&root);
-
-    layout.materialize(false).unwrap();
-    assert!(!root.exists());
-
-    layout.materialize(true).unwrap();
-    assert!(root.is_dir());
-    assert!(layout.conversations_dir().is_dir());
-    assert!(layout.logs_dir().is_dir());
-}
-
-#[test]
-fn seed_auth_copies_files_and_creates_targets() {
-    let temp = tempfile::tempdir().unwrap();
-    let seed = temp.path().join("seed_home");
-    std::fs::create_dir_all(&seed).unwrap();
-    std::fs::write(seed.join("auth.json"), "auth").unwrap();
-    std::fs::write(seed.join(".credentials.json"), "creds").unwrap();
-
-    let target_root = temp.path().join("target_home");
-    let layout = CodexHomeLayout::new(&target_root);
-    let outcome = layout
-        .seed_auth_from(&seed, AuthSeedOptions::default())
-        .unwrap();
-
-    assert!(outcome.copied_auth);
-    assert!(outcome.copied_credentials);
-    assert_eq!(std::fs::read_to_string(layout.auth_path()).unwrap(), "auth");
-    assert_eq!(
-        std::fs::read_to_string(layout.credentials_path()).unwrap(),
-        "creds"
-    );
-}
-
-#[test]
-fn seed_auth_skips_optional_files() {
-    let temp = tempfile::tempdir().unwrap();
-    let seed = temp.path().join("seed_home");
-    std::fs::create_dir_all(&seed).unwrap();
-    std::fs::write(seed.join("auth.json"), "auth").unwrap();
-
-    let target_root = temp.path().join("target_home");
-    let layout = CodexHomeLayout::new(&target_root);
-    let outcome = layout
-        .seed_auth_from(&seed, AuthSeedOptions::default())
-        .unwrap();
-
-    assert!(outcome.copied_auth);
-    assert!(!outcome.copied_credentials);
-    assert_eq!(std::fs::read_to_string(layout.auth_path()).unwrap(), "auth");
-    assert!(!layout.credentials_path().exists());
-}
-
-#[test]
-fn seed_auth_errors_when_required_missing() {
-    let temp = tempfile::tempdir().unwrap();
-    let seed = temp.path().join("seed_home");
-    std::fs::create_dir_all(&seed).unwrap();
-
-    let target_root = temp.path().join("target_home");
-    let layout = CodexHomeLayout::new(&target_root);
-    let err = layout
-        .seed_auth_from(
-            &seed,
-            AuthSeedOptions {
-                require_auth: true,
-                require_credentials: true,
-                ..Default::default()
-            },
-        )
-        .unwrap_err();
-
-    match err {
-        AuthSeedError::SeedFileMissing { path } => {
-            assert!(path.ends_with("auth.json"), "{path:?}")
-        }
-        other => panic!("unexpected error: {other:?}"),
-    }
-}
-
-#[test]
-fn codex_client_returns_configured_home_layout() {
-    let temp = tempfile::tempdir().unwrap();
-    let root = temp.path().join("app_codex_home");
-    let client = CodexClient::builder().codex_home(&root).build();
-
-    let layout = client.codex_home_layout().expect("layout missing");
-    assert_eq!(layout.root(), root.as_path());
-    assert!(!root.exists());
-
-    let client_without_home = CodexClient::builder().build();
-    assert!(client_without_home.codex_home_layout().is_none());
-}
-
-#[test]
-fn parses_version_output_fields() {
-    let parsed = version::parse_version_output("codex v3.4.5-nightly (commit abc1234)");
-    assert_eq!(parsed.semantic, Some((3, 4, 5)));
-    assert_eq!(parsed.channel, CodexReleaseChannel::Nightly);
-    assert_eq!(parsed.commit.as_deref(), Some("abc1234"));
-    assert_eq!(
-        parsed.raw,
-        "codex v3.4.5-nightly (commit abc1234)".to_string()
-    );
-}
-
-#[test]
-fn update_advisory_detects_newer_release() {
-    let capabilities = capabilities_with_version("codex 1.0.0");
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("1.1.0").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::UpdateRecommended);
-    assert!(advisory.is_update_recommended());
-    assert_eq!(
-        advisory
-            .latest_release
-            .as_ref()
-            .map(|release| release.version.clone()),
-        latest.stable
-    );
-}
-
-#[test]
-fn normalize_stream_infers_missing_thread_and_turn() {
-    let mut context = crate::jsonl::StreamContext::default();
-    // thread.started establishes thread context
-    let thread_line = r#"{"type":"thread.started","thread_id":"thread-1"}"#;
-    let thread_event = crate::jsonl::normalize_thread_event(thread_line, &mut context).unwrap();
-    match thread_event {
-        ThreadEvent::ThreadStarted(t) => assert_eq!(t.thread_id, "thread-1"),
-        other => panic!("unexpected event: {other:?}"),
-    }
-    // turn.started without thread_id should inherit
-    let turn_line = r#"{"type":"turn.started","turn_id":"turn-1"}"#;
-    let turn_event = crate::jsonl::normalize_thread_event(turn_line, &mut context).unwrap();
-    match turn_event {
-        ThreadEvent::TurnStarted(t) => {
-            assert_eq!(t.thread_id, "thread-1");
-            assert_eq!(t.turn_id, "turn-1");
-        }
-        other => panic!("unexpected event: {other:?}"),
-    }
-    // item.completed without ids should inherit both
-    let item_line =
-        r#"{"type":"item.completed","item":{"id":"msg-1","type":"agent_message","text":"hi"}}"#;
-    let item_event = crate::jsonl::normalize_thread_event(item_line, &mut context).unwrap();
-    match item_event {
-        ThreadEvent::ItemCompleted(item) => {
-            assert_eq!(item.turn_id, "turn-1");
-            assert_eq!(item.thread_id, "thread-1");
-            assert_eq!(item.item.item_id, "msg-1");
-        }
-        other => panic!("unexpected event: {other:?}"),
-    }
-}
-
-#[test]
-fn normalize_stream_errors_without_context() {
-    let mut context = crate::jsonl::StreamContext::default();
-    let line = r#"{"type":"turn.started"}"#;
-    let err = crate::jsonl::normalize_thread_event(line, &mut context).unwrap_err();
-    match err {
-        ExecStreamError::Normalize { .. } => {}
-        other => panic!("unexpected error: {other:?}"),
-    }
-}
-
-#[test]
-fn update_advisory_handles_unknown_local_version() {
-    let capabilities = capabilities_without_version();
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("3.2.1").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::UnknownLocalVersion);
-    assert!(advisory.is_update_recommended());
-    assert!(advisory
-        .notes
-        .iter()
-        .any(|note| note.contains("could not be parsed")));
-}
-
-#[test]
-fn update_advisory_marks_up_to_date() {
-    let capabilities = capabilities_with_version("codex 2.0.1");
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("2.0.1").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::UpToDate);
-    assert!(!advisory.is_update_recommended());
-}
-
-#[test]
-fn update_advisory_falls_back_when_channel_missing() {
-    let capabilities = capabilities_with_version("codex 2.0.0-beta");
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("2.0.1").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.comparison_channel, CodexReleaseChannel::Stable);
-    assert_eq!(advisory.status, CodexUpdateStatus::UpdateRecommended);
-    assert!(advisory
-        .notes
-        .iter()
-        .any(|note| note.contains("comparing against stable")));
-}
-
-#[test]
-fn update_advisory_handles_local_newer_than_known() {
-    let capabilities = capabilities_with_version("codex 2.0.0");
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("1.9.9").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::LocalNewerThanKnown);
-    assert!(!advisory.is_update_recommended());
-    assert!(advisory
-        .notes
-        .iter()
-        .any(|note| note.contains("newer than provided")));
-}
-
-#[test]
-fn update_advisory_handles_missing_latest_metadata() {
-    let capabilities = capabilities_with_version("codex 1.0.0");
-    let latest = CodexLatestReleases::default();
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::UnknownLatestVersion);
-    assert!(!advisory.is_update_recommended());
-    assert!(advisory
-        .notes
-        .iter()
-        .any(|note| note.contains("advisory unavailable")));
-}
-
-#[test]
-fn capability_snapshots_serialize_to_json_and_toml() {
-    let snapshot = sample_capabilities_snapshot();
-
-    let json = serialize_capabilities_snapshot(&snapshot, CapabilitySnapshotFormat::Json)
-        .expect("serialize json");
-    let parsed_json = deserialize_capabilities_snapshot(&json, CapabilitySnapshotFormat::Json)
-        .expect("parse json");
-    assert_eq!(parsed_json, snapshot);
-
-    let toml = serialize_capabilities_snapshot(&snapshot, CapabilitySnapshotFormat::Toml)
-        .expect("serialize toml");
-    let parsed_toml = deserialize_capabilities_snapshot(&toml, CapabilitySnapshotFormat::Toml)
-        .expect("parse toml");
-    assert_eq!(parsed_toml, snapshot);
-}
-
-#[test]
-fn capability_snapshots_and_overrides_round_trip_via_files() {
-    let snapshot = sample_capabilities_snapshot();
-    let overrides = sample_capability_overrides();
-    let temp = tempfile::tempdir().unwrap();
-
-    let snapshot_path = temp.path().join("capabilities.toml");
-    write_capabilities_snapshot(&snapshot_path, &snapshot, None).unwrap();
-    let loaded_snapshot = read_capabilities_snapshot(&snapshot_path, None).unwrap();
-    assert_eq!(loaded_snapshot, snapshot);
-
-    let overrides_path = temp.path().join("overrides.json");
-    write_capability_overrides(&overrides_path, &overrides, None).unwrap();
-    let loaded_overrides = read_capability_overrides(&overrides_path, None).unwrap();
-    assert_eq!(loaded_overrides, overrides);
-}
-
-#[test]
-fn capability_snapshot_match_checks_fingerprint() {
-    let temp = tempfile::tempdir().unwrap();
-    let script = "#!/bin/bash\necho ok";
-    let binary = write_fake_codex(temp.path(), script);
-    let cache_key = capability_cache_key(&binary);
-    let fingerprint = current_fingerprint(&cache_key);
-
-    let snapshot = CodexCapabilities {
-        cache_key: cache_key.clone(),
-        fingerprint: fingerprint.clone(),
-        version: None,
-        features: CodexFeatureFlags::default(),
-        probe_plan: CapabilityProbePlan::default(),
-        collected_at: SystemTime::UNIX_EPOCH,
-    };
-
-    assert!(capability_snapshot_matches_binary(&snapshot, &binary));
-    let mut missing_fingerprint = snapshot.clone();
-    missing_fingerprint.fingerprint = None;
-    assert!(!capability_snapshot_matches_binary(
-        &missing_fingerprint,
-        &binary
-    ));
-
-    std_fs::write(&binary, "#!/bin/bash\necho changed").unwrap();
-    let mut perms = std_fs::metadata(&binary).unwrap().permissions();
-    perms.set_mode(0o755);
-    std_fs::set_permissions(&binary, perms).unwrap();
-
-    assert!(!capability_snapshot_matches_binary(&snapshot, &binary));
-}
-
-#[test]
-fn capability_cache_entries_exposes_cache_state() {
-    let _guard = env_guard();
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let binary = write_fake_codex(temp.path(), "#!/bin/bash\necho ok");
-    let cache_key = capability_cache_key(&binary);
-    let fingerprint = current_fingerprint(&cache_key);
-
-    let snapshot = CodexCapabilities {
-        cache_key: cache_key.clone(),
-        fingerprint: fingerprint.clone(),
-        version: Some(version::parse_version_output("codex 0.0.1")),
-        features: CodexFeatureFlags {
-            supports_features_list: true,
-            supports_output_schema: true,
-            supports_add_dir: false,
-            supports_mcp_login: false,
-        },
-        probe_plan: CapabilityProbePlan {
-            steps: vec![CapabilityProbeStep::VersionFlag],
-        },
-        collected_at: SystemTime::UNIX_EPOCH,
-    };
-
-    update_capability_cache(snapshot.clone());
-
-    let entries = capability_cache_entries();
-    assert!(entries.iter().any(|entry| entry.cache_key == cache_key));
-
-    let fetched = capability_cache_entry(&binary).expect("expected cache entry");
-    assert_eq!(fetched.cache_key, cache_key);
-    assert!(clear_capability_cache_entry(&binary));
-    assert!(capability_cache_entry(&binary).is_none());
-    assert!(capability_cache_entries().is_empty());
-    clear_capability_cache();
-}
-
-#[test]
-fn capability_ttl_decision_reuses_fresh_snapshot() {
-    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(10);
-    let snapshot = capability_snapshot_with_metadata(
-        collected_at,
-        Some(BinaryFingerprint {
-            canonical_path: Some(PathBuf::from("/tmp/codex")),
-            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(1)),
-            len: Some(123),
-        }),
-    );
-
-    let decision = capability_cache_ttl_decision(
-        Some(&snapshot),
-        Duration::from_secs(300),
-        SystemTime::UNIX_EPOCH + Duration::from_secs(100),
-    );
-    assert!(!decision.should_probe);
-    assert_eq!(decision.policy, CapabilityCachePolicy::PreferCache);
-}
-
-#[test]
-fn capability_ttl_decision_refreshes_after_ttl_with_fingerprint() {
-    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(1);
-    let snapshot = capability_snapshot_with_metadata(
-        collected_at,
-        Some(BinaryFingerprint {
-            canonical_path: Some(PathBuf::from("/tmp/codex")),
-            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(1)),
-            len: Some(321),
-        }),
-    );
-
-    let decision = capability_cache_ttl_decision(
-        Some(&snapshot),
-        Duration::from_secs(5),
-        SystemTime::UNIX_EPOCH + Duration::from_secs(10),
-    );
-    assert!(decision.should_probe);
-    assert_eq!(decision.policy, CapabilityCachePolicy::Refresh);
-}
-
-#[test]
-fn capability_ttl_decision_bypasses_when_metadata_missing() {
-    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(2);
-    let snapshot = capability_snapshot_with_metadata(collected_at, None);
-
-    let decision = capability_cache_ttl_decision(
-        Some(&snapshot),
-        Duration::from_secs(5),
-        SystemTime::UNIX_EPOCH + Duration::from_secs(10),
-    );
-    assert!(decision.should_probe);
-    assert_eq!(decision.policy, CapabilityCachePolicy::Bypass);
-}
-
-#[tokio::test]
-async fn probe_reprobes_when_metadata_missing() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let binary = temp.path().join("missing_codex");
-    let cache_key = capability_cache_key(&binary);
-
-    {
-        let mut cache = capability_cache().lock().unwrap();
-        cache.insert(
-            cache_key.clone(),
-            CodexCapabilities {
-                cache_key: cache_key.clone(),
-                fingerprint: None,
-                version: Some(version::parse_version_output("codex 9.9.9")),
-                features: CodexFeatureFlags {
-                    supports_features_list: true,
-                    supports_output_schema: true,
-                    supports_add_dir: true,
-                    supports_mcp_login: true,
-                },
-                probe_plan: CapabilityProbePlan::default(),
-                collected_at: SystemTime::UNIX_EPOCH,
-            },
-        );
-    }
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(1))
-        .build();
-
-    let capabilities = client.probe_capabilities().await;
-    assert!(!capabilities.features.supports_output_schema);
-    assert!(capabilities
-        .probe_plan
-        .steps
-        .contains(&CapabilityProbeStep::VersionFlag));
-
-    clear_capability_cache();
-}
-
-#[tokio::test]
-async fn probe_refresh_policy_forces_new_snapshot() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("probe.log");
-    let script = format!(
-        r#"#!/bin/bash
-echo "$@" >> "{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{{"features":["output_schema"]}}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let first = client.probe_capabilities().await;
-    assert!(first.features.supports_output_schema);
-    let first_lines = std_fs::read_to_string(&log_path).unwrap().lines().count();
-    assert!(first_lines >= 2);
-
-    let refreshed = client
-        .probe_capabilities_with_policy(CapabilityCachePolicy::Refresh)
-        .await;
-    assert!(refreshed.features.supports_output_schema);
-    let refreshed_lines = std_fs::read_to_string(&log_path).unwrap().lines().count();
-    assert!(
-        refreshed_lines > first_lines,
-        "expected refresh policy to re-run probes"
-    );
-    clear_capability_cache();
-}
-
-#[tokio::test]
-async fn probe_bypass_policy_skips_cache_writes() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let script = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":["output_schema"]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema"
-fi
-"#;
-    let binary = write_fake_codex(temp.path(), script);
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let capabilities = client
-        .probe_capabilities_with_policy(CapabilityCachePolicy::Bypass)
-        .await;
-    assert!(capabilities.features.supports_output_schema);
-    assert!(capability_cache_entry(&binary).is_none());
-    clear_capability_cache();
-}
-
-#[test]
-fn parses_features_from_json_and_text() {
-    let json = r#"{"features":["output_schema","add_dir"],"mcp_login":true}"#;
-    let parsed_json = version::parse_features_from_json(json).unwrap();
-    assert!(parsed_json.supports_output_schema);
-    assert!(parsed_json.supports_add_dir);
-    assert!(parsed_json.supports_mcp_login);
-
-    let text = "Features: output-schema add-dir login --mcp";
-    let parsed_text = version::parse_features_from_text(text);
-    assert!(parsed_text.supports_output_schema);
-    assert!(parsed_text.supports_add_dir);
-    assert!(parsed_text.supports_mcp_login);
-}
-
-#[test]
-fn parses_feature_list_json_and_text_tables() {
-    let json = r#"{"features":[{"name":"json-stream","stage":"stable","enabled":true,"notes":"keep"},{"name":"cloud-exec","stage":"experimental","enabled":false}]}"#;
-    let (json_features, json_format) = version::parse_feature_list_output(json, true).unwrap();
-    assert_eq!(json_format, FeaturesListFormat::Json);
-    assert_eq!(json_features.len(), 2);
-    assert_eq!(json_features[0].name, "json-stream");
-    assert_eq!(json_features[0].stage, Some(CodexFeatureStage::Stable));
-    assert!(json_features[0].enabled);
-    assert!(json_features[0].extra.contains_key("notes"));
-    assert_eq!(
-        json_features[1].stage,
-        Some(CodexFeatureStage::Experimental)
-    );
-    assert!(!json_features[1].enabled);
-
-    let text = r#"
-Feature   Stage         Enabled
-json-stream stable      true
-	cloud-exec experimental false
-	"#;
-    let (text_features, text_format) = version::parse_feature_list_output(text, false).unwrap();
-    assert_eq!(text_format, FeaturesListFormat::Text);
-    assert_eq!(text_features.len(), 2);
-    assert_eq!(
-        text_features[1].stage,
-        Some(CodexFeatureStage::Experimental)
-    );
-    assert!(!text_features[1].enabled);
-
-    let (fallback_features, fallback_format) =
-        version::parse_feature_list_output(text, true).unwrap();
-    assert_eq!(fallback_format, FeaturesListFormat::Text);
-    assert_eq!(fallback_features.len(), 2);
-}
-
-#[test]
-fn parses_help_output_flags() {
-    let help =
-        "Usage: codex --output-schema ... add-dir ... login --mcp. See `codex features list`.";
-    let parsed = version::parse_help_output(help);
-    assert!(parsed.supports_output_schema);
-    assert!(parsed.supports_add_dir);
-    assert!(parsed.supports_mcp_login);
-    assert!(parsed.supports_features_list);
-}
-
-#[test]
-fn capability_guard_reports_detected_support() {
-    let flags = CodexFeatureFlags {
-        supports_features_list: true,
-        supports_output_schema: true,
-        supports_add_dir: true,
-        supports_mcp_login: true,
-    };
-    let capabilities = capabilities_with_feature_flags(flags);
-
-    let output_schema = capabilities.guard_output_schema();
-    assert_eq!(output_schema.support, CapabilitySupport::Supported);
-    assert!(output_schema.is_supported());
-
-    let add_dir = capabilities.guard_add_dir();
-    assert_eq!(add_dir.support, CapabilitySupport::Supported);
-    assert!(add_dir.is_supported());
-
-    let mcp_login = capabilities.guard_mcp_login();
-    assert_eq!(mcp_login.support, CapabilitySupport::Supported);
-
-    let features_list = capabilities.guard_features_list();
-    assert_eq!(features_list.support, CapabilitySupport::Supported);
-}
-
-#[test]
-fn capability_guard_marks_absent_feature_as_unsupported() {
-    let flags = CodexFeatureFlags {
-        supports_features_list: true,
-        supports_output_schema: false,
-        supports_add_dir: false,
-        supports_mcp_login: false,
-    };
-    let capabilities = capabilities_with_feature_flags(flags);
-
-    let output_schema = capabilities.guard_output_schema();
-    assert_eq!(output_schema.support, CapabilitySupport::Unsupported);
-    assert!(!output_schema.is_supported());
-    assert!(output_schema
-        .notes
-        .iter()
-        .any(|note| note.contains("features list")));
-
-    let mcp_login = capabilities.guard_mcp_login();
-    assert_eq!(mcp_login.support, CapabilitySupport::Unsupported);
-}
-
-#[test]
-fn capability_guard_returns_unknown_without_feature_list() {
-    let capabilities = capabilities_with_feature_flags(CodexFeatureFlags::default());
-
-    let add_dir = capabilities.guard_add_dir();
-    assert_eq!(add_dir.support, CapabilitySupport::Unknown);
-    assert!(add_dir.is_unknown());
-    assert!(add_dir
-        .notes
-        .iter()
-        .any(|note| note.contains("unknown") || note.contains("unavailable")));
-
-    let features_list = capabilities.guard_features_list();
-    assert_eq!(features_list.support, CapabilitySupport::Unknown);
-}
-
-#[tokio::test]
-async fn capability_snapshot_short_circuits_probes() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("probe.log");
-    let script = format!(
-        r#"#!/bin/bash
-echo "$@" >> "{log}"
-exit 99
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-
-    let snapshot = CodexCapabilities {
-        cache_key: CapabilityCacheKey {
-            binary_path: PathBuf::from("codex"),
-        },
-        fingerprint: None,
-        version: Some(version::parse_version_output("codex 9.9.9-custom")),
-        features: CodexFeatureFlags {
-            supports_features_list: true,
-            supports_output_schema: true,
-            supports_add_dir: false,
-            supports_mcp_login: true,
-        },
-        probe_plan: CapabilityProbePlan::default(),
-        collected_at: SystemTime::now(),
-    };
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .capability_snapshot(snapshot)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let capabilities = client.probe_capabilities().await;
-    assert_eq!(
-        capabilities.cache_key.binary_path,
-        std_fs::canonicalize(&binary).unwrap()
-    );
-    assert!(capabilities.fingerprint.is_some());
-    assert!(capabilities.features.supports_output_schema);
-    assert!(capabilities.features.supports_mcp_login);
-    assert_eq!(
-        capabilities.version.as_ref().and_then(|v| v.semantic),
-        Some((9, 9, 9))
-    );
-    assert!(capabilities
-        .probe_plan
-        .steps
-        .contains(&CapabilityProbeStep::ManualOverride));
-    assert!(!log_path.exists());
-}
-
-#[tokio::test]
-async fn capability_feature_overrides_apply_to_cached_entries() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let script = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":[]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "features list"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex exec"
-fi
-"#;
-    let binary = write_fake_codex(temp.path(), script);
-
-    let base_client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-    let base_capabilities = base_client.probe_capabilities().await;
-    assert!(base_capabilities.features.supports_features_list);
-    assert!(!base_capabilities.features.supports_output_schema);
-
-    let overrides = CapabilityFeatureOverrides::enabling(CodexFeatureFlags {
-        supports_features_list: false,
-        supports_output_schema: true,
-        supports_add_dir: false,
-        supports_mcp_login: true,
-    });
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .capability_feature_overrides(overrides)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let capabilities = client.probe_capabilities().await;
-    assert!(capabilities.features.supports_output_schema);
-    assert!(capabilities.features.supports_mcp_login);
-    assert!(capabilities
-        .probe_plan
-        .steps
-        .contains(&CapabilityProbeStep::ManualOverride));
-    assert_eq!(
-        capabilities.guard_output_schema().support,
-        CapabilitySupport::Supported
-    );
-}
-
-#[tokio::test]
-async fn capability_version_override_replaces_probe_version() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let script = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 0.1.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":["add_dir"]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "add_dir"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex add-dir"
-fi
-	"#;
-    let binary = write_fake_codex(temp.path(), script);
-    let version_override = version::parse_version_output("codex 9.9.9-nightly (commit beefcafe)");
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .capability_version_override(version_override)
-        .build();
-
-    let capabilities = client.probe_capabilities().await;
-    assert_eq!(
-        capabilities.version.as_ref().and_then(|v| v.semantic),
-        Some((9, 9, 9))
-    );
-    assert!(matches!(
-        capabilities.version.as_ref().map(|v| v.channel),
-        Some(CodexReleaseChannel::Nightly)
-    ));
-    assert!(capabilities.features.supports_add_dir);
-    assert!(capabilities
-        .probe_plan
-        .steps
-        .contains(&CapabilityProbeStep::ManualOverride));
-    assert_eq!(
-        capabilities.guard_add_dir().support,
-        CapabilitySupport::Supported
-    );
-}
-
-#[tokio::test]
-async fn exec_applies_guarded_flags_when_supported() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("exec.log");
-    let script = format!(
-        r#"#!/bin/bash
-log="{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.2.3"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{{"features":["output_schema","add_dir","mcp_login"]}}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema add_dir login --mcp"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex --output-schema add-dir login --mcp"
-elif [[ "$1" == "exec" ]]; then
-  echo "$@" >> "$log"
-  echo "ok"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .add_dir("src")
-        .output_schema(true)
-        .quiet(true)
-        .mirror_stdout(false)
-        .build();
-
-    let response = client.send_prompt("hello").await.unwrap();
-    assert_eq!(response.trim(), "ok");
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(logged.contains("--add-dir"));
-    assert!(logged.contains("src"));
-    assert!(logged.contains("--output-schema"));
-}
-
-#[tokio::test]
-async fn exec_skips_guarded_flags_when_unknown() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("exec.log");
-    let script = format!(
-        r#"#!/bin/bash
-log="{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 0.9.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo "feature list unavailable" >&2
-  exit 1
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "feature list unavailable" >&2
-  exit 1
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex exec"
-elif [[ "$1" == "exec" ]]; then
-  echo "$@" >> "$log"
-  echo "ok"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .add_dir("src")
-        .output_schema(true)
-        .quiet(true)
-        .mirror_stdout(false)
-        .build();
-
-    let response = client.send_prompt("hello").await.unwrap();
-    assert_eq!(response.trim(), "ok");
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(!logged.contains("--add-dir"));
-    assert!(!logged.contains("--output-schema"));
-}
-
-#[tokio::test]
-async fn mcp_login_skips_when_unsupported() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("login.log");
-    let script = format!(
-        r#"#!/bin/bash
-log="{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{{"features":["output_schema","add_dir"]}}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema add-dir"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex exec"
-elif [[ "$1" == "login" ]]; then
-  echo "$@" >> "$log"
-  echo "login invoked"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let login = client.spawn_mcp_login_process().await.unwrap();
-    assert!(login.is_none());
-    assert!(!log_path.exists());
-}
-
-#[tokio::test]
-async fn mcp_login_runs_when_supported() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("login.log");
-    let script = format!(
-        r#"#!/bin/bash
-log="{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 2.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{{"features":["output_schema","add_dir"],"mcp_login":true}}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema add_dir login --mcp"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex --output-schema add-dir login --mcp"
-elif [[ "$1" == "login" ]]; then
-  echo "$@" >> "$log"
-  echo "login invoked"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let login = client
-        .spawn_mcp_login_process()
-        .await
-        .unwrap()
-        .expect("expected login child");
-    let output = login.wait_with_output().await.unwrap();
-    assert!(output.status.success());
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(logged.contains("login --mcp"));
-}
-
-#[tokio::test]
-async fn probe_capabilities_caches_and_invalidates() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let script_v1 = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.2.3-beta (commit cafe123)"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":["output_schema","add_dir","mcp_login"]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema add-dir login --mcp"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex --output-schema add-dir login --mcp"
-fi
-"#;
-    let binary = write_fake_codex(temp.path(), script_v1);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let first = client.probe_capabilities().await;
-    assert_eq!(
-        first.version.as_ref().and_then(|v| v.semantic),
-        Some((1, 2, 3))
-    );
-    assert_eq!(
-        first.version.as_ref().map(|v| v.channel),
-        Some(CodexReleaseChannel::Beta)
-    );
-    assert_eq!(
-        first.version.as_ref().and_then(|v| v.commit.as_deref()),
-        Some("cafe123")
-    );
-    assert!(first.features.supports_features_list);
-    assert!(first.features.supports_output_schema);
-    assert!(first.features.supports_add_dir);
-    assert!(first.features.supports_mcp_login);
-
-    let cached = client.probe_capabilities().await;
-    assert_eq!(cached, first);
-
-    let script_v2 = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 2.0.0 (commit deadbeef)"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":["add_dir"]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "add-dir"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex add-dir"
-fi
-"#;
-    std_fs::write(&binary, script_v2).unwrap();
-    let mut perms = std_fs::metadata(&binary).unwrap().permissions();
-    perms.set_mode(0o755);
-    std_fs::set_permissions(&binary, perms).unwrap();
-
-    let refreshed = client.probe_capabilities().await;
-    assert_ne!(refreshed.version, first.version);
-    assert_eq!(
-        refreshed.version.as_ref().and_then(|v| v.semantic),
-        Some((2, 0, 0))
-    );
-    assert!(refreshed.features.supports_features_list);
-    assert!(refreshed.features.supports_add_dir);
-    assert!(!refreshed.features.supports_output_schema);
-    assert!(!refreshed.features.supports_mcp_login);
-    clear_capability_cache();
-}
-
-#[test]
-fn reasoning_config_by_model() {
-    assert_eq!(
-        reasoning_config_for(Some("gpt-5")).unwrap(),
-        DEFAULT_REASONING_CONFIG_GPT5
-    );
-    assert_eq!(
-        reasoning_config_for(Some("gpt-5.1-codex-max")).unwrap(),
-        DEFAULT_REASONING_CONFIG_GPT5_1
-    );
-    assert_eq!(
-        reasoning_config_for(Some("gpt-5-codex")).unwrap(),
-        DEFAULT_REASONING_CONFIG_GPT5_CODEX
-    );
-    assert!(reasoning_config_for(None).is_none());
-    assert!(reasoning_config_for(Some("gpt-4.1-mini")).is_none());
-}
-
-#[test]
-fn resolve_cli_overrides_respects_reasoning_defaults() {
-    let builder = CliOverrides::default();
-    let patch = CliOverridesPatch::default();
-
-    let resolved = resolve_cli_overrides(&builder, &patch, Some("gpt-5"));
-    let keys: Vec<_> = resolved
-        .config_overrides
-        .iter()
-        .map(|override_| override_.key.as_str())
-        .collect();
-    assert!(keys.contains(&"model_reasoning_effort"));
-    assert!(keys.contains(&"model_reasoning_summary"));
-    assert!(keys.contains(&"model_verbosity"));
-
-    let resolved_without_model = resolve_cli_overrides(&builder, &patch, None);
-    assert!(resolved_without_model.config_overrides.is_empty());
-}
-
-#[test]
-fn explicit_reasoning_overrides_disable_defaults() {
-    let mut builder = CliOverrides::default();
-    builder
-        .config_overrides
-        .push(ConfigOverride::new("model_reasoning_effort", "high"));
-
-    let resolved = resolve_cli_overrides(&builder, &CliOverridesPatch::default(), Some("gpt-5"));
-    assert_eq!(resolved.config_overrides.len(), 1);
-    assert_eq!(resolved.config_overrides[0].value, "high");
-}
-
-#[test]
-fn request_can_disable_auto_reasoning_defaults() {
-    let builder = CliOverrides::default();
-    let patch = CliOverridesPatch {
-        auto_reasoning_defaults: Some(false),
-        ..Default::default()
-    };
-
-    let resolved = resolve_cli_overrides(&builder, &patch, Some("gpt-5"));
-    assert!(resolved.config_overrides.is_empty());
-}
-
-#[test]
-fn request_config_overrides_follow_builder_order() {
-    let mut builder_overrides = CliOverrides {
-        auto_reasoning_defaults: false,
-        ..Default::default()
-    };
-    builder_overrides
-        .config_overrides
-        .push(ConfigOverride::new("foo", "bar"));
-
-    let mut patch = CliOverridesPatch::default();
-    patch
-        .config_overrides
-        .push(ConfigOverride::new("foo", "baz"));
-
-    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
-    let values: Vec<_> = resolved
-        .config_overrides
-        .iter()
-        .map(|override_| override_.value.as_str())
-        .collect();
-    assert_eq!(values, vec!["bar", "baz"]);
-}
-
-#[test]
-fn request_search_override_can_disable_builder_flag() {
-    let builder_overrides = CliOverrides {
-        search: FlagState::Enable,
-        ..Default::default()
-    };
-
-    let patch = CliOverridesPatch {
-        search: FlagState::Disable,
-        ..Default::default()
-    };
-
-    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
-    let args = cli_override_args(&resolved, true);
-    let args: Vec<_> = args
-        .iter()
-        .map(|arg| arg.to_string_lossy().into_owned())
-        .collect();
-    assert!(!args.contains(&"--search".to_string()));
-}
-
-#[test]
-fn request_profile_override_replaces_builder_value() {
-    let builder_overrides = CliOverrides {
-        profile: Some("builder".to_string()),
-        ..Default::default()
-    };
-
-    let patch = CliOverridesPatch {
-        profile: Some("request".to_string()),
-        ..Default::default()
-    };
-
-    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
-    let args: Vec<_> = cli_override_args(&resolved, true)
-        .iter()
-        .map(|arg| arg.to_string_lossy().into_owned())
-        .collect();
-    assert!(args.windows(2).any(|window| {
-        window.first().map(String::as_str) == Some("--profile")
-            && window.get(1).map(String::as_str) == Some("request")
-    }));
-    assert!(!args.contains(&"builder".to_string()));
-}
-
-#[test]
-fn request_oss_override_can_disable_builder_flag() {
-    let builder_overrides = CliOverrides {
-        oss: FlagState::Enable,
-        ..Default::default()
-    };
-
-    let resolved = resolve_cli_overrides(&builder_overrides, &CliOverridesPatch::default(), None);
-    let args: Vec<_> = cli_override_args(&resolved, true)
-        .iter()
-        .map(|arg| arg.to_string_lossy().into_owned())
-        .collect();
-    assert!(args.contains(&"--oss".to_string()));
-
-    let patch = CliOverridesPatch {
-        oss: FlagState::Disable,
-        ..Default::default()
-    };
-    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
-    let args: Vec<_> = cli_override_args(&resolved, true)
-        .iter()
-        .map(|arg| arg.to_string_lossy().into_owned())
-        .collect();
-    assert!(!args.contains(&"--oss".to_string()));
-}
-
-#[test]
-fn feature_toggles_merge_builder_and_request() {
-    let mut builder_overrides = CliOverrides::default();
-    builder_overrides
-        .feature_toggles
-        .enable
-        .push("builder-enable".to_string());
-    builder_overrides
-        .feature_toggles
-        .disable
-        .push("builder-disable".to_string());
-
-    let mut patch = CliOverridesPatch::default();
-    patch
-        .feature_toggles
-        .enable
-        .push("request-enable".to_string());
-    patch
-        .feature_toggles
-        .disable
-        .push("request-disable".to_string());
-
-    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
-    let args: Vec<_> = cli_override_args(&resolved, true)
-        .iter()
-        .map(|arg| arg.to_string_lossy().into_owned())
-        .collect();
-
-    assert!(args.windows(2).any(|window| {
-        window.first().map(String::as_str) == Some("--enable")
-            && window.get(1).map(String::as_str) == Some("builder-enable")
-    }));
-    assert!(args.windows(2).any(|window| {
-        window.first().map(String::as_str) == Some("--enable")
-            && window.get(1).map(String::as_str) == Some("request-enable")
-    }));
-    assert!(args.windows(2).any(|window| {
-        window.first().map(String::as_str) == Some("--disable")
-            && window.get(1).map(String::as_str) == Some("builder-disable")
-    }));
-    assert!(args.windows(2).any(|window| {
-        window.first().map(String::as_str) == Some("--disable")
-            && window.get(1).map(String::as_str) == Some("request-disable")
-    }));
-}
-
-#[test]
-fn cli_override_args_apply_safety_precedence() {
-    let mut resolved = ResolvedCliOverrides {
-        config_overrides: Vec::new(),
-        feature_toggles: FeatureToggles::default(),
-        approval_policy: None,
-        sandbox_mode: None,
-        safety_override: SafetyOverride::FullAuto,
-        profile: None,
-        cd: None,
-        local_provider: None,
-        oss: false,
-        search: FlagState::Enable,
-    };
-    let args = cli_override_args(&resolved, true);
-    let args: Vec<_> = args
-        .iter()
-        .map(|value| value.to_string_lossy().into_owned())
-        .collect();
-    assert!(args.contains(&"--full-auto".to_string()));
-    assert!(args.contains(&"--search".to_string()));
-    assert!(!args.contains(&"--ask-for-approval".to_string()));
-
-    resolved.approval_policy = Some(ApprovalPolicy::OnRequest);
-    let args_with_policy = cli_override_args(&resolved, true);
-    let args_with_policy: Vec<_> = args_with_policy
-        .iter()
-        .map(|value| value.to_string_lossy().into_owned())
-        .collect();
-    assert!(!args_with_policy.contains(&"--full-auto".to_string()));
-    assert!(args_with_policy.contains(&"--ask-for-approval".to_string()));
-
-    let resolved = ResolvedCliOverrides {
-        config_overrides: vec![ConfigOverride::new("foo", "bar")],
-        feature_toggles: FeatureToggles::default(),
-        approval_policy: Some(ApprovalPolicy::OnRequest),
-        sandbox_mode: Some(SandboxMode::WorkspaceWrite),
-        safety_override: SafetyOverride::DangerouslyBypass,
-        profile: Some("team".to_string()),
-        cd: Some(PathBuf::from("/tmp/worktree")),
-        local_provider: Some(LocalProvider::Ollama),
-        oss: false,
-        search: FlagState::Enable,
-    };
-    let args = cli_override_args(&resolved, true);
-    let args: Vec<_> = args
-        .iter()
-        .map(|value| value.to_string_lossy().into_owned())
-        .collect();
-    assert!(args.contains(&"--config".to_string()));
-    assert!(args.contains(&"foo=bar".to_string()));
-    assert!(args.contains(&"--dangerously-bypass-approvals-and-sandbox".to_string()));
-    assert!(args.contains(&"--profile".to_string()));
-    assert!(args.contains(&"team".to_string()));
-    assert!(args.contains(&"--cd".to_string()));
-    assert!(args.contains(&"/tmp/worktree".to_string()));
-    assert!(args.contains(&"--local-provider".to_string()));
-    assert!(args.contains(&"ollama".to_string()));
-    assert!(args.contains(&"--search".to_string()));
-    assert!(!args.contains(&"--ask-for-approval".to_string()));
-    assert!(!args.contains(&"--sandbox".to_string()));
-
-    let args_without_search = cli_override_args(&resolved, false);
-    let args_without_search: Vec<_> = args_without_search
-        .iter()
-        .map(|value| value.to_string_lossy().into_owned())
-        .collect();
-    assert!(!args_without_search.contains(&"--search".to_string()));
-}
-
-#[tokio::test]
-async fn exec_applies_cli_overrides_and_request_patch() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("exec.log");
-    let builder_cd = temp.path().join("builder-cd");
-    let request_cd = temp.path().join("request-cd");
-    let script = format!(
-        r#"#!/bin/bash
-echo "$@" >> "{log}"
-if [[ "$1" == "exec" ]]; then
-  echo "ok"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .mirror_stdout(false)
-        .quiet(true)
-        .auto_reasoning_defaults(false)
-        .config_override("foo", "bar")
-        .reasoning_summary(ReasoningSummary::Concise)
-        .approval_policy(ApprovalPolicy::OnRequest)
-        .sandbox_mode(SandboxMode::WorkspaceWrite)
-        .cd(&builder_cd)
-        .local_provider(LocalProvider::Custom)
-        .oss(true)
-        .enable_feature("builder-on")
-        .disable_feature("builder-off")
-        .search(true)
-        .build();
-
-    let mut request = ExecRequest::new("list flags")
-        .config_override("extra", "value")
-        .oss(false)
-        .enable_feature("request-on")
-        .disable_feature("request-off")
-        .search(false);
-    request.overrides.cd = Some(request_cd.clone());
-    request.overrides.safety_override = Some(SafetyOverride::DangerouslyBypass);
-
-    let response = client.send_prompt_with(request).await.unwrap();
-    assert_eq!(response.trim(), "ok");
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(logged.contains("--config"));
-    assert!(logged.contains("foo=bar"));
-    assert!(logged.contains("extra=value"));
-    assert!(logged.contains("model_reasoning_summary=concise"));
-    assert!(logged.contains("--dangerously-bypass-approvals-and-sandbox"));
-    assert!(logged.contains(&request_cd.display().to_string()));
-    assert!(!logged.contains(&builder_cd.display().to_string()));
-    assert!(logged.contains("--local-provider"));
-    assert!(logged.contains("custom"));
-    assert!(logged.contains("--enable"));
-    assert!(logged.contains("builder-on"));
-    assert!(logged.contains("request-on"));
-    assert!(logged.contains("--disable"));
-    assert!(logged.contains("builder-off"));
-    assert!(logged.contains("request-off"));
-    assert!(!logged.contains("--oss"));
-    assert!(!logged.contains("--ask-for-approval"));
-    assert!(!logged.contains("--sandbox"));
-    assert!(!logged.contains("--search"));
-}
-
-#[tokio::test]
-async fn resume_applies_search_and_selector_overrides() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("resume.log");
-    let builder_cd = temp.path().join("builder-cd");
-    let request_cd = temp.path().join("request-cd");
-    let script = format!(
-        r#"#!/bin/bash
-echo "$@" >> "{log}"
-if [[ "$1" == "exec" ]]; then
-  echo '{{"type":"thread.started","thread_id":"thread-1"}}'
-  echo '{{"type":"turn.started","thread_id":"thread-1","turn_id":"turn-1"}}'
-  echo '{{"type":"turn.completed","thread_id":"thread-1","turn_id":"turn-1"}}'
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .mirror_stdout(false)
-        .quiet(true)
-        .config_override("resume_hint", "enabled")
-        .approval_policy(ApprovalPolicy::OnRequest)
-        .sandbox_mode(SandboxMode::WorkspaceWrite)
-        .local_provider(LocalProvider::Ollama)
-        .cd(&builder_cd)
-        .search(true)
-        .build();
-
-    let request_last = ResumeRequest::last().prompt("continue");
-    let stream = client.stream_resume(request_last).await.unwrap();
-    let events: Vec<_> = stream.events.collect().await;
-    assert_eq!(events.len(), 3);
-    stream.completion.await.unwrap();
-
-    let mut request_all = ResumeRequest::all().prompt("summarize");
-    request_all.overrides.search = FlagState::Disable;
-    request_all.overrides.safety_override = Some(SafetyOverride::DangerouslyBypass);
-    request_all.overrides.cd = Some(request_cd.clone());
-    let stream_all = client.stream_resume(request_all).await.unwrap();
-    let _ = stream_all.events.collect::<Vec<_>>().await;
-    stream_all.completion.await.unwrap();
-
-    let logged: Vec<_> = std_fs::read_to_string(&log_path)
-        .unwrap()
-        .lines()
-        .map(str::to_string)
-        .collect();
-    assert!(logged.len() >= 2);
-
-    assert!(logged[0].contains("--last"));
-    assert!(logged[0].contains("--search"));
-    assert!(logged[0].contains("resume_hint=enabled"));
-    assert!(logged[0].contains("--ask-for-approval"));
-    assert!(logged[0].contains("--sandbox"));
-    assert!(logged[0].contains(&builder_cd.display().to_string()));
-    assert!(logged[0].contains("ollama"));
-
-    assert!(logged[1].contains("--all"));
-    assert!(logged[1].contains("--dangerously-bypass-approvals-and-sandbox"));
-    assert!(logged[1].contains(&request_cd.display().to_string()));
-    assert!(!logged[1].contains(&builder_cd.display().to_string()));
-    assert!(!logged[1].contains("--ask-for-approval"));
-    assert!(!logged[1].contains("--sandbox"));
-    assert!(!logged[1].contains("--search"));
-}
-
-#[tokio::test]
-async fn apply_respects_cli_overrides_without_search() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("apply.log");
-    let script = format!(
-        r#"#!/bin/bash
-echo "$@" >> "{log}"
-if [[ "$1" == "apply" ]]; then
-  echo "applied"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .mirror_stdout(false)
-        .quiet(true)
-        .cd(temp.path().join("apply-cd"))
-        .config_override("feature.toggle", "true")
-        .search(true)
-        .build();
-
-    let artifacts = client.apply().await.unwrap();
-    assert_eq!(artifacts.stdout.trim(), "applied");
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(logged.contains("--config"));
-    assert!(logged.contains("feature.toggle=true"));
-    assert!(logged.contains("apply-cd"));
-    assert!(!logged.contains("--search"));
-}
-
-#[test]
-fn color_mode_strings_are_stable() {
-    assert_eq!(ColorMode::Auto.as_str(), "auto");
-    assert_eq!(ColorMode::Always.as_str(), "always");
-    assert_eq!(ColorMode::Never.as_str(), "never");
-}
-
-#[tokio::test]
-async fn auth_helper_uses_app_scoped_home_without_mutating_env() {
-    let _guard = env_guard_async().await;
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("auth.log");
-    let app_home = temp.path().join("app-home");
-    let caller_home = temp.path().join("caller-home");
-    let previous_home = env::var("CODEX_HOME").ok();
-    env::set_var("CODEX_HOME", &caller_home);
-    env::set_var("AUTH_HELPER_LOG", &log_path);
-
-    let script = r#"#!/usr/bin/env bash
-set -e
-echo "args:$*" >> "$AUTH_HELPER_LOG"
-echo "CODEX_HOME=${CODEX_HOME:-missing}" >> "$AUTH_HELPER_LOG"
-if [[ "$1" == "login" && "$2" == "status" ]]; then
-  echo "Logged in using ChatGPT"
-  exit 0
-fi
-echo "Not logged in" >&2
-exit 1
-"#;
-    let binary = write_fake_codex(temp.path(), script);
-    let helper = AuthSessionHelper::with_client(
-        CodexClient::builder()
-            .binary(&binary)
-            .codex_home(&app_home)
-            .build(),
-    );
-
-    let status = helper.status().await.unwrap();
-    assert!(matches!(
-        status,
-        CodexAuthStatus::LoggedIn(CodexAuthMethod::ChatGpt)
-    ));
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(logged.contains("args:login status"));
-    assert!(logged.contains(&format!("CODEX_HOME={}", app_home.display())));
-
-    assert_eq!(
-        env::var("CODEX_HOME").unwrap(),
-        caller_home.display().to_string()
-    );
-
-    env::remove_var("AUTH_HELPER_LOG");
-    if let Some(previous) = previous_home {
-        env::set_var("CODEX_HOME", previous);
-    } else {
-        env::remove_var("CODEX_HOME");
-    }
-}
-
-#[tokio::test]
-async fn ensure_api_key_login_runs_when_logged_out() {
-    let _guard = env_guard_async().await;
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("login.log");
-    let state_path = temp.path().join("api-key-state");
-    let script = format!(
-        r#"#!/usr/bin/env bash
-set -e
-echo "$@" >> "{log}"
-if [[ "$1" == "login" && "$2" == "status" ]]; then
-  if [[ -f "{state}" ]]; then
-echo "Logged in using an API key - sk-already"
-exit 0
-  fi
-  echo "Not logged in" >&2
-  exit 1
-fi
-if [[ "$1" == "login" && "$2" == "--api-key" ]]; then
-  echo "Logged in using an API key - $3" > "{state}"
-  echo "Logged in using an API key - $3"
-  exit 0
-fi
-echo "unexpected args: $*" >&2
-exit 2
-"#,
-        log = log_path.display(),
-        state = state_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let helper = AuthSessionHelper::with_client(
-        CodexClient::builder()
-            .binary(&binary)
-            .codex_home(temp.path().join("app-home"))
-            .build(),
-    );
-
-    let status = helper.ensure_api_key_login("sk-test-key").await.unwrap();
-    match status {
-        CodexAuthStatus::LoggedIn(CodexAuthMethod::ApiKey { masked_key }) => {
-            assert_eq!(masked_key.as_deref(), Some("sk-test-key"));
-        }
-        other => panic!("unexpected status: {other:?}"),
-    }
-
-    let second = helper.ensure_api_key_login("sk-other").await.unwrap();
-    assert!(matches!(
-        second,
-        CodexAuthStatus::LoggedIn(CodexAuthMethod::ApiKey { .. })
-    ));
-
-    let log = std_fs::read_to_string(&log_path).unwrap();
-    assert!(log.contains("login status"));
-    assert!(log.contains("login --api-key sk-test-key"));
-    assert_eq!(
-        log.lines()
-            .filter(|line| line.contains("--api-key"))
-            .count(),
-        1
-    );
-}
-
-#[tokio::test]
-async fn ensure_chatgpt_login_launches_when_needed() {
-    let _guard = env_guard_async().await;
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("chatgpt.log");
-    let state_path = temp.path().join("chatgpt-state");
-    let script = format!(
-        r#"#!/usr/bin/env bash
-set -e
-echo "$@" >> "{log}"
-if [[ "$1" == "login" && "$2" == "status" ]]; then
-  if [[ -f "{state}" ]]; then
-echo "Logged in using ChatGPT"
-exit 0
-  fi
-  echo "Not logged in" >&2
-  exit 1
-fi
-if [[ "$1" == "login" && -z "$2" ]]; then
-  echo "Logged in using ChatGPT" > "{state}"
-  echo "Logged in using ChatGPT"
-  exit 0
-fi
-echo "unknown args: $*" >&2
-exit 2
-"#,
-        log = log_path.display(),
-        state = state_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let helper = AuthSessionHelper::with_client(
-        CodexClient::builder()
-            .binary(&binary)
-            .codex_home(temp.path().join("app-home"))
-            .build(),
-    );
-
-    let child = helper.ensure_chatgpt_login().await.unwrap();
-    let child = child.expect("expected ChatGPT login child");
-    let output = child.wait_with_output().await.unwrap();
-    let stdout = String::from_utf8_lossy(&output.stdout);
-    assert!(stdout.contains("Logged in using ChatGPT"));
-
-    let second = helper.ensure_chatgpt_login().await.unwrap();
-    assert!(second.is_none());
-
-    let log = std_fs::read_to_string(&log_path).unwrap();
-    assert!(log.lines().any(|line| line == "login"));
-    assert_eq!(log.lines().filter(|line| line == &"login").count(), 1);
-}
-
-#[test]
-fn parses_chatgpt_login() {
-    let message = "Logged in using ChatGPT";
-    let parsed = parse_login_success(message);
-    assert!(matches!(
-        parsed,
-        Some(CodexAuthStatus::LoggedIn(CodexAuthMethod::ChatGpt))
-    ));
-}
-
-#[test]
-fn parses_api_key_login() {
-    let message = "Logged in using an API key - sk-1234***abcd";
-    let parsed = parse_login_success(message);
-    match parsed {
-        Some(CodexAuthStatus::LoggedIn(CodexAuthMethod::ApiKey { masked_key })) => {
-            assert_eq!(masked_key.as_deref(), Some("sk-1234***abcd"));
-        }
-        other => panic!("unexpected status: {other:?}"),
-    }
-}
-
-#[test]
-fn parse_login_accepts_unknown_on_success() {
-    let message = "Authenticated";
-    assert!(parse_login_success(message).is_none());
-    let status = CodexAuthStatus::LoggedIn(CodexAuthMethod::Unknown {
-        raw: message.to_string(),
-    });
-    assert!(matches!(
-        status,
-        CodexAuthStatus::LoggedIn(CodexAuthMethod::Unknown { .. })
-    ));
-}
+#[path = "tests/mod.rs"]
+mod modularized;
diff --git a/crates/codex/src/tests/auth_session.rs b/crates/codex/src/tests/auth_session.rs
new file mode 100644
index 0000000..ff4eb1b
--- /dev/null
+++ b/crates/codex/src/tests/auth_session.rs
@@ -0,0 +1,202 @@
+use super::*;
+
+#[tokio::test]
+async fn auth_helper_uses_app_scoped_home_without_mutating_env() {
+    let _guard = env_guard_async().await;
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("auth.log");
+    let app_home = temp.path().join("app-home");
+    let caller_home = temp.path().join("caller-home");
+    let previous_home = env::var("CODEX_HOME").ok();
+    env::set_var("CODEX_HOME", &caller_home);
+    env::set_var("AUTH_HELPER_LOG", &log_path);
+
+    let script = r#"#!/usr/bin/env bash
+set -e
+echo "args:$*" >> "$AUTH_HELPER_LOG"
+echo "CODEX_HOME=${CODEX_HOME:-missing}" >> "$AUTH_HELPER_LOG"
+if [[ "$1" == "login" && "$2" == "status" ]]; then
+  echo "Logged in using ChatGPT"
+  exit 0
+fi
+echo "Not logged in" >&2
+exit 1
+"#;
+    let binary = write_fake_codex(temp.path(), script);
+    let helper = AuthSessionHelper::with_client(
+        CodexClient::builder()
+            .binary(&binary)
+            .codex_home(&app_home)
+            .build(),
+    );
+
+    let status = helper.status().await.unwrap();
+    assert!(matches!(
+        status,
+        CodexAuthStatus::LoggedIn(CodexAuthMethod::ChatGpt)
+    ));
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(logged.contains("args:login status"));
+    assert!(logged.contains(&format!("CODEX_HOME={}", app_home.display())));
+
+    assert_eq!(
+        env::var("CODEX_HOME").unwrap(),
+        caller_home.display().to_string()
+    );
+
+    env::remove_var("AUTH_HELPER_LOG");
+    if let Some(previous) = previous_home {
+        env::set_var("CODEX_HOME", previous);
+    } else {
+        env::remove_var("CODEX_HOME");
+    }
+}
+
+#[tokio::test]
+async fn ensure_api_key_login_runs_when_logged_out() {
+    let _guard = env_guard_async().await;
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("login.log");
+    let state_path = temp.path().join("api-key-state");
+    let script = format!(
+        r#"#!/usr/bin/env bash
+set -e
+echo "$@" >> "{log}"
+if [[ "$1" == "login" && "$2" == "status" ]]; then
+  if [[ -f "{state}" ]]; then
+echo "Logged in using an API key - sk-already"
+exit 0
+  fi
+  echo "Not logged in" >&2
+  exit 1
+fi
+if [[ "$1" == "login" && "$2" == "--api-key" ]]; then
+  echo "Logged in using an API key - $3" > "{state}"
+  echo "Logged in using an API key - $3"
+  exit 0
+fi
+echo "unexpected args: $*" >&2
+exit 2
+"#,
+        log = log_path.display(),
+        state = state_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let helper = AuthSessionHelper::with_client(
+        CodexClient::builder()
+            .binary(&binary)
+            .codex_home(temp.path().join("app-home"))
+            .build(),
+    );
+
+    let status = helper.ensure_api_key_login("sk-test-key").await.unwrap();
+    match status {
+        CodexAuthStatus::LoggedIn(CodexAuthMethod::ApiKey { masked_key }) => {
+            assert_eq!(masked_key.as_deref(), Some("sk-test-key"));
+        }
+        other => panic!("unexpected status: {other:?}"),
+    }
+
+    let second = helper.ensure_api_key_login("sk-other").await.unwrap();
+    assert!(matches!(
+        second,
+        CodexAuthStatus::LoggedIn(CodexAuthMethod::ApiKey { .. })
+    ));
+
+    let log = std_fs::read_to_string(&log_path).unwrap();
+    assert!(log.contains("login status"));
+    assert!(log.contains("login --api-key sk-test-key"));
+    assert_eq!(
+        log.lines()
+            .filter(|line| line.contains("--api-key"))
+            .count(),
+        1
+    );
+}
+
+#[tokio::test]
+async fn ensure_chatgpt_login_launches_when_needed() {
+    let _guard = env_guard_async().await;
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("chatgpt.log");
+    let state_path = temp.path().join("chatgpt-state");
+    let script = format!(
+        r#"#!/usr/bin/env bash
+set -e
+echo "$@" >> "{log}"
+if [[ "$1" == "login" && "$2" == "status" ]]; then
+  if [[ -f "{state}" ]]; then
+echo "Logged in using ChatGPT"
+exit 0
+  fi
+  echo "Not logged in" >&2
+  exit 1
+fi
+if [[ "$1" == "login" && -z "$2" ]]; then
+  echo "Logged in using ChatGPT" > "{state}"
+  echo "Logged in using ChatGPT"
+  exit 0
+fi
+echo "unknown args: $*" >&2
+exit 2
+"#,
+        log = log_path.display(),
+        state = state_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let helper = AuthSessionHelper::with_client(
+        CodexClient::builder()
+            .binary(&binary)
+            .codex_home(temp.path().join("app-home"))
+            .build(),
+    );
+
+    let child = helper.ensure_chatgpt_login().await.unwrap();
+    let child = child.expect("expected ChatGPT login child");
+    let output = child.wait_with_output().await.unwrap();
+    let stdout = String::from_utf8_lossy(&output.stdout);
+    assert!(stdout.contains("Logged in using ChatGPT"));
+
+    let second = helper.ensure_chatgpt_login().await.unwrap();
+    assert!(second.is_none());
+
+    let log = std_fs::read_to_string(&log_path).unwrap();
+    assert!(log.lines().any(|line| line == "login"));
+    assert_eq!(log.lines().filter(|line| line == &"login").count(), 1);
+}
+
+#[test]
+fn parses_chatgpt_login() {
+    let message = "Logged in using ChatGPT";
+    let parsed = parse_login_success(message);
+    assert!(matches!(
+        parsed,
+        Some(CodexAuthStatus::LoggedIn(CodexAuthMethod::ChatGpt))
+    ));
+}
+
+#[test]
+fn parses_api_key_login() {
+    let message = "Logged in using an API key - sk-1234***abcd";
+    let parsed = parse_login_success(message);
+    match parsed {
+        Some(CodexAuthStatus::LoggedIn(CodexAuthMethod::ApiKey { masked_key })) => {
+            assert_eq!(masked_key.as_deref(), Some("sk-1234***abcd"));
+        }
+        other => panic!("unexpected status: {other:?}"),
+    }
+}
+
+#[test]
+fn parse_login_accepts_unknown_on_success() {
+    let message = "Authenticated";
+    assert!(parse_login_success(message).is_none());
+    let status = CodexAuthStatus::LoggedIn(CodexAuthMethod::Unknown {
+        raw: message.to_string(),
+    });
+    assert!(matches!(
+        status,
+        CodexAuthStatus::LoggedIn(CodexAuthMethod::Unknown { .. })
+    ));
+}
diff --git a/crates/codex/src/tests/builder_env_home.rs b/crates/codex/src/tests/builder_env_home.rs
new file mode 100644
index 0000000..3e03700
--- /dev/null
+++ b/crates/codex/src/tests/builder_env_home.rs
@@ -0,0 +1,480 @@
+use super::*;
+
+#[test]
+fn builder_defaults_are_sane() {
+    let builder = CodexClient::builder();
+    assert!(builder.model.is_none());
+    assert_eq!(builder.timeout, DEFAULT_TIMEOUT);
+    assert_eq!(builder.color_mode, ColorMode::Never);
+    assert!(builder.codex_home.is_none());
+    assert!(builder.create_home_dirs);
+    assert!(builder.working_dir.is_none());
+    assert!(builder.images.is_empty());
+    assert!(!builder.json_output);
+    assert!(!builder.quiet);
+    assert!(builder.json_event_log.is_none());
+    assert!(builder.cli_overrides.config_overrides.is_empty());
+    assert!(!builder.cli_overrides.reasoning.has_overrides());
+    assert!(builder.cli_overrides.approval_policy.is_none());
+    assert!(builder.cli_overrides.sandbox_mode.is_none());
+    assert_eq!(
+        builder.cli_overrides.safety_override,
+        SafetyOverride::Inherit
+    );
+    assert!(builder.cli_overrides.cd.is_none());
+    assert!(builder.cli_overrides.local_provider.is_none());
+    assert_eq!(builder.cli_overrides.search, FlagState::Inherit);
+    assert!(builder.cli_overrides.auto_reasoning_defaults);
+    assert!(builder.capability_overrides.is_empty());
+    assert_eq!(
+        builder.capability_cache_policy,
+        CapabilityCachePolicy::PreferCache
+    );
+}
+
+#[test]
+fn builder_collects_images() {
+    let client = CodexClient::builder()
+        .image("foo.png")
+        .image("bar.jpg")
+        .build();
+    assert_eq!(client.images.len(), 2);
+    assert_eq!(client.images[0], PathBuf::from("foo.png"));
+    assert_eq!(client.images[1], PathBuf::from("bar.jpg"));
+}
+
+#[test]
+fn builder_sets_json_flag() {
+    let client = CodexClient::builder().json(true).build();
+    assert!(client.json_output);
+}
+
+#[test]
+fn builder_sets_json_event_log() {
+    let client = CodexClient::builder().json_event_log("events.log").build();
+    assert_eq!(client.json_event_log, Some(PathBuf::from("events.log")));
+}
+
+#[test]
+fn builder_sets_quiet_flag() {
+    let client = CodexClient::builder().quiet(true).build();
+    assert!(client.quiet);
+}
+
+#[test]
+fn builder_mirrors_stdout_by_default() {
+    let client = CodexClient::builder().build();
+    assert!(client.mirror_stdout);
+}
+
+#[test]
+fn builder_can_disable_stdout_mirroring() {
+    let client = CodexClient::builder().mirror_stdout(false).build();
+    assert!(!client.mirror_stdout);
+}
+
+#[test]
+fn builder_uses_env_binary_when_set() {
+    let _guard = env_guard();
+    let key = CODEX_BINARY_ENV;
+    let original = env::var_os(key);
+    env::set_var(key, "custom_codex");
+    let builder = CodexClient::builder();
+    assert_eq!(builder.binary, PathBuf::from("custom_codex"));
+    if let Some(value) = original {
+        env::set_var(key, value);
+    } else {
+        env::remove_var(key);
+    }
+}
+
+#[test]
+fn default_binary_falls_back_when_env_missing() {
+    let _guard = env_guard();
+    let key = CODEX_BINARY_ENV;
+    let original = env::var_os(key);
+    env::remove_var(key);
+
+    assert_eq!(default_binary_path(), PathBuf::from("codex"));
+
+    if let Some(value) = original {
+        env::set_var(key, value);
+    } else {
+        env::remove_var(key);
+    }
+}
+
+#[test]
+fn default_rust_log_is_error_when_unset() {
+    let _guard = env_guard();
+    let original = env::var_os("RUST_LOG");
+    env::remove_var("RUST_LOG");
+
+    assert_eq!(default_rust_log_value(), Some("error"));
+
+    if let Some(value) = original {
+        env::set_var("RUST_LOG", value);
+    } else {
+        env::remove_var("RUST_LOG");
+    }
+}
+
+#[test]
+fn default_rust_log_respects_existing_env() {
+    let _guard = env_guard();
+    let original = env::var_os("RUST_LOG");
+    env::set_var("RUST_LOG", "info");
+
+    assert_eq!(default_rust_log_value(), None);
+
+    if let Some(value) = original {
+        env::set_var("RUST_LOG", value);
+    } else {
+        env::remove_var("RUST_LOG");
+    }
+}
+
+#[test]
+fn command_env_sets_expected_overrides() {
+    let _guard = env_guard();
+    let rust_log_original = env::var_os(RUST_LOG_ENV);
+    env::remove_var(RUST_LOG_ENV);
+
+    let temp = tempfile::tempdir().unwrap();
+    let home = temp.path().join("codex_home");
+    let env_prep =
+        CommandEnvironment::new(PathBuf::from("/custom/codex"), Some(home.clone()), true);
+    let overrides = env_prep.environment_overrides().unwrap();
+    let map: HashMap<OsString, OsString> = overrides.into_iter().collect();
+
+    assert_eq!(
+        map.get(&OsString::from(CODEX_BINARY_ENV)),
+        Some(&OsString::from("/custom/codex"))
+    );
+    assert_eq!(
+        map.get(&OsString::from(CODEX_HOME_ENV)),
+        Some(&home.as_os_str().to_os_string())
+    );
+    assert_eq!(
+        map.get(&OsString::from(RUST_LOG_ENV)),
+        Some(&OsString::from(DEFAULT_RUST_LOG))
+    );
+
+    assert!(home.is_dir());
+    assert!(home.join("conversations").is_dir());
+    assert!(home.join("logs").is_dir());
+
+    match rust_log_original {
+        Some(value) => env::set_var(RUST_LOG_ENV, value),
+        None => env::remove_var(RUST_LOG_ENV),
+    }
+}
+
+#[test]
+fn command_env_applies_home_and_binary_per_command() {
+    let _guard = env_guard();
+    let binary_key = CODEX_BINARY_ENV;
+    let home_key = CODEX_HOME_ENV;
+    let rust_log_key = RUST_LOG_ENV;
+    let original_binary = env::var_os(binary_key);
+    let original_home = env::var_os(home_key);
+    let original_rust_log = env::var_os(rust_log_key);
+
+    env::set_var(binary_key, "/tmp/ignored_codex");
+    env::set_var(home_key, "/tmp/ambient_home");
+    env::remove_var(rust_log_key);
+
+    let temp = tempfile::tempdir().unwrap();
+    let home = temp.path().join("scoped_home");
+    let env_prep = CommandEnvironment::new(
+        PathBuf::from("/app/bundled/codex"),
+        Some(home.clone()),
+        true,
+    );
+
+    let mut command = Command::new("echo");
+    env_prep.apply(&mut command).unwrap();
+
+    let envs: HashMap<OsString, Option<OsString>> = command
+        .as_std()
+        .get_envs()
+        .map(|(key, value)| (key.to_os_string(), value.map(|v| v.to_os_string())))
+        .collect();
+
+    assert_eq!(
+        envs.get(&OsString::from(binary_key)),
+        Some(&Some(OsString::from("/app/bundled/codex")))
+    );
+    assert_eq!(
+        envs.get(&OsString::from(home_key)),
+        Some(&Some(home.as_os_str().to_os_string()))
+    );
+    assert_eq!(
+        envs.get(&OsString::from(rust_log_key)),
+        Some(&Some(OsString::from(DEFAULT_RUST_LOG)))
+    );
+    assert_eq!(
+        env::var_os(home_key),
+        Some(OsString::from("/tmp/ambient_home"))
+    );
+    assert!(home.is_dir());
+    assert!(home.join("conversations").is_dir());
+    assert!(home.join("logs").is_dir());
+
+    match original_binary {
+        Some(value) => env::set_var(binary_key, value),
+        None => env::remove_var(binary_key),
+    }
+    match original_home {
+        Some(value) => env::set_var(home_key, value),
+        None => env::remove_var(home_key),
+    }
+    match original_rust_log {
+        Some(value) => env::set_var(rust_log_key, value),
+        None => env::remove_var(rust_log_key),
+    }
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn apply_and_diff_capture_outputs_and_status() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = dir.path().join("codex");
+    std::fs::write(
+        &script_path,
+        r#"#!/usr/bin/env bash
+set -e
+cmd="$1"
+if [[ "$cmd" == "apply" ]]; then
+  echo "applied"
+  echo "apply-stderr" >&2
+  exit 0
+elif [[ "$cmd" == "cloud" && "${2:-}" == "diff" ]]; then
+  echo "diff-body"
+  echo "diff-stderr" >&2
+  exit 3
+else
+  echo "unknown $cmd" >&2
+  exit 99
+fi
+"#,
+    )
+    .unwrap();
+    let mut perms = std::fs::metadata(&script_path).unwrap().permissions();
+    perms.set_mode(0o755);
+    std::fs::set_permissions(&script_path, perms).unwrap();
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let apply = client.apply().await.unwrap();
+    assert!(apply.status.success());
+    assert_eq!(apply.stdout.trim(), "applied");
+    assert_eq!(apply.stderr.trim(), "apply-stderr");
+
+    let diff = client.diff().await.unwrap();
+    assert!(!diff.status.success());
+    assert_eq!(diff.status.code(), Some(3));
+    assert_eq!(diff.stdout.trim(), "diff-body");
+    assert_eq!(diff.stderr.trim(), "diff-stderr");
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn apply_respects_rust_log_default() {
+    let _guard = env_guard_async().await;
+    let original = env::var_os("RUST_LOG");
+    env::remove_var("RUST_LOG");
+
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = dir.path().join("codex-rust-log");
+    std::fs::write(
+        &script_path,
+        r#"#!/usr/bin/env bash
+echo "${RUST_LOG:-missing}"
+exit 0
+"#,
+    )
+    .unwrap();
+    let mut perms = std::fs::metadata(&script_path).unwrap().permissions();
+    perms.set_mode(0o755);
+    std::fs::set_permissions(&script_path, perms).unwrap();
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let apply = client.apply().await.unwrap();
+    assert_eq!(apply.stdout.trim(), "error");
+
+    if let Some(value) = original {
+        env::set_var("RUST_LOG", value);
+    } else {
+        env::remove_var("RUST_LOG");
+    }
+}
+
+#[test]
+fn command_env_respects_existing_rust_log() {
+    let _guard = env_guard();
+    let rust_log_original = env::var_os(RUST_LOG_ENV);
+    env::set_var(RUST_LOG_ENV, "trace");
+
+    let env_prep = CommandEnvironment::new(PathBuf::from("codex"), None, true);
+    let overrides = env_prep.environment_overrides().unwrap();
+    let map: HashMap<OsString, OsString> = overrides.into_iter().collect();
+
+    assert_eq!(
+        map.get(&OsString::from(CODEX_BINARY_ENV)),
+        Some(&OsString::from("codex"))
+    );
+    assert!(!map.contains_key(&OsString::from(RUST_LOG_ENV)));
+
+    match rust_log_original {
+        Some(value) => env::set_var(RUST_LOG_ENV, value),
+        None => env::remove_var(RUST_LOG_ENV),
+    }
+}
+
+#[test]
+fn command_env_can_skip_home_creation() {
+    let _guard = env_guard();
+    let rust_log_original = env::var_os(RUST_LOG_ENV);
+    env::remove_var(RUST_LOG_ENV);
+
+    let temp = tempfile::tempdir().unwrap();
+    let home = temp.path().join("codex_home");
+    let env_prep = CommandEnvironment::new(PathBuf::from("codex"), Some(home.clone()), false);
+    let overrides = env_prep.environment_overrides().unwrap();
+    let map: HashMap<OsString, OsString> = overrides.into_iter().collect();
+
+    assert!(!home.exists());
+    assert!(!home.join("conversations").exists());
+    assert!(!home.join("logs").exists());
+    assert_eq!(
+        map.get(&OsString::from(CODEX_HOME_ENV)),
+        Some(&home.as_os_str().to_os_string())
+    );
+
+    match rust_log_original {
+        Some(value) => env::set_var(RUST_LOG_ENV, value),
+        None => env::remove_var(RUST_LOG_ENV),
+    }
+}
+
+#[test]
+fn codex_home_layout_exposes_paths() {
+    let root = PathBuf::from("/tmp/codex_layout_root");
+    let layout = CodexHomeLayout::new(&root);
+
+    assert_eq!(layout.root(), root.as_path());
+    assert_eq!(layout.config_path(), root.join("config.toml"));
+    assert_eq!(layout.auth_path(), root.join("auth.json"));
+    assert_eq!(layout.credentials_path(), root.join(".credentials.json"));
+    assert_eq!(layout.history_path(), root.join("history.jsonl"));
+    assert_eq!(layout.conversations_dir(), root.join("conversations"));
+    assert_eq!(layout.logs_dir(), root.join("logs"));
+}
+
+#[test]
+fn codex_home_layout_respects_materialization_flag() {
+    let temp = tempfile::tempdir().unwrap();
+    let root = temp.path().join("codex_home_layout");
+    let layout = CodexHomeLayout::new(&root);
+
+    layout.materialize(false).unwrap();
+    assert!(!root.exists());
+
+    layout.materialize(true).unwrap();
+    assert!(root.is_dir());
+    assert!(layout.conversations_dir().is_dir());
+    assert!(layout.logs_dir().is_dir());
+}
+
+#[test]
+fn seed_auth_copies_files_and_creates_targets() {
+    let temp = tempfile::tempdir().unwrap();
+    let seed = temp.path().join("seed_home");
+    std::fs::create_dir_all(&seed).unwrap();
+    std::fs::write(seed.join("auth.json"), "auth").unwrap();
+    std::fs::write(seed.join(".credentials.json"), "creds").unwrap();
+
+    let target_root = temp.path().join("target_home");
+    let layout = CodexHomeLayout::new(&target_root);
+    let outcome = layout
+        .seed_auth_from(&seed, AuthSeedOptions::default())
+        .unwrap();
+
+    assert!(outcome.copied_auth);
+    assert!(outcome.copied_credentials);
+    assert_eq!(std::fs::read_to_string(layout.auth_path()).unwrap(), "auth");
+    assert_eq!(
+        std::fs::read_to_string(layout.credentials_path()).unwrap(),
+        "creds"
+    );
+}
+
+#[test]
+fn seed_auth_skips_optional_files() {
+    let temp = tempfile::tempdir().unwrap();
+    let seed = temp.path().join("seed_home");
+    std::fs::create_dir_all(&seed).unwrap();
+    std::fs::write(seed.join("auth.json"), "auth").unwrap();
+
+    let target_root = temp.path().join("target_home");
+    let layout = CodexHomeLayout::new(&target_root);
+    let outcome = layout
+        .seed_auth_from(&seed, AuthSeedOptions::default())
+        .unwrap();
+
+    assert!(outcome.copied_auth);
+    assert!(!outcome.copied_credentials);
+    assert_eq!(std::fs::read_to_string(layout.auth_path()).unwrap(), "auth");
+    assert!(!layout.credentials_path().exists());
+}
+
+#[test]
+fn seed_auth_errors_when_required_missing() {
+    let temp = tempfile::tempdir().unwrap();
+    let seed = temp.path().join("seed_home");
+    std::fs::create_dir_all(&seed).unwrap();
+
+    let target_root = temp.path().join("target_home");
+    let layout = CodexHomeLayout::new(&target_root);
+    let err = layout
+        .seed_auth_from(
+            &seed,
+            AuthSeedOptions {
+                require_auth: true,
+                require_credentials: true,
+                ..Default::default()
+            },
+        )
+        .unwrap_err();
+
+    match err {
+        AuthSeedError::SeedFileMissing { path } => {
+            assert!(path.ends_with("auth.json"), "{path:?}")
+        }
+        other => panic!("unexpected error: {other:?}"),
+    }
+}
+
+#[test]
+fn codex_client_returns_configured_home_layout() {
+    let temp = tempfile::tempdir().unwrap();
+    let root = temp.path().join("app_codex_home");
+    let client = CodexClient::builder().codex_home(&root).build();
+
+    let layout = client.codex_home_layout().expect("layout missing");
+    assert_eq!(layout.root(), root.as_path());
+    assert!(!root.exists());
+
+    let client_without_home = CodexClient::builder().build();
+    assert!(client_without_home.codex_home_layout().is_none());
+}
diff --git a/crates/codex/src/tests/bundled_binary.rs b/crates/codex/src/tests/bundled_binary.rs
new file mode 100644
index 0000000..4ff42a8
--- /dev/null
+++ b/crates/codex/src/tests/bundled_binary.rs
@@ -0,0 +1,87 @@
+use super::*;
+
+#[test]
+fn resolve_bundled_binary_defaults_to_runtime_platform() {
+    let temp = tempfile::tempdir().unwrap();
+    let platform = default_bundled_platform_label();
+    let version = "1.2.3";
+    let version_dir = temp.path().join(&platform).join(version);
+    std_fs::create_dir_all(&version_dir).unwrap();
+    let binary = write_fake_bundled_codex(&version_dir, &platform, "#!/usr/bin/env bash\necho ok");
+
+    let resolved = resolve_bundled_binary(BundledBinarySpec {
+        bundle_root: temp.path(),
+        version,
+        platform: None,
+    })
+    .unwrap();
+
+    assert_eq!(resolved.platform, platform);
+    assert_eq!(resolved.version, version);
+    assert_eq!(resolved.binary_path, std_fs::canonicalize(&binary).unwrap());
+}
+
+#[test]
+fn resolve_bundled_binary_honors_platform_override() {
+    let temp = tempfile::tempdir().unwrap();
+    let platform = "windows-x64";
+    let version = "5.6.7";
+    let version_dir = temp.path().join(platform).join(version);
+    std_fs::create_dir_all(&version_dir).unwrap();
+    let binary = write_fake_bundled_codex(&version_dir, platform, "#!/usr/bin/env bash\necho win");
+
+    let resolved = resolve_bundled_binary(BundledBinarySpec {
+        bundle_root: temp.path(),
+        version,
+        platform: Some(platform),
+    })
+    .unwrap();
+
+    assert_eq!(resolved.platform, platform);
+    assert_eq!(resolved.version, version);
+    assert_eq!(resolved.binary_path, std_fs::canonicalize(&binary).unwrap());
+    assert_eq!(
+        resolved
+            .binary_path
+            .file_name()
+            .and_then(|name| name.to_str()),
+        Some("codex.exe")
+    );
+}
+
+#[test]
+fn resolve_bundled_binary_errors_when_binary_missing() {
+    let temp = tempfile::tempdir().unwrap();
+    let platform = default_bundled_platform_label();
+    let version = "0.0.1";
+    let version_dir = temp.path().join(&platform).join(version);
+    std_fs::create_dir_all(&version_dir).unwrap();
+
+    let err = resolve_bundled_binary(BundledBinarySpec {
+        bundle_root: temp.path(),
+        version,
+        platform: None,
+    })
+    .unwrap_err();
+
+    match err {
+        BundledBinaryError::BinaryUnreadable { binary, .. }
+        | BundledBinaryError::BinaryNotFile { binary }
+        | BundledBinaryError::BinaryNotExecutable { binary } => {
+            assert_eq!(binary, version_dir.join(bundled_binary_filename(&platform)));
+        }
+        other => panic!("unexpected error: {other:?}"),
+    }
+}
+
+#[test]
+fn resolve_bundled_binary_rejects_empty_version() {
+    let temp = tempfile::tempdir().unwrap();
+    let err = resolve_bundled_binary(BundledBinarySpec {
+        bundle_root: temp.path(),
+        version: "  ",
+        platform: None,
+    })
+    .unwrap_err();
+    assert!(matches!(err, BundledBinaryError::EmptyVersion));
+}
diff --git a/crates/codex/src/tests/capabilities.rs b/crates/codex/src/tests/capabilities.rs
new file mode 100644
index 0000000..8ec5738
--- /dev/null
+++ b/crates/codex/src/tests/capabilities.rs
@@ -0,0 +1,1007 @@
+use super::*;
+
+fn capabilities_with_version(raw_version: &str) -> CodexCapabilities {
+    CodexCapabilities {
+        cache_key: CapabilityCacheKey {
+            binary_path: PathBuf::from("codex"),
+        },
+        fingerprint: None,
+        version: Some(version::parse_version_output(raw_version)),
+        features: CodexFeatureFlags::default(),
+        probe_plan: CapabilityProbePlan::default(),
+        collected_at: SystemTime::now(),
+    }
+}
+
+fn capabilities_without_version() -> CodexCapabilities {
+    CodexCapabilities {
+        cache_key: CapabilityCacheKey {
+            binary_path: PathBuf::from("codex"),
+        },
+        fingerprint: None,
+        version: None,
+        features: CodexFeatureFlags::default(),
+        probe_plan: CapabilityProbePlan::default(),
+        collected_at: SystemTime::now(),
+    }
+}
+
+fn capabilities_with_feature_flags(features: CodexFeatureFlags) -> CodexCapabilities {
+    CodexCapabilities {
+        cache_key: CapabilityCacheKey {
+            binary_path: PathBuf::from("codex"),
+        },
+        fingerprint: None,
+        version: None,
+        features,
+        probe_plan: CapabilityProbePlan::default(),
+        collected_at: SystemTime::now(),
+    }
+}
+
+fn sample_capabilities_snapshot() -> CodexCapabilities {
+    CodexCapabilities {
+        cache_key: CapabilityCacheKey {
+            binary_path: PathBuf::from("/tmp/codex"),
+        },
+        fingerprint: Some(BinaryFingerprint {
+            canonical_path: Some(PathBuf::from("/tmp/codex")),
+            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(5)),
+            len: Some(1234),
+        }),
+        version: Some(CodexVersionInfo {
+            raw: "codex 3.4.5-beta (commit cafe)".to_string(),
+            semantic: Some((3, 4, 5)),
+            commit: Some("cafe".to_string()),
+            channel: CodexReleaseChannel::Beta,
+        }),
+        features: CodexFeatureFlags {
+            supports_features_list: true,
+            supports_output_schema: true,
+            supports_add_dir: false,
+            supports_mcp_login: true,
+        },
+        probe_plan: CapabilityProbePlan {
+            steps: vec![
+                CapabilityProbeStep::VersionFlag,
+                CapabilityProbeStep::FeaturesListJson,
+                CapabilityProbeStep::ManualOverride,
+            ],
+        },
+        collected_at: SystemTime::UNIX_EPOCH + Duration::from_secs(10),
+    }
+}
+
+fn sample_capability_overrides() -> CapabilityOverrides {
+    CapabilityOverrides {
+        snapshot: Some(sample_capabilities_snapshot()),
+        version: Some(version::parse_version_output("codex 9.9.9-nightly")),
+        features: CapabilityFeatureOverrides {
+            supports_features_list: Some(true),
+            supports_output_schema: Some(true),
+            supports_add_dir: Some(true),
+            supports_mcp_login: None,
+        },
+    }
+}
+
+fn capability_snapshot_with_metadata(
+    collected_at: SystemTime,
+    fingerprint: Option<BinaryFingerprint>,
+) -> CodexCapabilities {
+    CodexCapabilities {
+        cache_key: CapabilityCacheKey {
+            binary_path: PathBuf::from("/tmp/codex"),
+        },
+        fingerprint,
+        version: None,
+        features: CodexFeatureFlags::default(),
+        probe_plan: CapabilityProbePlan::default(),
+        collected_at,
+    }
+}
+
+#[test]
+fn parses_version_output_fields() {
+    let parsed = version::parse_version_output("codex v3.4.5-nightly (commit abc1234)");
+    assert_eq!(parsed.semantic, Some((3, 4, 5)));
+    assert_eq!(parsed.channel, CodexReleaseChannel::Nightly);
+    assert_eq!(parsed.commit.as_deref(), Some("abc1234"));
+    assert_eq!(
+        parsed.raw,
+        "codex v3.4.5-nightly (commit abc1234)".to_string()
+    );
+}
+
+#[test]
+fn update_advisory_detects_newer_release() {
+    let capabilities = capabilities_with_version("codex 1.0.0");
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("1.1.0").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::UpdateRecommended);
+    assert!(advisory.is_update_recommended());
+    assert_eq!(
+        advisory
+            .latest_release
+            .as_ref()
+            .map(|release| release.version.clone()),
+        latest.stable
+    );
+}
+
+#[test]
+fn update_advisory_handles_unknown_local_version() {
+    let capabilities = capabilities_without_version();
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("3.2.1").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::UnknownLocalVersion);
+    assert!(advisory.is_update_recommended());
+    assert!(advisory
+        .notes
+        .iter()
+        .any(|note| note.contains("could not be parsed")));
+}
+
+#[test]
+fn update_advisory_marks_up_to_date() {
+    let capabilities = capabilities_with_version("codex 2.0.1");
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("2.0.1").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::UpToDate);
+    assert!(!advisory.is_update_recommended());
+}
+
+#[test]
+fn update_advisory_falls_back_when_channel_missing() {
+    let capabilities = capabilities_with_version("codex 2.0.0-beta");
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("2.0.1").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.comparison_channel, CodexReleaseChannel::Stable);
+    assert_eq!(advisory.status, CodexUpdateStatus::UpdateRecommended);
+    assert!(advisory
+        .notes
+        .iter()
+        .any(|note| note.contains("comparing against stable")));
+}
+
+#[test]
+fn update_advisory_handles_local_newer_than_known() {
+    let capabilities = capabilities_with_version("codex 2.0.0");
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("1.9.9").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::LocalNewerThanKnown);
+    assert!(!advisory.is_update_recommended());
+    assert!(advisory
+        .notes
+        .iter()
+        .any(|note| note.contains("newer than provided")));
+}
+
+#[test]
+fn update_advisory_handles_missing_latest_metadata() {
+    let capabilities = capabilities_with_version("codex 1.0.0");
+    let latest = CodexLatestReleases::default();
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::UnknownLatestVersion);
+    assert!(!advisory.is_update_recommended());
+    assert!(advisory
+        .notes
+        .iter()
+        .any(|note| note.contains("advisory unavailable")));
+}
+
+#[test]
+fn capability_snapshots_serialize_to_json_and_toml() {
+    let snapshot = sample_capabilities_snapshot();
+
+    let json = serialize_capabilities_snapshot(&snapshot, CapabilitySnapshotFormat::Json)
+        .expect("serialize json");
+    let parsed_json = deserialize_capabilities_snapshot(&json, CapabilitySnapshotFormat::Json)
+        .expect("parse json");
+    assert_eq!(parsed_json, snapshot);
+
+    let toml = serialize_capabilities_snapshot(&snapshot, CapabilitySnapshotFormat::Toml)
+        .expect("serialize toml");
+    let parsed_toml = deserialize_capabilities_snapshot(&toml, CapabilitySnapshotFormat::Toml)
+        .expect("parse toml");
+    assert_eq!(parsed_toml, snapshot);
+}
+
+#[test]
+fn capability_snapshots_and_overrides_round_trip_via_files() {
+    let snapshot = sample_capabilities_snapshot();
+    let overrides = sample_capability_overrides();
+    let temp = tempfile::tempdir().unwrap();
+
+    let snapshot_path = temp.path().join("capabilities.toml");
+    write_capabilities_snapshot(&snapshot_path, &snapshot, None).unwrap();
+    let loaded_snapshot = read_capabilities_snapshot(&snapshot_path, None).unwrap();
+    assert_eq!(loaded_snapshot, snapshot);
+
+    let overrides_path = temp.path().join("overrides.json");
+    write_capability_overrides(&overrides_path, &overrides, None).unwrap();
+    let loaded_overrides = read_capability_overrides(&overrides_path, None).unwrap();
+    assert_eq!(loaded_overrides, overrides);
+}
+
+#[test]
+fn capability_snapshot_match_checks_fingerprint() {
+    let temp = tempfile::tempdir().unwrap();
+    let script = "#!/bin/bash\necho ok";
+    let binary = write_fake_codex(temp.path(), script);
+    let cache_key = capability_cache_key(&binary);
+    let fingerprint = current_fingerprint(&cache_key);
+
+    let snapshot = CodexCapabilities {
+        cache_key: cache_key.clone(),
+        fingerprint: fingerprint.clone(),
+        version: None,
+        features: CodexFeatureFlags::default(),
+        probe_plan: CapabilityProbePlan::default(),
+        collected_at: SystemTime::UNIX_EPOCH,
+    };
+
+    assert!(capability_snapshot_matches_binary(&snapshot, &binary));
+    let mut missing_fingerprint = snapshot.clone();
+    missing_fingerprint.fingerprint = None;
+    assert!(!capability_snapshot_matches_binary(
+        &missing_fingerprint,
+        &binary
+    ));
+
+    std_fs::write(&binary, "#!/bin/bash\necho changed").unwrap();
+    let mut perms = std_fs::metadata(&binary).unwrap().permissions();
+    perms.set_mode(0o755);
+    std_fs::set_permissions(&binary, perms).unwrap();
+
+    assert!(!capability_snapshot_matches_binary(&snapshot, &binary));
+}
+
+#[test]
+fn capability_cache_entries_exposes_cache_state() {
+    let _guard = env_guard();
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let binary = write_fake_codex(temp.path(), "#!/bin/bash\necho ok");
+    let cache_key = capability_cache_key(&binary);
+    let fingerprint = current_fingerprint(&cache_key);
+
+    let snapshot = CodexCapabilities {
+        cache_key: cache_key.clone(),
+        fingerprint: fingerprint.clone(),
+        version: Some(version::parse_version_output("codex 0.0.1")),
+        features: CodexFeatureFlags {
+            supports_features_list: true,
+            supports_output_schema: true,
+            supports_add_dir: false,
+            supports_mcp_login: false,
+        },
+        probe_plan: CapabilityProbePlan {
+            steps: vec![CapabilityProbeStep::VersionFlag],
+        },
+        collected_at: SystemTime::UNIX_EPOCH,
+    };
+
+    update_capability_cache(snapshot.clone());
+
+    let entries = capability_cache_entries();
+    assert!(entries.iter().any(|entry| entry.cache_key == cache_key));
+
+    let fetched = capability_cache_entry(&binary).expect("expected cache entry");
+    assert_eq!(fetched.cache_key, cache_key);
+    assert!(clear_capability_cache_entry(&binary));
+    assert!(capability_cache_entry(&binary).is_none());
+    assert!(capability_cache_entries().is_empty());
+    clear_capability_cache();
+}
+
+#[test]
+fn capability_ttl_decision_reuses_fresh_snapshot() {
+    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(10);
+    let snapshot = capability_snapshot_with_metadata(
+        collected_at,
+        Some(BinaryFingerprint {
+            canonical_path: Some(PathBuf::from("/tmp/codex")),
+            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(1)),
+            len: Some(123),
+        }),
+    );
+
+    let decision = capability_cache_ttl_decision(
+        Some(&snapshot),
+        Duration::from_secs(300),
+        SystemTime::UNIX_EPOCH + Duration::from_secs(100),
+    );
+    assert!(!decision.should_probe);
+    assert_eq!(decision.policy, CapabilityCachePolicy::PreferCache);
+}
+
+#[test]
+fn capability_ttl_decision_refreshes_after_ttl_with_fingerprint() {
+    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(1);
+    let snapshot = capability_snapshot_with_metadata(
+        collected_at,
+        Some(BinaryFingerprint {
+            canonical_path: Some(PathBuf::from("/tmp/codex")),
+            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(1)),
+            len: Some(321),
+        }),
+    );
+
+    let decision = capability_cache_ttl_decision(
+        Some(&snapshot),
+        Duration::from_secs(5),
+        SystemTime::UNIX_EPOCH + Duration::from_secs(10),
+    );
+    assert!(decision.should_probe);
+    assert_eq!(decision.policy, CapabilityCachePolicy::Refresh);
+}
+
+#[test]
+fn capability_ttl_decision_bypasses_when_metadata_missing() {
+    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(2);
+    let snapshot = capability_snapshot_with_metadata(collected_at, None);
+
+    let decision = capability_cache_ttl_decision(
+        Some(&snapshot),
+        Duration::from_secs(5),
+        SystemTime::UNIX_EPOCH + Duration::from_secs(10),
+    );
+    assert!(decision.should_probe);
+    assert_eq!(decision.policy, CapabilityCachePolicy::Bypass);
+}
+
+#[tokio::test]
+async fn probe_reprobes_when_metadata_missing() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let binary = temp.path().join("missing_codex");
+    let cache_key = capability_cache_key(&binary);
+
+    {
+        let mut cache = capability_cache().lock().unwrap();
+        cache.insert(
+            cache_key.clone(),
+            CodexCapabilities {
+                cache_key: cache_key.clone(),
+                fingerprint: None,
+                version: Some(version::parse_version_output("codex 9.9.9")),
+                features: CodexFeatureFlags {
+                    supports_features_list: true,
+                    supports_output_schema: true,
+                    supports_add_dir: true,
+                    supports_mcp_login: true,
+                },
+                probe_plan: CapabilityProbePlan::default(),
+                collected_at: SystemTime::UNIX_EPOCH,
+            },
+        );
+    }
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(1))
+        .build();
+
+    let capabilities = client.probe_capabilities().await;
+    assert!(!capabilities.features.supports_output_schema);
+    assert!(capabilities
+        .probe_plan
+        .steps
+        .contains(&CapabilityProbeStep::VersionFlag));
+
+    clear_capability_cache();
+}
+
+#[tokio::test]
+async fn probe_refresh_policy_forces_new_snapshot() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("probe.log");
+    let script = format!(
+        r#"#!/bin/bash
+echo "$@" >> "{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{{"features":["output_schema"]}}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let first = client.probe_capabilities().await;
+    assert!(first.features.supports_output_schema);
+    let first_lines = std_fs::read_to_string(&log_path).unwrap().lines().count();
+    assert!(first_lines >= 2);
+
+    let refreshed = client
+        .probe_capabilities_with_policy(CapabilityCachePolicy::Refresh)
+        .await;
+    assert!(refreshed.features.supports_output_schema);
+    let refreshed_lines = std_fs::read_to_string(&log_path).unwrap().lines().count();
+    assert!(
+        refreshed_lines > first_lines,
+        "expected refresh policy to re-run probes"
+    );
+    clear_capability_cache();
+}
+
+#[tokio::test]
+async fn probe_bypass_policy_skips_cache_writes() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let script = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":["output_schema"]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema"
+fi
+"#;
+    let binary = write_fake_codex(temp.path(), script);
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let capabilities = client
+        .probe_capabilities_with_policy(CapabilityCachePolicy::Bypass)
+        .await;
+    assert!(capabilities.features.supports_output_schema);
+    assert!(capability_cache_entry(&binary).is_none());
+    clear_capability_cache();
+}
+
+#[test]
+fn parses_features_from_json_and_text() {
+    let json = r#"{"features":["output_schema","add_dir"],"mcp_login":true}"#;
+    let parsed_json = version::parse_features_from_json(json).unwrap();
+    assert!(parsed_json.supports_output_schema);
+    assert!(parsed_json.supports_add_dir);
+    assert!(parsed_json.supports_mcp_login);
+
+    let text = "Features: output-schema add-dir login --mcp";
+    let parsed_text = version::parse_features_from_text(text);
+    assert!(parsed_text.supports_output_schema);
+    assert!(parsed_text.supports_add_dir);
+    assert!(parsed_text.supports_mcp_login);
+}
+
+#[test]
+fn parses_feature_list_json_and_text_tables() {
+    let json = r#"{"features":[{"name":"json-stream","stage":"stable","enabled":true,"notes":"keep"},{"name":"cloud-exec","stage":"experimental","enabled":false}]}"#;
+    let (json_features, json_format) = version::parse_feature_list_output(json, true).unwrap();
+    assert_eq!(json_format, FeaturesListFormat::Json);
+    assert_eq!(json_features.len(), 2);
+    assert_eq!(json_features[0].name, "json-stream");
+    assert_eq!(json_features[0].stage, Some(CodexFeatureStage::Stable));
+    assert!(json_features[0].enabled);
+    assert!(json_features[0].extra.contains_key("notes"));
+    assert_eq!(
+        json_features[1].stage,
+        Some(CodexFeatureStage::Experimental)
+    );
+    assert!(!json_features[1].enabled);
+
+    let text = r#"
+Feature   Stage         Enabled
+json-stream stable      true
+	cloud-exec experimental false
+	"#;
+    let (text_features, text_format) = version::parse_feature_list_output(text, false).unwrap();
+    assert_eq!(text_format, FeaturesListFormat::Text);
+    assert_eq!(text_features.len(), 2);
+    assert_eq!(
+        text_features[1].stage,
+        Some(CodexFeatureStage::Experimental)
+    );
+    assert!(!text_features[1].enabled);
+
+    let (fallback_features, fallback_format) =
+        version::parse_feature_list_output(text, true).unwrap();
+    assert_eq!(fallback_format, FeaturesListFormat::Text);
+    assert_eq!(fallback_features.len(), 2);
+}
+
+#[test]
+fn parses_help_output_flags() {
+    let help =
+        "Usage: codex --output-schema ... add-dir ... login --mcp. See `codex features list`.";
+    let parsed = version::parse_help_output(help);
+    assert!(parsed.supports_output_schema);
+    assert!(parsed.supports_add_dir);
+    assert!(parsed.supports_mcp_login);
+    assert!(parsed.supports_features_list);
+}
+
+#[test]
+fn capability_guard_reports_detected_support() {
+    let flags = CodexFeatureFlags {
+        supports_features_list: true,
+        supports_output_schema: true,
+        supports_add_dir: true,
+        supports_mcp_login: true,
+    };
+    let capabilities = capabilities_with_feature_flags(flags);
+
+    let output_schema = capabilities.guard_output_schema();
+    assert_eq!(output_schema.support, CapabilitySupport::Supported);
+    assert!(output_schema.is_supported());
+
+    let add_dir = capabilities.guard_add_dir();
+    assert_eq!(add_dir.support, CapabilitySupport::Supported);
+    assert!(add_dir.is_supported());
+
+    let mcp_login = capabilities.guard_mcp_login();
+    assert_eq!(mcp_login.support, CapabilitySupport::Supported);
+
+    let features_list = capabilities.guard_features_list();
+    assert_eq!(features_list.support, CapabilitySupport::Supported);
+}
+
+#[test]
+fn capability_guard_marks_absent_feature_as_unsupported() {
+    let flags = CodexFeatureFlags {
+        supports_features_list: true,
+        supports_output_schema: false,
+        supports_add_dir: false,
+        supports_mcp_login: false,
+    };
+    let capabilities = capabilities_with_feature_flags(flags);
+
+    let output_schema = capabilities.guard_output_schema();
+    assert_eq!(output_schema.support, CapabilitySupport::Unsupported);
+    assert!(!output_schema.is_supported());
+    assert!(output_schema
+        .notes
+        .iter()
+        .any(|note| note.contains("features list")));
+
+    let mcp_login = capabilities.guard_mcp_login();
+    assert_eq!(mcp_login.support, CapabilitySupport::Unsupported);
+}
+
+#[test]
+fn capability_guard_returns_unknown_without_feature_list() {
+    let capabilities = capabilities_with_feature_flags(CodexFeatureFlags::default());
+
+    let add_dir = capabilities.guard_add_dir();
+    assert_eq!(add_dir.support, CapabilitySupport::Unknown);
+    assert!(add_dir.is_unknown());
+    assert!(add_dir
+        .notes
+        .iter()
+        .any(|note| note.contains("unknown") || note.contains("unavailable")));
+
+    let features_list = capabilities.guard_features_list();
+    assert_eq!(features_list.support, CapabilitySupport::Unknown);
+}
+
+#[tokio::test]
+async fn capability_snapshot_short_circuits_probes() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("probe.log");
+    let script = format!(
+        r#"#!/bin/bash
+echo "$@" >> "{log}"
+exit 99
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+
+    let snapshot = CodexCapabilities {
+        cache_key: CapabilityCacheKey {
+            binary_path: PathBuf::from("codex"),
+        },
+        fingerprint: None,
+        version: Some(version::parse_version_output("codex 9.9.9-custom")),
+        features: CodexFeatureFlags {
+            supports_features_list: true,
+            supports_output_schema: true,
+            supports_add_dir: false,
+            supports_mcp_login: true,
+        },
+        probe_plan: CapabilityProbePlan::default(),
+        collected_at: SystemTime::now(),
+    };
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .capability_snapshot(snapshot)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let capabilities = client.probe_capabilities().await;
+    assert_eq!(
+        capabilities.cache_key.binary_path,
+        std_fs::canonicalize(&binary).unwrap()
+    );
+    assert!(capabilities.fingerprint.is_some());
+    assert!(capabilities.features.supports_output_schema);
+    assert!(capabilities.features.supports_mcp_login);
+    assert_eq!(
+        capabilities.version.as_ref().and_then(|v| v.semantic),
+        Some((9, 9, 9))
+    );
+    assert!(capabilities
+        .probe_plan
+        .steps
+        .contains(&CapabilityProbeStep::ManualOverride));
+    assert!(!log_path.exists());
+}
+
+#[tokio::test]
+async fn capability_feature_overrides_apply_to_cached_entries() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let script = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":[]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "features list"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex exec"
+fi
+"#;
+    let binary = write_fake_codex(temp.path(), script);
+
+    let base_client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+    let base_capabilities = base_client.probe_capabilities().await;
+    assert!(base_capabilities.features.supports_features_list);
+    assert!(!base_capabilities.features.supports_output_schema);
+
+    let overrides = CapabilityFeatureOverrides::enabling(CodexFeatureFlags {
+        supports_features_list: false,
+        supports_output_schema: true,
+        supports_add_dir: false,
+        supports_mcp_login: true,
+    });
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .capability_feature_overrides(overrides)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let capabilities = client.probe_capabilities().await;
+    assert!(capabilities.features.supports_output_schema);
+    assert!(capabilities.features.supports_mcp_login);
+    assert!(capabilities
+        .probe_plan
+        .steps
+        .contains(&CapabilityProbeStep::ManualOverride));
+    assert_eq!(
+        capabilities.guard_output_schema().support,
+        CapabilitySupport::Supported
+    );
+}
+
+#[tokio::test]
+async fn capability_version_override_replaces_probe_version() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let script = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 0.1.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":["add_dir"]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "add_dir"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex add-dir"
+fi
+	"#;
+    let binary = write_fake_codex(temp.path(), script);
+    let version_override = version::parse_version_output("codex 9.9.9-nightly (commit beefcafe)");
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .capability_version_override(version_override)
+        .build();
+
+    let capabilities = client.probe_capabilities().await;
+    assert_eq!(
+        capabilities.version.as_ref().and_then(|v| v.semantic),
+        Some((9, 9, 9))
+    );
+    assert!(matches!(
+        capabilities.version.as_ref().map(|v| v.channel),
+        Some(CodexReleaseChannel::Nightly)
+    ));
+    assert!(capabilities.features.supports_add_dir);
+    assert!(capabilities
+        .probe_plan
+        .steps
+        .contains(&CapabilityProbeStep::ManualOverride));
+    assert_eq!(
+        capabilities.guard_add_dir().support,
+        CapabilitySupport::Supported
+    );
+}
+
+#[tokio::test]
+async fn exec_applies_guarded_flags_when_supported() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("exec.log");
+    let script = format!(
+        r#"#!/bin/bash
+log="{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.2.3"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{{"features":["output_schema","add_dir","mcp_login"]}}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema add_dir login --mcp"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex --output-schema add-dir login --mcp"
+elif [[ "$1" == "exec" ]]; then
+  echo "$@" >> "$log"
+  echo "ok"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .add_dir("src")
+        .output_schema(true)
+        .quiet(true)
+        .mirror_stdout(false)
+        .build();
+
+    let response = client.send_prompt("hello").await.unwrap();
+    assert_eq!(response.trim(), "ok");
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(logged.contains("--add-dir"));
+    assert!(logged.contains("src"));
+    assert!(logged.contains("--output-schema"));
+}
+
+#[tokio::test]
+async fn exec_skips_guarded_flags_when_unknown() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("exec.log");
+    let script = format!(
+        r#"#!/bin/bash
+log="{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 0.9.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo "feature list unavailable" >&2
+  exit 1
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "feature list unavailable" >&2
+  exit 1
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex exec"
+elif [[ "$1" == "exec" ]]; then
+  echo "$@" >> "$log"
+  echo "ok"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .add_dir("src")
+        .output_schema(true)
+        .quiet(true)
+        .mirror_stdout(false)
+        .build();
+
+    let response = client.send_prompt("hello").await.unwrap();
+    assert_eq!(response.trim(), "ok");
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(!logged.contains("--add-dir"));
+    assert!(!logged.contains("--output-schema"));
+}
+
+#[tokio::test]
+async fn mcp_login_skips_when_unsupported() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("login.log");
+    let script = format!(
+        r#"#!/bin/bash
+log="{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{{"features":["output_schema","add_dir"]}}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema add-dir"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex exec"
+elif [[ "$1" == "login" ]]; then
+  echo "$@" >> "$log"
+  echo "login invoked"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let login = client.spawn_mcp_login_process().await.unwrap();
+    assert!(login.is_none());
+    assert!(!log_path.exists());
+}
+
+#[tokio::test]
+async fn mcp_login_runs_when_supported() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("login.log");
+    let script = format!(
+        r#"#!/bin/bash
+log="{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 2.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{{"features":["output_schema","add_dir"],"mcp_login":true}}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema add_dir login --mcp"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex --output-schema add-dir login --mcp"
+elif [[ "$1" == "login" ]]; then
+  echo "$@" >> "$log"
+  echo "login invoked"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let login = client
+        .spawn_mcp_login_process()
+        .await
+        .unwrap()
+        .expect("expected login child");
+    let output = login.wait_with_output().await.unwrap();
+    assert!(output.status.success());
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(logged.contains("login --mcp"));
+}
+
+#[tokio::test]
+async fn probe_capabilities_caches_and_invalidates() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let script_v1 = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.2.3-beta (commit cafe123)"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":["output_schema","add_dir","mcp_login"]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema add-dir login --mcp"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex --output-schema add-dir login --mcp"
+fi
+"#;
+    let binary = write_fake_codex(temp.path(), script_v1);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let first = client.probe_capabilities().await;
+    assert_eq!(
+        first.version.as_ref().and_then(|v| v.semantic),
+        Some((1, 2, 3))
+    );
+    assert_eq!(
+        first.version.as_ref().map(|v| v.channel),
+        Some(CodexReleaseChannel::Beta)
+    );
+    assert_eq!(
+        first.version.as_ref().and_then(|v| v.commit.as_deref()),
+        Some("cafe123")
+    );
+    assert!(first.features.supports_features_list);
+    assert!(first.features.supports_output_schema);
+    assert!(first.features.supports_add_dir);
+    assert!(first.features.supports_mcp_login);
+
+    let cached = client.probe_capabilities().await;
+    assert_eq!(cached, first);
+
+    let script_v2 = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 2.0.0 (commit deadbeef)"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":["add_dir"]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "add-dir"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex add-dir"
+fi
+"#;
+    std_fs::write(&binary, script_v2).unwrap();
+    let mut perms = std_fs::metadata(&binary).unwrap().permissions();
+    perms.set_mode(0o755);
+    std_fs::set_permissions(&binary, perms).unwrap();
+
+    let refreshed = client.probe_capabilities().await;
+    assert_ne!(refreshed.version, first.version);
+    assert_eq!(
+        refreshed.version.as_ref().and_then(|v| v.semantic),
+        Some((2, 0, 0))
+    );
+    assert!(refreshed.features.supports_features_list);
+    assert!(refreshed.features.supports_add_dir);
+    assert!(!refreshed.features.supports_output_schema);
+    assert!(!refreshed.features.supports_mcp_login);
+    clear_capability_cache();
+}
diff --git a/crates/codex/src/tests/cli_commands.rs b/crates/codex/src/tests/cli_commands.rs
new file mode 100644
index 0000000..3b64c0a
--- /dev/null
+++ b/crates/codex/src/tests/cli_commands.rs
@@ -0,0 +1,652 @@
+use super::*;
+
+#[cfg(unix)]
+#[tokio::test]
+async fn features_list_maps_overrides_and_json_flag() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+echo "$PWD" 1>&2
+printf "%s\n" "$@" 1>&2
+cat <<'JSON'
+[{"name":"json-stream","stage":"stable","enabled":true},{"name":"cloud-exec","stage":"experimental","enabled":false}]
+JSON
+"#,
+    );
+
+    let workdir = dir.path().join("features-workdir");
+    std_fs::create_dir_all(&workdir).unwrap();
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .working_dir(&workdir)
+        .approval_policy(ApprovalPolicy::OnRequest)
+        .search(true)
+        .build();
+
+    let output = client
+        .list_features(
+            FeaturesListRequest::new()
+                .json(true)
+                .profile("dev")
+                .config_override("features.extras", "true"),
+        )
+        .await
+        .unwrap();
+
+    assert_eq!(output.format, FeaturesListFormat::Json);
+    assert_eq!(output.features.len(), 2);
+    assert_eq!(output.features[0].stage, Some(CodexFeatureStage::Stable));
+    assert!(output.features[0].enabled);
+    assert!(!output.features[1].enabled);
+
+    let mut lines = output.stderr.lines();
+    let pwd = lines.next().unwrap();
+    assert_eq!(Path::new(pwd), workdir.as_path());
+
+    let args: Vec<_> = lines.map(str::to_string).collect();
+    assert_eq!(
+        args,
+        vec![
+            "features",
+            "list",
+            "--config",
+            "features.extras=true",
+            "--profile",
+            "dev",
+            "--ask-for-approval",
+            "on-request",
+            "--search",
+            "--json"
+        ]
+    );
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn supports_help_review_fork_resume_and_features_commands() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+printf "%s\n" "$@"
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let features = client
+        .features(FeaturesCommandRequest::new())
+        .await
+        .unwrap();
+    assert_eq!(
+        features.stdout.lines().collect::<Vec<_>>(),
+        vec!["features"]
+    );
+
+    let help = client
+        .help(HelpCommandRequest::new(HelpScope::Root).command(["exec", "review"]))
+        .await
+        .unwrap();
+    assert_eq!(
+        help.stdout.lines().collect::<Vec<_>>(),
+        vec!["help", "exec", "review"]
+    );
+
+    let review = client
+        .review(
+            ReviewCommandRequest::new()
+                .base("main")
+                .commit("abc123")
+                .title("hello")
+                .uncommitted(true)
+                .prompt("please review"),
+        )
+        .await
+        .unwrap();
+    assert_eq!(
+        review.stdout.lines().collect::<Vec<_>>(),
+        vec![
+            "review",
+            "--base",
+            "main",
+            "--commit",
+            "abc123",
+            "--title",
+            "hello",
+            "--uncommitted",
+            "please review"
+        ]
+    );
+
+    let exec_review = client
+        .exec_review(
+            ExecReviewCommandRequest::new()
+                .base("main")
+                .commit("abc123")
+                .title("hello")
+                .uncommitted(true)
+                .json(true)
+                .prompt("please review"),
+        )
+        .await
+        .unwrap();
+    assert_eq!(
+        exec_review.stdout.lines().collect::<Vec<_>>(),
+        vec![
+            "exec",
+            "review",
+            "--base",
+            "main",
+            "--commit",
+            "abc123",
+            "--json",
+            "--skip-git-repo-check",
+            "--title",
+            "hello",
+            "--uncommitted",
+            "please review"
+        ]
+    );
+
+    let resume = client
+        .resume_session(
+            ResumeSessionRequest::new()
+                .all(true)
+                .last(true)
+                .session_id("sess-1")
+                .prompt("resume prompt"),
+        )
+        .await
+        .unwrap();
+    assert_eq!(
+        resume.stdout.lines().collect::<Vec<_>>(),
+        vec!["resume", "--all", "--last", "sess-1", "resume prompt"]
+    );
+
+    let fork = client
+        .fork_session(
+            ForkSessionRequest::new()
+                .all(true)
+                .last(true)
+                .session_id("sess-1")
+                .prompt("fork prompt"),
+        )
+        .await
+        .unwrap();
+    assert_eq!(
+        fork.stdout.lines().collect::<Vec<_>>(),
+        vec!["fork", "--all", "--last", "sess-1", "fork prompt"]
+    );
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn cloud_list_parses_json_and_maps_args() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+printf "%s\n" "$@" 1>&2
+cat <<'JSON'
+{"tasks":[],"cursor":null}
+JSON
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let output = client
+        .cloud_list(
+            CloudListRequest::new()
+                .json(true)
+                .env_id("env-1")
+                .limit(3)
+                .cursor("cur-1"),
+        )
+        .await
+        .unwrap();
+
+    assert_eq!(output.json, Some(json!({"tasks": [], "cursor": null})));
+    assert_eq!(
+        output.stderr.lines().collect::<Vec<_>>(),
+        vec!["cloud", "list", "--env", "env-1", "--limit", "3", "--cursor", "cur-1", "--json"]
+    );
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn cloud_exec_maps_args_and_rejects_empty_env_id() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+printf "%s\n" "$@"
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let output = client
+        .cloud_exec(
+            CloudExecRequest::new("env-1")
+                .attempts(2)
+                .branch("main")
+                .query("hello"),
+        )
+        .await
+        .unwrap();
+    assert_eq!(
+        output.stdout.lines().collect::<Vec<_>>(),
+        vec![
+            "cloud",
+            "exec",
+            "--env",
+            "env-1",
+            "--attempts",
+            "2",
+            "--branch",
+            "main",
+            "hello"
+        ]
+    );
+
+    let err = client
+        .cloud_exec(CloudExecRequest::new("  "))
+        .await
+        .unwrap_err();
+    assert!(matches!(err, CodexError::EmptyEnvId));
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn mcp_list_get_and_add_map_args_and_parse_json() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+printf "%s\n" "$@" 1>&2
+cat <<'JSON'
+{"servers":[{"name":"files"}]}
+JSON
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let list = client
+        .mcp_list(McpListRequest::new().json(true))
+        .await
+        .unwrap();
+    assert_eq!(list.json, Some(json!({"servers": [{"name": "files"}]})));
+    assert_eq!(
+        list.stderr.lines().collect::<Vec<_>>(),
+        vec!["mcp", "list", "--json"]
+    );
+
+    let get = client
+        .mcp_get(McpGetRequest::new("files").json(true))
+        .await
+        .unwrap();
+    assert_eq!(get.json, Some(json!({"servers": [{"name": "files"}]})));
+    assert_eq!(
+        get.stderr.lines().collect::<Vec<_>>(),
+        vec!["mcp", "get", "--json", "files"]
+    );
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn mcp_add_maps_transports_and_validates_required_fields() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+printf "%s\n" "$@"
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let stdio = client
+        .mcp_add(
+            McpAddRequest::stdio("files", vec![OsString::from("node"), OsString::from("srv")])
+                .env("TOKEN", "abc"),
+        )
+        .await
+        .unwrap();
+    assert_eq!(
+        stdio.stdout.lines().collect::<Vec<_>>(),
+        vec![
+            "mcp",
+            "add",
+            "files",
+            "--env",
+            "TOKEN=abc",
+            "--",
+            "node",
+            "srv"
+        ]
+    );
+
+    let http = client
+        .mcp_add(
+            McpAddRequest::streamable_http("http", "https://example.test")
+                .bearer_token_env_var("TOKEN_ENV"),
+        )
+        .await
+        .unwrap();
+    assert_eq!(
+        http.stdout.lines().collect::<Vec<_>>(),
+        vec![
+            "mcp",
+            "add",
+            "http",
+            "--url",
+            "https://example.test",
+            "--bearer-token-env-var",
+            "TOKEN_ENV"
+        ]
+    );
+
+    let err = client
+        .mcp_add(McpAddRequest::stdio("files", Vec::new()))
+        .await
+        .unwrap_err();
+    assert!(matches!(err, CodexError::EmptyMcpCommand));
+
+    let err = client
+        .mcp_add(McpAddRequest::streamable_http("bad", "  "))
+        .await
+        .unwrap_err();
+    assert!(matches!(err, CodexError::EmptyMcpUrl));
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn app_server_codegen_maps_overrides_and_prettier() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+echo "$PWD"
+printf "%s\n" "$@"
+"#,
+    );
+
+    let workdir = dir.path().join("workdir");
+    std_fs::create_dir_all(&workdir).unwrap();
+    let out_dir = dir.path().join("out/ts");
+    let prettier = dir.path().join("bin/prettier.js");
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .working_dir(&workdir)
+        .approval_policy(ApprovalPolicy::OnRequest)
+        .search(true)
+        .build();
+
+    let result = client
+        .generate_app_server_bindings(
+            AppServerCodegenRequest::typescript(&out_dir)
+                .prettier(&prettier)
+                .profile("dev")
+                .config_override("features.codegen", "true"),
+        )
+        .await
+        .unwrap();
+
+    let mut lines = result.stdout.lines();
+    let pwd = lines.next().unwrap();
+    assert_eq!(Path::new(pwd), workdir.as_path());
+
+    let args: Vec<_> = lines.map(str::to_string).collect();
+    assert_eq!(
+        args,
+        vec![
+            "app-server",
+            "generate-ts",
+            "--out",
+            out_dir.to_string_lossy().as_ref(),
+            "--config",
+            "features.codegen=true",
+            "--profile",
+            "dev",
+            "--ask-for-approval",
+            "on-request",
+            "--search",
+            "--prettier",
+            prettier.to_string_lossy().as_ref(),
+        ]
+    );
+    assert!(out_dir.is_dir());
+    assert_eq!(result.out_dir, out_dir);
+    assert!(result.status.success());
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn app_server_codegen_surfaces_non_zero_exit() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+echo "ts error"
+echo "bad format" 1>&2
+exit 5
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let out_dir = dir.path().join("schema");
+    let err = client
+        .generate_app_server_bindings(AppServerCodegenRequest::json_schema(&out_dir))
+        .await
+        .unwrap_err();
+
+    match err {
+        CodexError::NonZeroExit { status, stderr } => {
+            assert_eq!(status.code(), Some(5));
+            assert!(stderr.contains("bad format"));
+        }
+        other => panic!("expected NonZeroExit, got {other:?}"),
+    }
+    assert!(out_dir.is_dir());
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn responses_api_proxy_maps_flags_and_parses_server_info() {
+    let dir = tempfile::tempdir().unwrap();
+    let server_info = dir.path().join("server-info.json");
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+echo "$PWD"
+printf "%s\n" "$@"
+info_path=""
+while [[ $# -gt 0 ]]; do
+  if [[ $1 == "--server-info" ]]; then
+info_path=$2
+  fi
+  shift
+done
+read -r key || exit 1
+echo "key:${key}"
+if [[ -n "$info_path" ]]; then
+  printf '{"port":4567,"pid":1234}\n' > "$info_path"
+fi
+"#,
+    );
+
+    let workdir = dir.path().join("responses-workdir");
+    std_fs::create_dir_all(&workdir).unwrap();
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .working_dir(&workdir)
+        .build();
+
+    let mut proxy = client
+        .start_responses_api_proxy(
+            ResponsesApiProxyRequest::new("sk-test-123")
+                .port(8080)
+                .server_info(&server_info)
+                .http_shutdown(true)
+                .upstream_url("https://example.com/v1/responses"),
+        )
+        .await
+        .unwrap();
+
+    assert_eq!(
+        proxy.server_info_path.as_deref(),
+        Some(server_info.as_path())
+    );
+
+    let stdout = proxy.child.stdout.take().unwrap();
+    let mut lines = BufReader::new(stdout).lines();
+
+    let pwd = lines.next_line().await.unwrap().unwrap();
+    assert_eq!(Path::new(&pwd), workdir.as_path());
+
+    let mut args = Vec::new();
+    for _ in 0..8 {
+        args.push(lines.next_line().await.unwrap().unwrap());
+    }
+    assert_eq!(
+        args,
+        vec![
+            "responses-api-proxy",
+            "--port",
+            "8080",
+            "--server-info",
+            server_info.to_string_lossy().as_ref(),
+            "--http-shutdown",
+            "--upstream-url",
+            "https://example.com/v1/responses",
+        ]
+    );
+
+    let api_key_line = lines.next_line().await.unwrap().unwrap();
+    assert_eq!(api_key_line, "key:sk-test-123");
+
+    let info = proxy.read_server_info().await.unwrap().unwrap();
+    assert_eq!(info.port, 4567);
+    assert_eq!(info.pid, 1234);
+
+    let status = proxy.child.wait().await.unwrap();
+    assert!(status.success());
+}
+
+#[tokio::test]
+async fn responses_api_proxy_rejects_empty_api_key() {
+    let client = CodexClient::builder().build();
+    let err = client
+        .start_responses_api_proxy(ResponsesApiProxyRequest::new("  "))
+        .await
+        .unwrap_err();
+    assert!(matches!(err, CodexError::EmptyApiKey));
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn stdio_to_uds_maps_args_and_pipes_stdio() {
+    let dir = tempfile::tempdir().unwrap();
+    let socket_path = dir.path().join("bridge.sock");
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+echo "$PWD"
+printf "%s\n" "$@"
+while read -r line; do
+  echo "relay:${line}"
+done
+"#,
+    );
+
+    let workdir = dir.path().join("uds-workdir");
+    std_fs::create_dir_all(&workdir).unwrap();
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .working_dir(&workdir)
+        .build();
+
+    let request = StdioToUdsRequest::new(&socket_path).working_dir(&workdir);
+    let mut child = match client.stdio_to_uds(request.clone()) {
+        Ok(child) => child,
+        Err(CodexError::Spawn { source, .. }) if source.raw_os_error() == Some(26) => {
+            time::sleep(Duration::from_millis(25)).await;
+            client.stdio_to_uds(request).unwrap()
+        }
+        Err(other) => panic!("unexpected spawn error: {other:?}"),
+    };
+
+    let stdout = child.stdout.take().unwrap();
+    let mut lines = BufReader::new(stdout).lines();
+
+    let pwd = lines.next_line().await.unwrap().unwrap();
+    assert_eq!(Path::new(&pwd), workdir.as_path());
+
+    let arg_one = lines.next_line().await.unwrap().unwrap();
+    let arg_two = lines.next_line().await.unwrap().unwrap();
+    assert_eq!(arg_one, "stdio-to-uds");
+    assert_eq!(arg_two, socket_path.to_string_lossy().as_ref());
+
+    let mut stdin = child.stdin.take().unwrap();
+    stdin.write_all(b"ping\n").await.unwrap();
+    stdin.shutdown().await.unwrap();
+    drop(stdin);
+
+    let echoed = lines.next_line().await.unwrap().unwrap();
+    assert_eq!(echoed, "relay:ping");
+
+    let status = time::timeout(Duration::from_secs(5), child.wait())
+        .await
+        .expect("stdio-to-uds wait timed out")
+        .unwrap();
+    assert!(status.success());
+}
+
+#[tokio::test]
+async fn stdio_to_uds_rejects_empty_socket_path() {
+    let client = CodexClient::builder().build();
+    let err = client
+        .stdio_to_uds(StdioToUdsRequest::new(PathBuf::new()))
+        .unwrap_err();
+    assert!(matches!(err, CodexError::EmptySocketPath));
+}
diff --git a/crates/codex/src/tests/cli_overrides.rs b/crates/codex/src/tests/cli_overrides.rs
new file mode 100644
index 0000000..0f5b3b2
--- /dev/null
+++ b/crates/codex/src/tests/cli_overrides.rs
@@ -0,0 +1,460 @@
+use super::*;
+
+#[test]
+fn reasoning_config_by_model() {
+    assert_eq!(
+        reasoning_config_for(Some("gpt-5")).unwrap(),
+        DEFAULT_REASONING_CONFIG_GPT5
+    );
+    assert_eq!(
+        reasoning_config_for(Some("gpt-5.1-codex-max")).unwrap(),
+        DEFAULT_REASONING_CONFIG_GPT5_1
+    );
+    assert_eq!(
+        reasoning_config_for(Some("gpt-5-codex")).unwrap(),
+        DEFAULT_REASONING_CONFIG_GPT5_CODEX
+    );
+    assert!(reasoning_config_for(None).is_none());
+    assert!(reasoning_config_for(Some("gpt-4.1-mini")).is_none());
+}
+
+#[test]
+fn resolve_cli_overrides_respects_reasoning_defaults() {
+    let builder = CliOverrides::default();
+    let patch = CliOverridesPatch::default();
+
+    let resolved = resolve_cli_overrides(&builder, &patch, Some("gpt-5"));
+    let keys: Vec<_> = resolved
+        .config_overrides
+        .iter()
+        .map(|override_| override_.key.as_str())
+        .collect();
+    assert!(keys.contains(&"model_reasoning_effort"));
+    assert!(keys.contains(&"model_reasoning_summary"));
+    assert!(keys.contains(&"model_verbosity"));
+
+    let resolved_without_model = resolve_cli_overrides(&builder, &patch, None);
+    assert!(resolved_without_model.config_overrides.is_empty());
+}
+
+#[test]
+fn explicit_reasoning_overrides_disable_defaults() {
+    let mut builder = CliOverrides::default();
+    builder
+        .config_overrides
+        .push(ConfigOverride::new("model_reasoning_effort", "high"));
+
+    let resolved = resolve_cli_overrides(&builder, &CliOverridesPatch::default(), Some("gpt-5"));
+    assert_eq!(resolved.config_overrides.len(), 1);
+    assert_eq!(resolved.config_overrides[0].value, "high");
+}
+
+#[test]
+fn request_can_disable_auto_reasoning_defaults() {
+    let builder = CliOverrides::default();
+    let patch = CliOverridesPatch {
+        auto_reasoning_defaults: Some(false),
+        ..Default::default()
+    };
+
+    let resolved = resolve_cli_overrides(&builder, &patch, Some("gpt-5"));
+    assert!(resolved.config_overrides.is_empty());
+}
+
+#[test]
+fn request_config_overrides_follow_builder_order() {
+    let mut builder_overrides = CliOverrides {
+        auto_reasoning_defaults: false,
+        ..Default::default()
+    };
+    builder_overrides
+        .config_overrides
+        .push(ConfigOverride::new("foo", "bar"));
+
+    let mut patch = CliOverridesPatch::default();
+    patch
+        .config_overrides
+        .push(ConfigOverride::new("foo", "baz"));
+
+    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
+    let values: Vec<_> = resolved
+        .config_overrides
+        .iter()
+        .map(|override_| override_.value.as_str())
+        .collect();
+    assert_eq!(values, vec!["bar", "baz"]);
+}
+
+#[test]
+fn request_search_override_can_disable_builder_flag() {
+    let builder_overrides = CliOverrides {
+        search: FlagState::Enable,
+        ..Default::default()
+    };
+
+    let patch = CliOverridesPatch {
+        search: FlagState::Disable,
+        ..Default::default()
+    };
+
+    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
+    let args = cli_override_args(&resolved, true);
+    let args: Vec<_> = args
+        .iter()
+        .map(|arg| arg.to_string_lossy().into_owned())
+        .collect();
+    assert!(!args.contains(&"--search".to_string()));
+}
+
+#[test]
+fn request_profile_override_replaces_builder_value() {
+    let builder_overrides = CliOverrides {
+        profile: Some("builder".to_string()),
+        ..Default::default()
+    };
+
+    let patch = CliOverridesPatch {
+        profile: Some("request".to_string()),
+        ..Default::default()
+    };
+
+    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
+    let args: Vec<_> = cli_override_args(&resolved, true)
+        .iter()
+        .map(|arg| arg.to_string_lossy().into_owned())
+        .collect();
+    assert!(args.windows(2).any(|window| {
+        window.first().map(String::as_str) == Some("--profile")
+            && window.get(1).map(String::as_str) == Some("request")
+    }));
+    assert!(!args.contains(&"builder".to_string()));
+}
+
+#[test]
+fn request_oss_override_can_disable_builder_flag() {
+    let builder_overrides = CliOverrides {
+        oss: FlagState::Enable,
+        ..Default::default()
+    };
+
+    let resolved = resolve_cli_overrides(&builder_overrides, &CliOverridesPatch::default(), None);
+    let args: Vec<_> = cli_override_args(&resolved, true)
+        .iter()
+        .map(|arg| arg.to_string_lossy().into_owned())
+        .collect();
+    assert!(args.contains(&"--oss".to_string()));
+
+    let patch = CliOverridesPatch {
+        oss: FlagState::Disable,
+        ..Default::default()
+    };
+    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
+    let args: Vec<_> = cli_override_args(&resolved, true)
+        .iter()
+        .map(|arg| arg.to_string_lossy().into_owned())
+        .collect();
+    assert!(!args.contains(&"--oss".to_string()));
+}
+
+#[test]
+fn feature_toggles_merge_builder_and_request() {
+    let mut builder_overrides = CliOverrides::default();
+    builder_overrides
+        .feature_toggles
+        .enable
+        .push("builder-enable".to_string());
+    builder_overrides
+        .feature_toggles
+        .disable
+        .push("builder-disable".to_string());
+
+    let mut patch = CliOverridesPatch::default();
+    patch
+        .feature_toggles
+        .enable
+        .push("request-enable".to_string());
+    patch
+        .feature_toggles
+        .disable
+        .push("request-disable".to_string());
+
+    let resolved = resolve_cli_overrides(&builder_overrides, &patch, None);
+    let args: Vec<_> = cli_override_args(&resolved, true)
+        .iter()
+        .map(|arg| arg.to_string_lossy().into_owned())
+        .collect();
+
+    assert!(args.windows(2).any(|window| {
+        window.first().map(String::as_str) == Some("--enable")
+            && window.get(1).map(String::as_str) == Some("builder-enable")
+    }));
+    assert!(args.windows(2).any(|window| {
+        window.first().map(String::as_str) == Some("--enable")
+            && window.get(1).map(String::as_str) == Some("request-enable")
+    }));
+    assert!(args.windows(2).any(|window| {
+        window.first().map(String::as_str) == Some("--disable")
+            && window.get(1).map(String::as_str) == Some("builder-disable")
+    }));
+    assert!(args.windows(2).any(|window| {
+        window.first().map(String::as_str) == Some("--disable")
+            && window.get(1).map(String::as_str) == Some("request-disable")
+    }));
+}
+
+#[test]
+fn cli_override_args_apply_safety_precedence() {
+    let mut resolved = ResolvedCliOverrides {
+        config_overrides: Vec::new(),
+        feature_toggles: FeatureToggles::default(),
+        approval_policy: None,
+        sandbox_mode: None,
+        safety_override: SafetyOverride::FullAuto,
+        profile: None,
+        cd: None,
+        local_provider: None,
+        oss: false,
+        search: FlagState::Enable,
+    };
+    let args = cli_override_args(&resolved, true);
+    let args: Vec<_> = args
+        .iter()
+        .map(|value| value.to_string_lossy().into_owned())
+        .collect();
+    assert!(args.contains(&"--full-auto".to_string()));
+    assert!(args.contains(&"--search".to_string()));
+    assert!(!args.contains(&"--ask-for-approval".to_string()));
+
+    resolved.approval_policy = Some(ApprovalPolicy::OnRequest);
+    let args_with_policy = cli_override_args(&resolved, true);
+    let args_with_policy: Vec<_> = args_with_policy
+        .iter()
+        .map(|value| value.to_string_lossy().into_owned())
+        .collect();
+    assert!(!args_with_policy.contains(&"--full-auto".to_string()));
+    assert!(args_with_policy.contains(&"--ask-for-approval".to_string()));
+
+    let resolved = ResolvedCliOverrides {
+        config_overrides: vec![ConfigOverride::new("foo", "bar")],
+        feature_toggles: FeatureToggles::default(),
+        approval_policy: Some(ApprovalPolicy::OnRequest),
+        sandbox_mode: Some(SandboxMode::WorkspaceWrite),
+        safety_override: SafetyOverride::DangerouslyBypass,
+        profile: Some("team".to_string()),
+        cd: Some(PathBuf::from("/tmp/worktree")),
+        local_provider: Some(LocalProvider::Ollama),
+        oss: false,
+        search: FlagState::Enable,
+    };
+    let args = cli_override_args(&resolved, true);
+    let args: Vec<_> = args
+        .iter()
+        .map(|value| value.to_string_lossy().into_owned())
+        .collect();
+    assert!(args.contains(&"--config".to_string()));
+    assert!(args.contains(&"foo=bar".to_string()));
+    assert!(args.contains(&"--dangerously-bypass-approvals-and-sandbox".to_string()));
+    assert!(args.contains(&"--profile".to_string()));
+    assert!(args.contains(&"team".to_string()));
+    assert!(args.contains(&"--cd".to_string()));
+    assert!(args.contains(&"/tmp/worktree".to_string()));
+    assert!(args.contains(&"--local-provider".to_string()));
+    assert!(args.contains(&"ollama".to_string()));
+    assert!(args.contains(&"--search".to_string()));
+    assert!(!args.contains(&"--ask-for-approval".to_string()));
+    assert!(!args.contains(&"--sandbox".to_string()));
+
+    let args_without_search = cli_override_args(&resolved, false);
+    let args_without_search: Vec<_> = args_without_search
+        .iter()
+        .map(|value| value.to_string_lossy().into_owned())
+        .collect();
+    assert!(!args_without_search.contains(&"--search".to_string()));
+}
+
+#[tokio::test]
+async fn exec_applies_cli_overrides_and_request_patch() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("exec.log");
+    let builder_cd = temp.path().join("builder-cd");
+    let request_cd = temp.path().join("request-cd");
+    let script = format!(
+        r#"#!/bin/bash
+echo "$@" >> "{log}"
+if [[ "$1" == "exec" ]]; then
+  echo "ok"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .mirror_stdout(false)
+        .quiet(true)
+        .auto_reasoning_defaults(false)
+        .config_override("foo", "bar")
+        .reasoning_summary(ReasoningSummary::Concise)
+        .approval_policy(ApprovalPolicy::OnRequest)
+        .sandbox_mode(SandboxMode::WorkspaceWrite)
+        .cd(&builder_cd)
+        .local_provider(LocalProvider::Custom)
+        .oss(true)
+        .enable_feature("builder-on")
+        .disable_feature("builder-off")
+        .search(true)
+        .build();
+
+    let mut request = ExecRequest::new("list flags")
+        .config_override("extra", "value")
+        .oss(false)
+        .enable_feature("request-on")
+        .disable_feature("request-off")
+        .search(false);
+    request.overrides.cd = Some(request_cd.clone());
+    request.overrides.safety_override = Some(SafetyOverride::DangerouslyBypass);
+
+    let response = client.send_prompt_with(request).await.unwrap();
+    assert_eq!(response.trim(), "ok");
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(logged.contains("--config"));
+    assert!(logged.contains("foo=bar"));
+    assert!(logged.contains("extra=value"));
+    assert!(logged.contains("model_reasoning_summary=concise"));
+    assert!(logged.contains("--dangerously-bypass-approvals-and-sandbox"));
+    assert!(logged.contains(&request_cd.display().to_string()));
+    assert!(!logged.contains(&builder_cd.display().to_string()));
+    assert!(logged.contains("--local-provider"));
+    assert!(logged.contains("custom"));
+    assert!(logged.contains("--enable"));
+    assert!(logged.contains("builder-on"));
+    assert!(logged.contains("request-on"));
+    assert!(logged.contains("--disable"));
+    assert!(logged.contains("builder-off"));
+    assert!(logged.contains("request-off"));
+    assert!(!logged.contains("--oss"));
+    assert!(!logged.contains("--ask-for-approval"));
+    assert!(!logged.contains("--sandbox"));
+    assert!(!logged.contains("--search"));
+}
+
+#[tokio::test]
+async fn resume_applies_search_and_selector_overrides() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("resume.log");
+    let builder_cd = temp.path().join("builder-cd");
+    let request_cd = temp.path().join("request-cd");
+    let script = format!(
+        r#"#!/bin/bash
+echo "$@" >> "{log}"
+if [[ "$1" == "exec" ]]; then
+  echo '{{"type":"thread.started","thread_id":"thread-1"}}'
+  echo '{{"type":"turn.started","thread_id":"thread-1","turn_id":"turn-1"}}'
+  echo '{{"type":"turn.completed","thread_id":"thread-1","turn_id":"turn-1"}}'
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .mirror_stdout(false)
+        .quiet(true)
+        .config_override("resume_hint", "enabled")
+        .approval_policy(ApprovalPolicy::OnRequest)
+        .sandbox_mode(SandboxMode::WorkspaceWrite)
+        .local_provider(LocalProvider::Ollama)
+        .cd(&builder_cd)
+        .search(true)
+        .build();
+
+    let request_last = ResumeRequest::last().prompt("continue");
+    let stream = client.stream_resume(request_last).await.unwrap();
+    let events: Vec<_> = stream.events.collect().await;
+    assert_eq!(events.len(), 3);
+    stream.completion.await.unwrap();
+
+    let mut request_all = ResumeRequest::all().prompt("summarize");
+    request_all.overrides.search = FlagState::Disable;
+    request_all.overrides.safety_override = Some(SafetyOverride::DangerouslyBypass);
+    request_all.overrides.cd = Some(request_cd.clone());
+    let stream_all = client.stream_resume(request_all).await.unwrap();
+    let _ = stream_all.events.collect::<Vec<_>>().await;
+    stream_all.completion.await.unwrap();
+
+    let logged: Vec<_> = std_fs::read_to_string(&log_path)
+        .unwrap()
+        .lines()
+        .map(str::to_string)
+        .collect();
+    assert!(logged.len() >= 2);
+
+    assert!(logged[0].contains("--last"));
+    assert!(logged[0].contains("--search"));
+    assert!(logged[0].contains("resume_hint=enabled"));
+    assert!(logged[0].contains("--ask-for-approval"));
+    assert!(logged[0].contains("--sandbox"));
+    assert!(logged[0].contains(&builder_cd.display().to_string()));
+    assert!(logged[0].contains("ollama"));
+
+    assert!(logged[1].contains("--all"));
+    assert!(logged[1].contains("--dangerously-bypass-approvals-and-sandbox"));
+    assert!(logged[1].contains(&request_cd.display().to_string()));
+    assert!(!logged[1].contains(&builder_cd.display().to_string()));
+    assert!(!logged[1].contains("--ask-for-approval"));
+    assert!(!logged[1].contains("--sandbox"));
+    assert!(!logged[1].contains("--search"));
+}
+
+#[tokio::test]
+async fn apply_respects_cli_overrides_without_search() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("apply.log");
+    let script = format!(
+        r#"#!/bin/bash
+echo "$@" >> "{log}"
+if [[ "$1" == "apply" ]]; then
+  echo "applied"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .mirror_stdout(false)
+        .quiet(true)
+        .cd(temp.path().join("apply-cd"))
+        .config_override("feature.toggle", "true")
+        .search(true)
+        .build();
+
+    let artifacts = client.apply().await.unwrap();
+    assert_eq!(artifacts.stdout.trim(), "applied");
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(logged.contains("--config"));
+    assert!(logged.contains("feature.toggle=true"));
+    assert!(logged.contains("apply-cd"));
+    assert!(!logged.contains("--search"));
+}
+
+#[test]
+fn color_mode_strings_are_stable() {
+    assert_eq!(ColorMode::Auto.as_str(), "auto");
+    assert_eq!(ColorMode::Always.as_str(), "always");
+    assert_eq!(ColorMode::Never.as_str(), "never");
+}
diff --git a/crates/codex/src/tests/jsonl_stream.rs b/crates/codex/src/tests/jsonl_stream.rs
new file mode 100644
index 0000000..25483b5
--- /dev/null
+++ b/crates/codex/src/tests/jsonl_stream.rs
@@ -0,0 +1,307 @@
+use super::*;
+
+#[tokio::test]
+async fn json_stream_preserves_order_and_parses_tool_calls() {
+    let lines = [
+        r#"{"type":"thread.started","thread_id":"thread-1"}"#.to_string(),
+        serde_json::to_string(&json!({
+            "type": "item.started",
+            "thread_id": "thread-1",
+            "turn_id": "turn-1",
+            "item_id": "item-1",
+            "item_type": "mcp_tool_call",
+            "content": {
+                "server_name": "files",
+                "tool_name": "list",
+                "status": "running"
+            }
+        }))
+        .unwrap(),
+        serde_json::to_string(&json!({
+            "type": "item.delta",
+            "thread_id": "thread-1",
+            "turn_id": "turn-1",
+            "item_id": "item-1",
+            "item_type": "mcp_tool_call",
+            "delta": {
+                "result": {"paths": ["foo.rs"]},
+                "status": "completed"
+            }
+        }))
+        .unwrap(),
+    ];
+
+    let (mut writer, reader) = tokio::io::duplex(4096);
+    let (tx, rx) = mpsc::channel(8);
+    let forward_handle = tokio::spawn(crate::jsonl::forward_json_events(reader, tx, false, None));
+
+    for line in &lines {
+        writer.write_all(line.as_bytes()).await.unwrap();
+        writer.write_all(b"\n").await.unwrap();
+    }
+    writer.shutdown().await.unwrap();
+
+    let stream = crate::jsonl::EventChannelStream::new(rx, None);
+    pin_mut!(stream);
+    let events: Vec<_> = stream.collect().await;
+    forward_handle.await.unwrap().unwrap();
+
+    assert_eq!(events.len(), lines.len(), "events: {events:?}");
+
+    match &events[0] {
+        Ok(ThreadEvent::ThreadStarted(event)) => {
+            assert_eq!(event.thread_id, "thread-1");
+        }
+        other => panic!("unexpected first event: {other:?}"),
+    }
+
+    match &events[1] {
+        Ok(ThreadEvent::ItemStarted(envelope)) => {
+            assert_eq!(envelope.thread_id, "thread-1");
+            assert_eq!(envelope.turn_id, "turn-1");
+            match &envelope.item.payload {
+                ItemPayload::McpToolCall(state) => {
+                    assert_eq!(state.server_name, "files");
+                    assert_eq!(state.tool_name, "list");
+                    assert_eq!(state.status, ToolCallStatus::Running);
+                }
+                other => panic!("unexpected payload: {other:?}"),
+            }
+        }
+        other => panic!("unexpected second event: {other:?}"),
+    }
+
+    match &events[2] {
+        Ok(ThreadEvent::ItemDelta(delta)) => {
+            assert_eq!(delta.item_id, "item-1");
+            match &delta.delta {
+                ItemDeltaPayload::McpToolCall(call_delta) => {
+                    assert_eq!(call_delta.status, ToolCallStatus::Completed);
+                    let result = call_delta
+                        .result
+                        .as_ref()
+                        .expect("tool call delta result is captured");
+                    assert_eq!(result["paths"][0], "foo.rs");
+                }
+                other => panic!("unexpected delta payload: {other:?}"),
+            }
+        }
+        other => panic!("unexpected third event: {other:?}"),
+    }
+}
+
+#[tokio::test]
+async fn json_stream_propagates_parse_errors() {
+    let (mut writer, reader) = tokio::io::duplex(1024);
+    let (tx, rx) = mpsc::channel(4);
+    let forward_handle = tokio::spawn(crate::jsonl::forward_json_events(reader, tx, false, None));
+
+    writer
+        .write_all(br#"{"type":"thread.started","thread_id":"thread-err"}"#)
+        .await
+        .unwrap();
+    writer.write_all(b"\nthis is not json\n").await.unwrap();
+    writer.shutdown().await.unwrap();
+
+    let stream = crate::jsonl::EventChannelStream::new(rx, None);
+    pin_mut!(stream);
+    let events: Vec<_> = stream.collect().await;
+    forward_handle.await.unwrap().unwrap();
+
+    assert_eq!(events.len(), 2);
+    assert!(matches!(
+        events[0],
+        Ok(ThreadEvent::ThreadStarted(ThreadStarted { ref thread_id, .. }))
+            if thread_id == "thread-err"
+    ));
+    match &events[1] {
+        Err(ExecStreamError::Parse { line, .. }) => assert_eq!(line, "this is not json"),
+        other => panic!("expected parse error, got {other:?}"),
+    }
+}
+
+#[tokio::test]
+async fn json_stream_tees_logs_before_forwarding() {
+    let lines = [
+        r#"{"type":"thread.started","thread_id":"tee-thread"}"#.to_string(),
+        r#"{"type":"turn.started","thread_id":"tee-thread","turn_id":"turn-tee"}"#.to_string(),
+    ];
+
+    let dir = tempfile::tempdir().unwrap();
+    let log_path = dir.path().join("events.log");
+
+    let (mut writer, reader) = tokio::io::duplex(2048);
+    let (tx, rx) = mpsc::channel(4);
+    let log_sink = crate::jsonl::JsonLogSink::new(log_path.clone())
+        .await
+        .unwrap();
+    let forward_handle = tokio::spawn(crate::jsonl::forward_json_events(
+        reader,
+        tx,
+        false,
+        Some(log_sink),
+    ));
+
+    let stream = crate::jsonl::EventChannelStream::new(rx, None);
+    pin_mut!(stream);
+
+    writer.write_all(lines[0].as_bytes()).await.unwrap();
+    writer.write_all(b"\n").await.unwrap();
+
+    let first = stream.next().await.unwrap().unwrap();
+    assert!(matches!(first, ThreadEvent::ThreadStarted(_)));
+
+    let logged = fs::read_to_string(&log_path).await.unwrap();
+    assert_eq!(logged, format!("{}\n", lines[0]));
+
+    writer.write_all(lines[1].as_bytes()).await.unwrap();
+    writer.write_all(b"\n").await.unwrap();
+    writer.shutdown().await.unwrap();
+
+    let second = stream.next().await.unwrap().unwrap();
+    assert!(matches!(second, ThreadEvent::TurnStarted(_)));
+    assert!(stream.next().await.is_none());
+
+    forward_handle.await.unwrap().unwrap();
+
+    let final_log = fs::read_to_string(&log_path).await.unwrap();
+    assert_eq!(final_log, format!("{}\n{}\n", lines[0], lines[1]));
+}
+
+#[tokio::test]
+async fn json_event_log_captures_apply_diff_and_tool_payloads() {
+    let diff = "@@ -1 +1 @@\n-fn foo() {}\n+fn bar() {}";
+    let lines = vec![
+        r#"{"type":"thread.started","thread_id":"log-thread"}"#.to_string(),
+        serde_json::to_string(&json!({
+            "type": "item.started",
+            "thread_id": "log-thread",
+            "turn_id": "turn-log",
+            "item_id": "apply-1",
+            "item_type": "file_change",
+            "content": {
+                "path": "src/main.rs",
+                "change": "apply",
+                "diff": diff,
+                "stdout": "patched\n"
+            }
+        }))
+        .unwrap(),
+        serde_json::to_string(&json!({
+            "type": "item.delta",
+            "thread_id": "log-thread",
+            "turn_id": "turn-log",
+            "item_id": "apply-1",
+            "item_type": "file_change",
+            "delta": {
+                "diff": diff,
+                "stderr": "warning",
+                "exit_code": 2
+            }
+        }))
+        .unwrap(),
+        serde_json::to_string(&json!({
+            "type": "item.delta",
+            "thread_id": "log-thread",
+            "turn_id": "turn-log",
+            "item_id": "tool-1",
+            "item_type": "mcp_tool_call",
+            "delta": {
+                "result": {"paths": ["a.rs", "b.rs"]},
+                "status": "completed"
+            }
+        }))
+        .unwrap(),
+    ];
+
+    let dir = tempfile::tempdir().unwrap();
+    let log_path = dir.path().join("json.log");
+
+    let (mut writer, reader) = tokio::io::duplex(4096);
+    let (tx, rx) = mpsc::channel(8);
+    let log_sink = crate::jsonl::JsonLogSink::new(log_path.clone())
+        .await
+        .unwrap();
+    let forward_handle = tokio::spawn(crate::jsonl::forward_json_events(
+        reader,
+        tx,
+        false,
+        Some(log_sink),
+    ));
+
+    for line in &lines {
+        writer.write_all(line.as_bytes()).await.unwrap();
+        writer.write_all(b"\n").await.unwrap();
+    }
+    writer.shutdown().await.unwrap();
+
+    let stream = crate::jsonl::EventChannelStream::new(rx, None);
+    pin_mut!(stream);
+    let events: Vec<_> = stream.collect().await;
+    forward_handle.await.unwrap().unwrap();
+
+    assert_eq!(events.len(), lines.len());
+
+    let log_contents = fs::read_to_string(&log_path).await.unwrap();
+    assert_eq!(log_contents, lines.join("\n") + "\n");
+}
+
+#[tokio::test]
+async fn event_channel_stream_times_out_when_idle() {
+    let (_tx, rx) = mpsc::channel(1);
+    let stream = crate::jsonl::EventChannelStream::new(rx, Some(Duration::from_millis(5)));
+    pin_mut!(stream);
+
+    let next = stream.next().await;
+    match next {
+        Some(Err(ExecStreamError::IdleTimeout { idle_for })) => {
+            assert_eq!(idle_for, Duration::from_millis(5));
+        }
+        other => panic!("expected idle timeout, got {other:?}"),
+    }
+}
+
+#[test]
+fn normalize_stream_infers_missing_thread_and_turn() {
+    let mut context = crate::jsonl::StreamContext::default();
+    // thread.started establishes thread context
+    let thread_line = r#"{"type":"thread.started","thread_id":"thread-1"}"#;
+    let thread_event = crate::jsonl::normalize_thread_event(thread_line, &mut context).unwrap();
+    match thread_event {
+        ThreadEvent::ThreadStarted(t) => assert_eq!(t.thread_id, "thread-1"),
+        other => panic!("unexpected event: {other:?}"),
+    }
+    // turn.started without thread_id should inherit
+    let turn_line = r#"{"type":"turn.started","turn_id":"turn-1"}"#;
+    let turn_event = crate::jsonl::normalize_thread_event(turn_line, &mut context).unwrap();
+    match turn_event {
+        ThreadEvent::TurnStarted(t) => {
+            assert_eq!(t.thread_id, "thread-1");
+            assert_eq!(t.turn_id, "turn-1");
+        }
+        other => panic!("unexpected event: {other:?}"),
+    }
+    // item.completed without ids should inherit both
+    let item_line =
+        r#"{"type":"item.completed","item":{"id":"msg-1","type":"agent_message","text":"hi"}}"#;
+    let item_event = crate::jsonl::normalize_thread_event(item_line, &mut context).unwrap();
+    match item_event {
+        ThreadEvent::ItemCompleted(item) => {
+            assert_eq!(item.turn_id, "turn-1");
+            assert_eq!(item.thread_id, "thread-1");
+            assert_eq!(item.item.item_id, "msg-1");
+        }
+        other => panic!("unexpected event: {other:?}"),
+    }
+}
+
+#[test]
+fn normalize_stream_errors_without_context() {
+    let mut context = crate::jsonl::StreamContext::default();
+    let line = r#"{"type":"turn.started"}"#;
+    let err = crate::jsonl::normalize_thread_event(line, &mut context).unwrap_err();
+    match err {
+        ExecStreamError::Normalize { .. } => {}
+        other => panic!("unexpected error: {other:?}"),
+    }
+}
diff --git a/crates/codex/src/tests/mod.rs b/crates/codex/src/tests/mod.rs
new file mode 100644
index 0000000..6aa0ff0
--- /dev/null
+++ b/crates/codex/src/tests/mod.rs
@@ -0,0 +1,63 @@
+use super::*;
+use crate::auth::parse_login_success;
+use crate::builder::ResolvedCliOverrides;
+use crate::defaults::{
+    default_binary_path, default_rust_log_value, CODEX_BINARY_ENV, CODEX_HOME_ENV,
+    DEFAULT_RUST_LOG, DEFAULT_TIMEOUT, RUST_LOG_ENV,
+};
+use futures_util::{pin_mut, StreamExt};
+use semver::Version;
+use serde_json::json;
+use std::collections::HashMap;
+use std::env;
+use std::fs as std_fs;
+#[cfg(unix)]
+use std::os::unix::fs::PermissionsExt;
+use std::sync::OnceLock;
+use std::time::{Duration, SystemTime};
+use tokio::{
+    fs,
+    io::{AsyncBufReadExt, AsyncWriteExt, BufReader},
+};
+
+fn env_mutex() -> &'static tokio::sync::Mutex<()> {
+    static ENV_MUTEX: OnceLock<tokio::sync::Mutex<()>> = OnceLock::new();
+    ENV_MUTEX.get_or_init(|| tokio::sync::Mutex::new(()))
+}
+
+fn env_guard() -> tokio::sync::MutexGuard<'static, ()> {
+    env_mutex().blocking_lock()
+}
+
+async fn env_guard_async() -> tokio::sync::MutexGuard<'static, ()> {
+    env_mutex().lock().await
+}
+
+fn write_executable(dir: &Path, name: &str, script: &str) -> PathBuf {
+    let path = dir.join(name);
+    std_fs::write(&path, script).unwrap();
+    let mut perms = std_fs::metadata(&path).unwrap().permissions();
+    #[cfg(unix)]
+    {
+        perms.set_mode(0o755);
+    }
+    std_fs::set_permissions(&path, perms).unwrap();
+    path
+}
+
+fn write_fake_codex(dir: &Path, script: &str) -> PathBuf {
+    write_executable(dir, "codex", script)
+}
+
+fn write_fake_bundled_codex(dir: &Path, platform: &str, script: &str) -> PathBuf {
+    write_executable(dir, bundled_binary_filename(platform), script)
+}
+
+mod auth_session;
+mod builder_env_home;
+mod bundled_binary;
+mod capabilities;
+mod cli_commands;
+mod cli_overrides;
+mod jsonl_stream;
+mod sandbox_execpolicy;
diff --git a/crates/codex/src/tests/sandbox_execpolicy.rs b/crates/codex/src/tests/sandbox_execpolicy.rs
new file mode 100644
index 0000000..140e4e7
--- /dev/null
+++ b/crates/codex/src/tests/sandbox_execpolicy.rs
@@ -0,0 +1,314 @@
+use super::*;
+
+#[cfg(unix)]
+#[tokio::test]
+async fn sandbox_maps_platform_flags_and_command() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+echo "$PWD"
+printf "%s\n" "$@"
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let request = SandboxCommandRequest::new(
+        SandboxPlatform::Linux,
+        [OsString::from("echo"), OsString::from("hello world")],
+    )
+    .full_auto(true)
+    .log_denials(true)
+    .config_override("foo", "bar")
+    .enable_feature("alpha")
+    .disable_feature("beta");
+
+    let run = client.run_sandbox(request).await.unwrap();
+    let mut lines = run.stdout.lines();
+    let pwd = lines.next().unwrap();
+    assert_eq!(Path::new(pwd), env::current_dir().unwrap().as_path());
+
+    let args: Vec<_> = lines.map(str::to_string).collect();
+    assert!(!args.contains(&"--log-denials".to_string()));
+    assert_eq!(
+        args,
+        vec![
+            "sandbox",
+            "linux",
+            "--full-auto",
+            "--config",
+            "foo=bar",
+            "--enable",
+            "alpha",
+            "--disable",
+            "beta",
+            "--",
+            "echo",
+            "hello world"
+        ]
+    );
+    assert!(run.status.success());
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn sandbox_includes_log_denials_on_macos() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+printf "%s\n" "$@"
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let run = client
+        .run_sandbox(SandboxCommandRequest::new(SandboxPlatform::Macos, ["ls"]).log_denials(true))
+        .await
+        .unwrap();
+    let args: Vec<_> = run.stdout.lines().collect();
+    assert!(args.contains(&"--log-denials"));
+    assert_eq!(args[0], "sandbox");
+    assert_eq!(args[1], "macos");
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn sandbox_honors_working_dir_precedence() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+echo "$PWD"
+"#,
+    );
+
+    let request_dir = dir.path().join("request_cwd");
+    let builder_dir = dir.path().join("builder_cwd");
+    std_fs::create_dir_all(&request_dir).unwrap();
+    std_fs::create_dir_all(&builder_dir).unwrap();
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .working_dir(&builder_dir)
+        .build();
+
+    let run_request = client
+        .run_sandbox(
+            SandboxCommandRequest::new(SandboxPlatform::Windows, ["echo", "cwd"])
+                .working_dir(&request_dir),
+        )
+        .await
+        .unwrap();
+    let request_pwd = run_request.stdout.lines().next().unwrap();
+    assert_eq!(Path::new(request_pwd), request_dir.as_path());
+
+    let run_builder = client
+        .run_sandbox(SandboxCommandRequest::new(
+            SandboxPlatform::Windows,
+            ["echo", "builder"],
+        ))
+        .await
+        .unwrap();
+    let builder_pwd = run_builder.stdout.lines().next().unwrap();
+    assert_eq!(Path::new(builder_pwd), builder_dir.as_path());
+
+    let client_default = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+    let run_default = client_default
+        .run_sandbox(SandboxCommandRequest::new(
+            SandboxPlatform::Windows,
+            ["echo", "default"],
+        ))
+        .await
+        .unwrap();
+    let default_pwd = run_default.stdout.lines().next().unwrap();
+    assert_eq!(
+        Path::new(default_pwd),
+        env::current_dir().unwrap().as_path()
+    );
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn sandbox_returns_non_zero_status_without_error() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = write_fake_codex(
+        dir.path(),
+        r#"#!/usr/bin/env bash
+echo "failing"
+exit 7
+"#,
+    );
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+    let run = client
+        .run_sandbox(SandboxCommandRequest::new(
+            SandboxPlatform::Linux,
+            ["false"],
+        ))
+        .await
+        .unwrap();
+
+    assert!(!run.status.success());
+    assert_eq!(run.status.code(), Some(7));
+    assert_eq!(run.stdout.trim(), "failing");
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn execpolicy_maps_policies_and_overrides() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = dir.path().join("codex-execpolicy");
+    std_fs::write(
+        &script_path,
+        r#"#!/usr/bin/env bash
+printf "%s\n" "$PWD" "$@" 1>&2
+cat <<'JSON'
+{"match":{"decision":"prompt","rules":[{"name":"rule1","decision":"forbidden"}]}}
+JSON
+"#,
+    )
+    .unwrap();
+    let mut perms = std_fs::metadata(&script_path).unwrap().permissions();
+    perms.set_mode(0o755);
+    std_fs::set_permissions(&script_path, perms).unwrap();
+
+    let workdir = dir.path().join("workdir");
+    std_fs::create_dir_all(&workdir).unwrap();
+    let policy_one = dir.path().join("policy_a.codexpolicy");
+    let policy_two = dir.path().join("policy_b.codexpolicy");
+    std_fs::write(&policy_one, "").unwrap();
+    std_fs::write(&policy_two, "").unwrap();
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .working_dir(&workdir)
+        .approval_policy(ApprovalPolicy::OnRequest)
+        .build();
+
+    let result = client
+        .check_execpolicy(
+            ExecPolicyCheckRequest::new([
+                OsString::from("bash"),
+                OsString::from("-lc"),
+                OsString::from("echo ok"),
+            ])
+            .policies([&policy_one, &policy_two])
+            .pretty(true)
+            .profile("dev")
+            .config_override("features.execpolicy", "true"),
+        )
+        .await
+        .unwrap();
+
+    assert_eq!(result.decision(), Some(ExecPolicyDecision::Prompt));
+    let match_result = result.evaluation.match_result.unwrap();
+    assert_eq!(match_result.rules.len(), 1);
+    assert_eq!(match_result.rules[0].name.as_deref(), Some("rule1"));
+    assert_eq!(
+        match_result.rules[0].decision,
+        Some(ExecPolicyDecision::Forbidden)
+    );
+
+    let mut lines = result.stderr.lines();
+    let pwd = lines.next().unwrap();
+    assert_eq!(Path::new(pwd), workdir.as_path());
+
+    let args: Vec<_> = lines.map(str::to_string).collect();
+    assert_eq!(
+        args,
+        vec![
+            "execpolicy",
+            "check",
+            "--policy",
+            policy_one.to_string_lossy().as_ref(),
+            "--policy",
+            policy_two.to_string_lossy().as_ref(),
+            "--pretty",
+            "--config",
+            "features.execpolicy=true",
+            "--profile",
+            "dev",
+            "--ask-for-approval",
+            "on-request",
+            "--",
+            "bash",
+            "-lc",
+            "echo ok"
+        ]
+    );
+}
+
+#[tokio::test]
+async fn execpolicy_rejects_empty_command() {
+    let client = CodexClient::builder().build();
+    let request = ExecPolicyCheckRequest::new(Vec::<OsString>::new());
+    let err = client.check_execpolicy(request).await.unwrap_err();
+    assert!(matches!(err, CodexError::EmptyExecPolicyCommand));
+}
+
+#[cfg(unix)]
+#[tokio::test]
+async fn execpolicy_surfaces_parse_errors() {
+    let dir = tempfile::tempdir().unwrap();
+    let script_path = dir.path().join("codex-execpolicy-bad");
+    std_fs::write(
+        &script_path,
+        r#"#!/usr/bin/env bash
+echo "not-json"
+"#,
+    )
+    .unwrap();
+    let mut perms = std_fs::metadata(&script_path).unwrap().permissions();
+    perms.set_mode(0o755);
+    std_fs::set_permissions(&script_path, perms).unwrap();
+
+    let client = CodexClient::builder()
+        .binary(&script_path)
+        .mirror_stdout(false)
+        .quiet(true)
+        .build();
+
+    let err = client
+        .check_execpolicy(
+            ExecPolicyCheckRequest::new([OsString::from("echo"), OsString::from("noop")])
+                .policy(dir.path().join("policy.codexpolicy")),
+        )
+        .await
+        .unwrap_err();
+
+    match err {
+        CodexError::ExecPolicyParse { stdout, .. } => assert!(stdout.contains("not-json")),
+        other => panic!("expected ExecPolicyParse, got {other:?}"),
+    }
+}
+
+#[tokio::test]
+async fn sandbox_rejects_empty_command() {
+    let client = CodexClient::builder().build();
+    let request = SandboxCommandRequest::new(SandboxPlatform::Linux, Vec::<OsString>::new());
+    let err = client.run_sandbox(request).await.unwrap_err();
+    assert!(matches!(err, CodexError::EmptySandboxCommand));
+}
diff --git a/crates/xtask/src/codex_report/report.rs b/crates/xtask/src/codex_report/report.rs
index f4d4f73..1ab463a 100644
--- a/crates/xtask/src/codex_report/report.rs
+++ b/crates/xtask/src/codex_report/report.rs
@@ -1,15 +1,30 @@
 use std::collections::{BTreeMap, BTreeSet};
 
-use serde::Serialize;
-
 use super::{
-    models::{UnionArgV2, UnionCommandV2, UnionFlagV2, UnionSnapshotV2, WrapperCoverageV1},
-    rules::{ParityExclusionUnit, RulesFile, RulesParityExclusions},
+    models::{UnionCommandV2, UnionSnapshotV2, WrapperCoverageV1},
+    rules::RulesFile,
     util,
-    wrapper::{self, CoverageResolution, FilterMode, WrapperIndex},
+    wrapper::{self, FilterMode, WrapperIndex},
     ReportError,
 };
 
+mod filtering;
+mod iu;
+mod parity;
+mod schema;
+
+use filtering::{
+    classify_arg_delta, classify_command_delta, classify_flag_delta, present_on_filter,
+    upstream_arg_availability, upstream_flag_availability,
+};
+use iu::{build_iu_roots, cmp_iu_delta, find_inherited_iu_root, require_non_empty_note};
+pub(super) use parity::{build_parity_exclusions_index, ParityExclusionsIndex};
+use schema::{
+    CoverageReportV1, PlatformFilterV1, ReportArgDeltaV1, ReportCommandDeltaV1, ReportDeltasV1,
+    ReportFlagDeltaV1, ReportInputsV1, ReportIntentionallyUnsupportedDeltaV1, ReportRulesInputsV1,
+    ReportUpstreamInputsV1, ReportWrapperInputsV1,
+};
+
 pub(super) fn index_upstream(union: &UnionSnapshotV2) -> BTreeMap<Vec<String>, UnionCommandV2> {
     let mut out = BTreeMap::new();
     for cmd in &union.commands {
@@ -534,454 +549,3 @@ pub(super) fn build_report(
         deltas,
     })
 }
-
-fn present_on_filter(
-    available_on: &[String],
-    report_targets: &BTreeSet<String>,
-    expected_targets: &[String],
-    mode: FilterMode<'_>,
-) -> bool {
-    match mode {
-        FilterMode::Any => available_on.iter().any(|t| report_targets.contains(t)),
-        FilterMode::ExactTarget(t) => available_on.iter().any(|x| x == t),
-        FilterMode::All => expected_targets
-            .iter()
-            .all(|t| available_on.iter().any(|x| x == t)),
-    }
-}
-
-fn classify_command_delta(
-    missing: &mut Vec<ReportCommandDeltaV1>,
-    passthrough_candidates: &mut Vec<ReportCommandDeltaV1>,
-    unsupported: &mut Vec<ReportCommandDeltaV1>,
-    path: &[String],
-    upstream_available_on: &[String],
-    wrapper: &CoverageResolution,
-) {
-    let entry = ReportCommandDeltaV1 {
-        path: path.to_vec(),
-        upstream_available_on: upstream_available_on.to_vec(),
-        wrapper_level: wrapper.level.clone(),
-        note: wrapper.note.clone(),
-    };
-
-    match wrapper.level.as_deref() {
-        None => missing.push(entry),
-        Some("unknown") => missing.push(entry),
-        Some("unsupported") => unsupported.push(entry),
-        Some("intentionally_unsupported") => {}
-        Some("passthrough") => passthrough_candidates.push(entry),
-        Some("explicit") => {}
-        Some(other) => missing.push(ReportCommandDeltaV1 {
-            wrapper_level: Some(other.to_string()),
-            ..entry
-        }),
-    }
-}
-
-fn classify_flag_delta(
-    out: &mut Vec<ReportFlagDeltaV1>,
-    path: &[String],
-    flag: &UnionFlagV2,
-    wrapper: &CoverageResolution,
-) {
-    match wrapper.level.as_deref() {
-        None | Some("unknown") | Some("unsupported") => out.push(ReportFlagDeltaV1 {
-            path: path.to_vec(),
-            key: flag.key.clone(),
-            upstream_available_on: flag.available_on.clone(),
-            wrapper_level: wrapper.level.clone(),
-            note: wrapper.note.clone(),
-        }),
-        Some("intentionally_unsupported") => {}
-        Some("explicit") | Some("passthrough") => {}
-        Some(other) => out.push(ReportFlagDeltaV1 {
-            path: path.to_vec(),
-            key: flag.key.clone(),
-            upstream_available_on: flag.available_on.clone(),
-            wrapper_level: Some(other.to_string()),
-            note: wrapper.note.clone(),
-        }),
-    }
-}
-
-fn classify_arg_delta(
-    out: &mut Vec<ReportArgDeltaV1>,
-    path: &[String],
-    arg: &UnionArgV2,
-    wrapper: &CoverageResolution,
-) {
-    match wrapper.level.as_deref() {
-        None | Some("unknown") | Some("unsupported") => out.push(ReportArgDeltaV1 {
-            path: path.to_vec(),
-            name: arg.name.clone(),
-            upstream_available_on: arg.available_on.clone(),
-            wrapper_level: wrapper.level.clone(),
-            note: wrapper.note.clone(),
-        }),
-        Some("intentionally_unsupported") => {}
-        Some("explicit") | Some("passthrough") => {}
-        Some(other) => out.push(ReportArgDeltaV1 {
-            path: path.to_vec(),
-            name: arg.name.clone(),
-            upstream_available_on: arg.available_on.clone(),
-            wrapper_level: Some(other.to_string()),
-            note: wrapper.note.clone(),
-        }),
-    }
-}
-
-fn upstream_flag_availability(
-    upstream: &BTreeMap<Vec<String>, UnionCommandV2>,
-    path: &[String],
-    key: &str,
-    wrapper_res: &CoverageResolution,
-    report_targets: &BTreeSet<String>,
-    expected_targets: &[String],
-    mode: FilterMode<'_>,
-) -> (Vec<String>, bool) {
-    if let Some(cmd) = upstream.get(path) {
-        if let Some(flag) = cmd.flags.iter().find(|f| f.key == key) {
-            let present =
-                present_on_filter(&flag.available_on, report_targets, expected_targets, mode);
-            return (flag.available_on.clone(), present);
-        }
-        return (cmd.available_on.clone(), false);
-    }
-    (
-        util::ordered_subset(expected_targets, &wrapper_res.targets),
-        false,
-    )
-}
-
-fn upstream_arg_availability(
-    upstream: &BTreeMap<Vec<String>, UnionCommandV2>,
-    path: &[String],
-    name: &str,
-    wrapper_res: &CoverageResolution,
-    report_targets: &BTreeSet<String>,
-    expected_targets: &[String],
-    mode: FilterMode<'_>,
-) -> (Vec<String>, bool) {
-    if let Some(cmd) = upstream.get(path) {
-        if let Some(arg) = cmd.args.iter().find(|a| a.name == name) {
-            let present =
-                present_on_filter(&arg.available_on, report_targets, expected_targets, mode);
-            return (arg.available_on.clone(), present);
-        }
-        return (cmd.available_on.clone(), false);
-    }
-    (
-        util::ordered_subset(expected_targets, &wrapper_res.targets),
-        false,
-    )
-}
-
-#[derive(Debug, Serialize)]
-pub(super) struct CoverageReportV1 {
-    schema_version: u32,
-    generated_at: String,
-    inputs: ReportInputsV1,
-    platform_filter: PlatformFilterV1,
-    deltas: ReportDeltasV1,
-}
-
-#[derive(Debug, Serialize)]
-struct ReportInputsV1 {
-    upstream: ReportUpstreamInputsV1,
-    wrapper: ReportWrapperInputsV1,
-    rules: ReportRulesInputsV1,
-}
-
-#[derive(Debug, Serialize)]
-struct ReportUpstreamInputsV1 {
-    semantic_version: String,
-    mode: String,
-    targets: Vec<String>,
-}
-
-#[derive(Debug, Serialize)]
-struct ReportWrapperInputsV1 {
-    schema_version: u32,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    wrapper_version: Option<String>,
-}
-
-#[derive(Debug, Serialize)]
-struct ReportRulesInputsV1 {
-    rules_schema_version: u32,
-}
-
-#[derive(Debug, Serialize)]
-struct PlatformFilterV1 {
-    mode: String,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    target_triple: Option<String>,
-}
-
-#[derive(Debug, Serialize)]
-struct ReportDeltasV1 {
-    missing_commands: Vec<ReportCommandDeltaV1>,
-    missing_flags: Vec<ReportFlagDeltaV1>,
-    missing_args: Vec<ReportArgDeltaV1>,
-
-    #[serde(skip_serializing_if = "Option::is_none")]
-    excluded_commands: Option<Vec<ReportCommandDeltaV1>>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    excluded_flags: Option<Vec<ReportFlagDeltaV1>>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    excluded_args: Option<Vec<ReportArgDeltaV1>>,
-
-    #[serde(skip_serializing_if = "Option::is_none")]
-    passthrough_candidates: Option<Vec<ReportCommandDeltaV1>>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    unsupported: Option<Vec<ReportCommandDeltaV1>>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    intentionally_unsupported: Option<Vec<ReportIntentionallyUnsupportedDeltaV1>>,
-
-    #[serde(skip_serializing_if = "Option::is_none")]
-    wrapper_only_commands: Option<Vec<ReportCommandDeltaV1>>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    wrapper_only_flags: Option<Vec<ReportFlagDeltaV1>>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    wrapper_only_args: Option<Vec<ReportArgDeltaV1>>,
-}
-
-#[derive(Debug, Serialize)]
-struct ReportCommandDeltaV1 {
-    path: Vec<String>,
-    upstream_available_on: Vec<String>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    wrapper_level: Option<String>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    note: Option<String>,
-}
-
-#[derive(Debug, Serialize)]
-struct ReportFlagDeltaV1 {
-    path: Vec<String>,
-    key: String,
-    upstream_available_on: Vec<String>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    wrapper_level: Option<String>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    note: Option<String>,
-}
-
-#[derive(Debug, Serialize)]
-struct ReportArgDeltaV1 {
-    path: Vec<String>,
-    name: String,
-    upstream_available_on: Vec<String>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    wrapper_level: Option<String>,
-    #[serde(skip_serializing_if = "Option::is_none")]
-    note: Option<String>,
-}
-
-#[derive(Debug, Serialize)]
-#[serde(untagged)]
-enum ReportIntentionallyUnsupportedDeltaV1 {
-    Command(ReportCommandDeltaV1),
-    Flag(ReportFlagDeltaV1),
-    Arg(ReportArgDeltaV1),
-}
-
-#[derive(Debug, Clone)]
-struct IuRoot {
-    path: Vec<String>,
-    targets: BTreeSet<String>,
-    note: String,
-}
-
-fn build_iu_roots(
-    wrapper: &WrapperCoverageV1,
-    wrapper_index: &WrapperIndex,
-    report_target_set: &BTreeSet<String>,
-    expected_targets: &[String],
-    filter_mode: FilterMode<'_>,
-) -> Result<Vec<IuRoot>, ReportError> {
-    let mut unique_paths: BTreeSet<Vec<String>> = BTreeSet::new();
-    for cmd in &wrapper.coverage {
-        if cmd.level == "intentionally_unsupported" {
-            unique_paths.insert(cmd.path.clone());
-        }
-    }
-
-    let mut roots = Vec::new();
-    for path in unique_paths {
-        let res = wrapper::resolve_wrapper(
-            wrapper_index
-                .commands
-                .get(&path)
-                .map(Vec::as_slice)
-                .unwrap_or(&[]),
-            report_target_set,
-            expected_targets,
-            filter_mode,
-            "command",
-            &format!("path={}", util::format_path(&path)),
-        )?;
-        if res.level.as_deref() != Some("intentionally_unsupported") {
-            continue;
-        }
-        let note = require_non_empty_note(
-            res.note.as_deref(),
-            "command",
-            &format!("path={}", util::format_path(&path)),
-        )?;
-        roots.push(IuRoot {
-            path,
-            targets: res.targets,
-            note,
-        });
-    }
-
-    roots.sort_by(|a, b| {
-        b.path
-            .len()
-            .cmp(&a.path.len())
-            .then_with(|| util::cmp_path(&a.path, &b.path))
-    });
-    Ok(roots)
-}
-
-fn find_inherited_iu_root<'a>(
-    roots: &'a [IuRoot],
-    unit_path: &[String],
-    unit_available_on: &[String],
-    report_target_set: &BTreeSet<String>,
-    unit_kind: &'static str,
-) -> Result<Option<&'a IuRoot>, ReportError> {
-    let relevant_targets: BTreeSet<String> = unit_available_on
-        .iter()
-        .filter(|t| report_target_set.contains(*t))
-        .cloned()
-        .collect();
-    if relevant_targets.is_empty() {
-        return Ok(None);
-    }
-
-    for root in roots {
-        if !util::is_prefix(&root.path, unit_path) {
-            continue;
-        }
-
-        let overlap: BTreeSet<String> = relevant_targets
-            .intersection(&root.targets)
-            .cloned()
-            .collect();
-        if overlap.is_empty() {
-            continue;
-        }
-        if overlap != relevant_targets {
-            return Err(ReportError::WrapperResolution {
-                unit: unit_kind.to_string(),
-                detail: format!(
-                    "IU subtree root scope mismatch: root_path={} does not cover all upstream targets for unit_path={} (root_targets={} unit_targets={})",
-                    util::format_path(&root.path),
-                    util::format_path(unit_path),
-                    root.targets.iter().cloned().collect::<Vec<_>>().join(","),
-                    relevant_targets
-                        .iter()
-                        .cloned()
-                        .collect::<Vec<_>>()
-                        .join(","),
-                ),
-            });
-        }
-
-        return Ok(Some(root));
-    }
-
-    Ok(None)
-}
-
-fn require_non_empty_note(
-    note: Option<&str>,
-    unit_kind: &'static str,
-    detail: &str,
-) -> Result<String, ReportError> {
-    match note.map(str::trim).filter(|s| !s.is_empty()) {
-        Some(v) => Ok(v.to_string()),
-        None => Err(ReportError::WrapperResolution {
-            unit: unit_kind.to_string(),
-            detail: format!("{detail} intentionally_unsupported requires non-empty note"),
-        }),
-    }
-}
-
-fn iu_kind_rank(entry: &ReportIntentionallyUnsupportedDeltaV1) -> u8 {
-    match entry {
-        ReportIntentionallyUnsupportedDeltaV1::Command(_) => 0,
-        ReportIntentionallyUnsupportedDeltaV1::Flag(_) => 1,
-        ReportIntentionallyUnsupportedDeltaV1::Arg(_) => 2,
-    }
-}
-
-fn iu_path(entry: &ReportIntentionallyUnsupportedDeltaV1) -> &[String] {
-    match entry {
-        ReportIntentionallyUnsupportedDeltaV1::Command(v) => &v.path,
-        ReportIntentionallyUnsupportedDeltaV1::Flag(v) => &v.path,
-        ReportIntentionallyUnsupportedDeltaV1::Arg(v) => &v.path,
-    }
-}
-
-fn cmp_iu_delta(
-    a: &ReportIntentionallyUnsupportedDeltaV1,
-    b: &ReportIntentionallyUnsupportedDeltaV1,
-) -> std::cmp::Ordering {
-    iu_kind_rank(a).cmp(&iu_kind_rank(b)).then_with(|| {
-        util::cmp_path(iu_path(a), iu_path(b)).then_with(|| match (a, b) {
-            (
-                ReportIntentionallyUnsupportedDeltaV1::Flag(a),
-                ReportIntentionallyUnsupportedDeltaV1::Flag(b),
-            ) => a.key.cmp(&b.key),
-            (
-                ReportIntentionallyUnsupportedDeltaV1::Arg(a),
-                ReportIntentionallyUnsupportedDeltaV1::Arg(b),
-            ) => a.name.cmp(&b.name),
-            _ => std::cmp::Ordering::Equal,
-        })
-    })
-}
-
-#[derive(Debug)]
-pub(super) struct ParityExclusionsIndex {
-    commands: BTreeMap<Vec<String>, ParityExclusionUnit>,
-    flags: BTreeMap<(Vec<String>, String), ParityExclusionUnit>,
-    args: BTreeMap<(Vec<String>, String), ParityExclusionUnit>,
-}
-
-pub(super) fn build_parity_exclusions_index(
-    exclusions: &RulesParityExclusions,
-) -> ParityExclusionsIndex {
-    let mut commands = BTreeMap::new();
-    let mut flags = BTreeMap::new();
-    let mut args = BTreeMap::new();
-
-    for unit in &exclusions.units {
-        match unit.unit.as_str() {
-            "command" => {
-                commands.insert(unit.path.clone(), unit.clone());
-            }
-            "flag" => {
-                if let Some(key) = unit.key.as_ref() {
-                    flags.insert((unit.path.clone(), key.clone()), unit.clone());
-                }
-            }
-            "arg" => {
-                if let Some(name) = unit.name.as_ref() {
-                    args.insert((unit.path.clone(), name.clone()), unit.clone());
-                }
-            }
-            _ => {}
-        }
-    }
-
-    ParityExclusionsIndex {
-        commands,
-        flags,
-        args,
-    }
-}
diff --git a/crates/xtask/src/codex_report/report/filtering.rs b/crates/xtask/src/codex_report/report/filtering.rs
new file mode 100644
index 0000000..ae5f63a
--- /dev/null
+++ b/crates/xtask/src/codex_report/report/filtering.rs
@@ -0,0 +1,152 @@
+use std::collections::{BTreeMap, BTreeSet};
+
+use super::{
+    super::{
+        models::{UnionArgV2, UnionCommandV2, UnionFlagV2},
+        util,
+        wrapper::{CoverageResolution, FilterMode},
+    },
+    schema::{ReportArgDeltaV1, ReportCommandDeltaV1, ReportFlagDeltaV1},
+};
+
+pub(super) fn present_on_filter(
+    available_on: &[String],
+    report_targets: &BTreeSet<String>,
+    expected_targets: &[String],
+    mode: FilterMode<'_>,
+) -> bool {
+    match mode {
+        FilterMode::Any => available_on.iter().any(|t| report_targets.contains(t)),
+        FilterMode::ExactTarget(t) => available_on.iter().any(|x| x == t),
+        FilterMode::All => expected_targets
+            .iter()
+            .all(|t| available_on.iter().any(|x| x == t)),
+    }
+}
+
+pub(super) fn classify_command_delta(
+    missing: &mut Vec<ReportCommandDeltaV1>,
+    passthrough_candidates: &mut Vec<ReportCommandDeltaV1>,
+    unsupported: &mut Vec<ReportCommandDeltaV1>,
+    path: &[String],
+    upstream_available_on: &[String],
+    wrapper: &CoverageResolution,
+) {
+    let entry = ReportCommandDeltaV1 {
+        path: path.to_vec(),
+        upstream_available_on: upstream_available_on.to_vec(),
+        wrapper_level: wrapper.level.clone(),
+        note: wrapper.note.clone(),
+    };
+
+    match wrapper.level.as_deref() {
+        None => missing.push(entry),
+        Some("unknown") => missing.push(entry),
+        Some("unsupported") => unsupported.push(entry),
+        Some("intentionally_unsupported") => {}
+        Some("passthrough") => passthrough_candidates.push(entry),
+        Some("explicit") => {}
+        Some(other) => missing.push(ReportCommandDeltaV1 {
+            wrapper_level: Some(other.to_string()),
+            ..entry
+        }),
+    }
+}
+
+pub(super) fn classify_flag_delta(
+    out: &mut Vec<ReportFlagDeltaV1>,
+    path: &[String],
+    flag: &UnionFlagV2,
+    wrapper: &CoverageResolution,
+) {
+    match wrapper.level.as_deref() {
+        None | Some("unknown") | Some("unsupported") => out.push(ReportFlagDeltaV1 {
+            path: path.to_vec(),
+            key: flag.key.clone(),
+            upstream_available_on: flag.available_on.clone(),
+            wrapper_level: wrapper.level.clone(),
+            note: wrapper.note.clone(),
+        }),
+        Some("intentionally_unsupported") => {}
+        Some("explicit") | Some("passthrough") => {}
+        Some(other) => out.push(ReportFlagDeltaV1 {
+            path: path.to_vec(),
+            key: flag.key.clone(),
+            upstream_available_on: flag.available_on.clone(),
+            wrapper_level: Some(other.to_string()),
+            note: wrapper.note.clone(),
+        }),
+    }
+}
+
+pub(super) fn classify_arg_delta(
+    out: &mut Vec<ReportArgDeltaV1>,
+    path: &[String],
+    arg: &UnionArgV2,
+    wrapper: &CoverageResolution,
+) {
+    match wrapper.level.as_deref() {
+        None | Some("unknown") | Some("unsupported") => out.push(ReportArgDeltaV1 {
+            path: path.to_vec(),
+            name: arg.name.clone(),
+            upstream_available_on: arg.available_on.clone(),
+            wrapper_level: wrapper.level.clone(),
+            note: wrapper.note.clone(),
+        }),
+        Some("intentionally_unsupported") => {}
+        Some("explicit") | Some("passthrough") => {}
+        Some(other) => out.push(ReportArgDeltaV1 {
+            path: path.to_vec(),
+            name: arg.name.clone(),
+            upstream_available_on: arg.available_on.clone(),
+            wrapper_level: Some(other.to_string()),
+            note: wrapper.note.clone(),
+        }),
+    }
+}
+
+pub(super) fn upstream_flag_availability(
+    upstream: &BTreeMap<Vec<String>, UnionCommandV2>,
+    path: &[String],
+    key: &str,
+    wrapper_res: &CoverageResolution,
+    report_targets: &BTreeSet<String>,
+    expected_targets: &[String],
+    mode: FilterMode<'_>,
+) -> (Vec<String>, bool) {
+    if let Some(cmd) = upstream.get(path) {
+        if let Some(flag) = cmd.flags.iter().find(|f| f.key == key) {
+            let present =
+                present_on_filter(&flag.available_on, report_targets, expected_targets, mode);
+            return (flag.available_on.clone(), present);
+        }
+        return (cmd.available_on.clone(), false);
+    }
+    (
+        util::ordered_subset(expected_targets, &wrapper_res.targets),
+        false,
+    )
+}
+
+pub(super) fn upstream_arg_availability(
+    upstream: &BTreeMap<Vec<String>, UnionCommandV2>,
+    path: &[String],
+    name: &str,
+    wrapper_res: &CoverageResolution,
+    report_targets: &BTreeSet<String>,
+    expected_targets: &[String],
+    mode: FilterMode<'_>,
+) -> (Vec<String>, bool) {
+    if let Some(cmd) = upstream.get(path) {
+        if let Some(arg) = cmd.args.iter().find(|a| a.name == name) {
+            let present =
+                present_on_filter(&arg.available_on, report_targets, expected_targets, mode);
+            return (arg.available_on.clone(), present);
+        }
+        return (cmd.available_on.clone(), false);
+    }
+    (
+        util::ordered_subset(expected_targets, &wrapper_res.targets),
+        false,
+    )
+}
diff --git a/crates/xtask/src/codex_report/report/iu.rs b/crates/xtask/src/codex_report/report/iu.rs
new file mode 100644
index 0000000..109c994
--- /dev/null
+++ b/crates/xtask/src/codex_report/report/iu.rs
@@ -0,0 +1,166 @@
+use std::collections::BTreeSet;
+
+use super::{
+    super::{
+        models::WrapperCoverageV1,
+        util,
+        wrapper::{self, FilterMode, WrapperIndex},
+        ReportError,
+    },
+    schema::ReportIntentionallyUnsupportedDeltaV1,
+};
+
+#[derive(Debug, Clone)]
+pub(super) struct IuRoot {
+    pub(super) path: Vec<String>,
+    targets: BTreeSet<String>,
+    pub(super) note: String,
+}
+
+pub(super) fn build_iu_roots(
+    wrapper: &WrapperCoverageV1,
+    wrapper_index: &WrapperIndex,
+    report_target_set: &BTreeSet<String>,
+    expected_targets: &[String],
+    filter_mode: FilterMode<'_>,
+) -> Result<Vec<IuRoot>, ReportError> {
+    let mut unique_paths: BTreeSet<Vec<String>> = BTreeSet::new();
+    for cmd in &wrapper.coverage {
+        if cmd.level == "intentionally_unsupported" {
+            unique_paths.insert(cmd.path.clone());
+        }
+    }
+
+    let mut roots = Vec::new();
+    for path in unique_paths {
+        let res = wrapper::resolve_wrapper(
+            wrapper_index
+                .commands
+                .get(&path)
+                .map(Vec::as_slice)
+                .unwrap_or(&[]),
+            report_target_set,
+            expected_targets,
+            filter_mode,
+            "command",
+            &format!("path={}", util::format_path(&path)),
+        )?;
+        if res.level.as_deref() != Some("intentionally_unsupported") {
+            continue;
+        }
+        let note = require_non_empty_note(
+            res.note.as_deref(),
+            "command",
+            &format!("path={}", util::format_path(&path)),
+        )?;
+        roots.push(IuRoot {
+            path,
+            targets: res.targets,
+            note,
+        });
+    }
+
+    roots.sort_by(|a, b| {
+        b.path
+            .len()
+            .cmp(&a.path.len())
+            .then_with(|| util::cmp_path(&a.path, &b.path))
+    });
+    Ok(roots)
+}
+
+pub(super) fn find_inherited_iu_root<'a>(
+    roots: &'a [IuRoot],
+    unit_path: &[String],
+    unit_available_on: &[String],
+    report_target_set: &BTreeSet<String>,
+    unit_kind: &'static str,
+) -> Result<Option<&'a IuRoot>, ReportError> {
+    let relevant_targets: BTreeSet<String> = unit_available_on
+        .iter()
+        .filter(|t| report_target_set.contains(*t))
+        .cloned()
+        .collect();
+    if relevant_targets.is_empty() {
+        return Ok(None);
+    }
+
+    for root in roots {
+        if !util::is_prefix(&root.path, unit_path) {
+            continue;
+        }
+
+        let overlap: BTreeSet<String> = relevant_targets
+            .intersection(&root.targets)
+            .cloned()
+            .collect();
+        if overlap.is_empty() {
+            continue;
+        }
+        if overlap != relevant_targets {
+            return Err(ReportError::WrapperResolution {
+                unit: unit_kind.to_string(),
+                detail: format!(
+                    "IU subtree root scope mismatch: root_path={} does not cover all upstream targets for unit_path={} (root_targets={} unit_targets={})",
+                    util::format_path(&root.path),
+                    util::format_path(unit_path),
+                    root.targets.iter().cloned().collect::<Vec<_>>().join(","),
+                    relevant_targets.iter().cloned().collect::<Vec<_>>().join(","),
+                ),
+            });
+        }
+
+        return Ok(Some(root));
+    }
+
+    Ok(None)
+}
+
+pub(super) fn require_non_empty_note(
+    note: Option<&str>,
+    unit_kind: &'static str,
+    detail: &str,
+) -> Result<String, ReportError> {
+    match note.map(str::trim).filter(|s| !s.is_empty()) {
+        Some(v) => Ok(v.to_string()),
+        None => Err(ReportError::WrapperResolution {
+            unit: unit_kind.to_string(),
+            detail: format!("{detail} intentionally_unsupported requires non-empty note"),
+        }),
+    }
+}
+
+fn iu_kind_rank(entry: &ReportIntentionallyUnsupportedDeltaV1) -> u8 {
+    match entry {
+        ReportIntentionallyUnsupportedDeltaV1::Command(_) => 0,
+        ReportIntentionallyUnsupportedDeltaV1::Flag(_) => 1,
+        ReportIntentionallyUnsupportedDeltaV1::Arg(_) => 2,
+    }
+}
+
+fn iu_path(entry: &ReportIntentionallyUnsupportedDeltaV1) -> &[String] {
+    match entry {
+        ReportIntentionallyUnsupportedDeltaV1::Command(v) => &v.path,
+        ReportIntentionallyUnsupportedDeltaV1::Flag(v) => &v.path,
+        ReportIntentionallyUnsupportedDeltaV1::Arg(v) => &v.path,
+    }
+}
+
+pub(super) fn cmp_iu_delta(
+    a: &ReportIntentionallyUnsupportedDeltaV1,
+    b: &ReportIntentionallyUnsupportedDeltaV1,
+) -> std::cmp::Ordering {
+    iu_kind_rank(a).cmp(&iu_kind_rank(b)).then_with(|| {
+        util::cmp_path(iu_path(a), iu_path(b)).then_with(|| match (a, b) {
+            (
+                ReportIntentionallyUnsupportedDeltaV1::Flag(a),
+                ReportIntentionallyUnsupportedDeltaV1::Flag(b),
+            ) => a.key.cmp(&b.key),
+            (
+                ReportIntentionallyUnsupportedDeltaV1::Arg(a),
+                ReportIntentionallyUnsupportedDeltaV1::Arg(b),
+            ) => a.name.cmp(&b.name),
+            _ => std::cmp::Ordering::Equal,
+        })
+    })
+}
diff --git a/crates/xtask/src/codex_report/report/parity.rs b/crates/xtask/src/codex_report/report/parity.rs
new file mode 100644
index 0000000..be9e3ef
--- /dev/null
+++ b/crates/xtask/src/codex_report/report/parity.rs
@@ -0,0 +1,43 @@
+use std::collections::BTreeMap;
+
+use super::super::rules::{ParityExclusionUnit, RulesParityExclusions};
+
+#[derive(Debug)]
+pub(in super::super) struct ParityExclusionsIndex {
+    pub(in super::super) commands: BTreeMap<Vec<String>, ParityExclusionUnit>,
+    pub(in super::super) flags: BTreeMap<(Vec<String>, String), ParityExclusionUnit>,
+    pub(in super::super) args: BTreeMap<(Vec<String>, String), ParityExclusionUnit>,
+}
+
+pub(in super::super) fn build_parity_exclusions_index(
+    exclusions: &RulesParityExclusions,
+) -> ParityExclusionsIndex {
+    let mut commands = BTreeMap::new();
+    let mut flags = BTreeMap::new();
+    let mut args = BTreeMap::new();
+
+    for unit in &exclusions.units {
+        match unit.unit.as_str() {
+            "command" => {
+                commands.insert(unit.path.clone(), unit.clone());
+            }
+            "flag" => {
+                if let Some(key) = unit.key.as_ref() {
+                    flags.insert((unit.path.clone(), key.clone()), unit.clone());
+                }
+            }
+            "arg" => {
+                if let Some(name) = unit.name.as_ref() {
+                    args.insert((unit.path.clone(), name.clone()), unit.clone());
+                }
+            }
+            _ => {}
+        }
+    }
+
+    ParityExclusionsIndex {
+        commands,
+        flags,
+        args,
+    }
+}
diff --git a/crates/xtask/src/codex_report/report/schema.rs b/crates/xtask/src/codex_report/report/schema.rs
new file mode 100644
index 0000000..ebeec50
--- /dev/null
+++ b/crates/xtask/src/codex_report/report/schema.rs
@@ -0,0 +1,111 @@
+use serde::Serialize;
+
+#[derive(Debug, Serialize)]
+pub(in super::super) struct CoverageReportV1 {
+    pub(super) schema_version: u32,
+    pub(super) generated_at: String,
+    pub(super) inputs: ReportInputsV1,
+    pub(super) platform_filter: PlatformFilterV1,
+    pub(super) deltas: ReportDeltasV1,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct ReportInputsV1 {
+    pub(super) upstream: ReportUpstreamInputsV1,
+    pub(super) wrapper: ReportWrapperInputsV1,
+    pub(super) rules: ReportRulesInputsV1,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct ReportUpstreamInputsV1 {
+    pub(super) semantic_version: String,
+    pub(super) mode: String,
+    pub(super) targets: Vec<String>,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct ReportWrapperInputsV1 {
+    pub(super) schema_version: u32,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) wrapper_version: Option<String>,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct ReportRulesInputsV1 {
+    pub(super) rules_schema_version: u32,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct PlatformFilterV1 {
+    pub(super) mode: String,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) target_triple: Option<String>,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct ReportDeltasV1 {
+    pub(super) missing_commands: Vec<ReportCommandDeltaV1>,
+    pub(super) missing_flags: Vec<ReportFlagDeltaV1>,
+    pub(super) missing_args: Vec<ReportArgDeltaV1>,
+
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) excluded_commands: Option<Vec<ReportCommandDeltaV1>>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) excluded_flags: Option<Vec<ReportFlagDeltaV1>>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) excluded_args: Option<Vec<ReportArgDeltaV1>>,
+
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) passthrough_candidates: Option<Vec<ReportCommandDeltaV1>>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) unsupported: Option<Vec<ReportCommandDeltaV1>>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) intentionally_unsupported: Option<Vec<ReportIntentionallyUnsupportedDeltaV1>>,
+
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) wrapper_only_commands: Option<Vec<ReportCommandDeltaV1>>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) wrapper_only_flags: Option<Vec<ReportFlagDeltaV1>>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) wrapper_only_args: Option<Vec<ReportArgDeltaV1>>,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct ReportCommandDeltaV1 {
+    pub(super) path: Vec<String>,
+    pub(super) upstream_available_on: Vec<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) wrapper_level: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) note: Option<String>,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct ReportFlagDeltaV1 {
+    pub(super) path: Vec<String>,
+    pub(super) key: String,
+    pub(super) upstream_available_on: Vec<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) wrapper_level: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) note: Option<String>,
+}
+
+#[derive(Debug, Serialize)]
+pub(super) struct ReportArgDeltaV1 {
+    pub(super) path: Vec<String>,
+    pub(super) name: String,
+    pub(super) upstream_available_on: Vec<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) wrapper_level: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub(super) note: Option<String>,
+}
+
+#[derive(Debug, Serialize)]
+#[serde(untagged)]
+pub(super) enum ReportIntentionallyUnsupportedDeltaV1 {
+    Command(ReportCommandDeltaV1),
+    Flag(ReportFlagDeltaV1),
+    Arg(ReportArgDeltaV1),
+}
