diff --git a/crates/codex/src/lib.rs b/crates/codex/src/lib.rs
index 2d453c4..3759773 100644
--- a/crates/codex/src/lib.rs
+++ b/crates/codex/src/lib.rs
@@ -76,6 +76,7 @@ mod execpolicy;
 mod home;
 pub mod jsonl;
 pub mod mcp;
+mod process;
 pub mod wrapper_coverage_manifest;
 
 pub use apply_diff::{ApplyDiffArtifacts, CloudApplyRequest, CloudDiffRequest};
@@ -120,7 +121,6 @@ use std::{
     ffi::{OsStr, OsString},
     fs as std_fs,
     future::Future,
-    io::{self as stdio, Write},
     path::{Path, PathBuf},
     pin::Pin,
     process::ExitStatus,
@@ -130,15 +130,13 @@ use std::{
 use builder::{apply_cli_overrides, resolve_cli_overrides};
 use futures_core::Stream;
 use home::CommandEnvironment;
+use process::{
+    command_output_text, preferred_output_channel, spawn_with_retry, tee_stream, CommandOutput,
+    ConsoleTarget,
+};
 use tempfile::TempDir;
 use thiserror::Error;
-use tokio::{
-    fs,
-    io::{AsyncRead, AsyncReadExt, AsyncWriteExt},
-    process::Command,
-    sync::mpsc,
-    task, time,
-};
+use tokio::{fs, io::AsyncWriteExt, process::Command, sync::mpsc, time};
 use tracing::{debug, warn};
 
 const DEFAULT_TIMEOUT: Duration = Duration::from_secs(120);
@@ -2505,33 +2503,6 @@ impl Default for CodexClient {
     }
 }
 
-fn spawn_with_retry(
-    command: &mut Command,
-    binary: &Path,
-) -> Result<tokio::process::Child, CodexError> {
-    let mut backoff = Duration::from_millis(2);
-    for attempt in 0..5 {
-        match command.spawn() {
-            Ok(child) => return Ok(child),
-            Err(source) => {
-                let is_busy = matches!(source.kind(), std::io::ErrorKind::ExecutableFileBusy)
-                    || source.raw_os_error() == Some(26);
-                if is_busy && attempt < 4 {
-                    std::thread::sleep(backoff);
-                    backoff = std::cmp::min(backoff * 2, Duration::from_millis(50));
-                    continue;
-                }
-                return Err(CodexError::Spawn {
-                    binary: binary.to_path_buf(),
-                    source,
-                });
-            }
-        }
-    }
-
-    unreachable!("spawn_with_retry should return before exhausting retries")
-}
-
 /// Errors that may occur while invoking the Codex CLI.
 #[derive(Debug, Error)]
 pub enum CodexError {
@@ -2837,18 +2808,35 @@ impl DirectoryContext {
     }
 }
 
-fn command_output_text(output: &CommandOutput) -> String {
-    let stdout = String::from_utf8_lossy(&output.stdout).into_owned();
-    let stderr = String::from_utf8_lossy(&output.stderr).into_owned();
-    let stdout = stdout.trim_end();
-    let stderr = stderr.trim_end();
-    if stdout.is_empty() {
-        stderr.to_string()
-    } else if stderr.is_empty() {
-        stdout.to_string()
-    } else {
-        format!("{stdout}\n{stderr}")
+fn default_rust_log_value() -> Option<&'static str> {
+    env::var_os(RUST_LOG_ENV)
+        .is_none()
+        .then_some(DEFAULT_RUST_LOG)
+}
+
+fn default_binary_path() -> PathBuf {
+    env::var_os(CODEX_BINARY_ENV)
+        .map(PathBuf::from)
+        .unwrap_or_else(|| PathBuf::from("codex"))
+}
+
+fn parse_login_success(output: &str) -> Option<CodexAuthStatus> {
+    let lower = output.to_lowercase();
+    if lower.contains("chatgpt") {
+        return Some(CodexAuthStatus::LoggedIn(CodexAuthMethod::ChatGpt));
     }
+    if lower.contains("api key") || lower.contains("apikey") {
+        // Prefer everything after the first " - " so we do not chop the key itself.
+        let masked = output
+            .split_once(" - ")
+            .map(|(_, value)| value.trim().to_string())
+            .filter(|value| !value.is_empty())
+            .or_else(|| output.split_whitespace().last().map(|v| v.to_string()));
+        return Some(CodexAuthStatus::LoggedIn(CodexAuthMethod::ApiKey {
+            masked_key: masked,
+        }));
+    }
+    None
 }
 
 #[cfg(test)]
@@ -6412,90 +6400,3 @@ exit 2
         ));
     }
 }
-
-fn default_rust_log_value() -> Option<&'static str> {
-    env::var_os(RUST_LOG_ENV)
-        .is_none()
-        .then_some(DEFAULT_RUST_LOG)
-}
-
-fn default_binary_path() -> PathBuf {
-    env::var_os(CODEX_BINARY_ENV)
-        .map(PathBuf::from)
-        .unwrap_or_else(|| PathBuf::from("codex"))
-}
-
-#[derive(Clone, Copy)]
-enum ConsoleTarget {
-    Stdout,
-    Stderr,
-}
-
-async fn tee_stream<R>(
-    mut reader: R,
-    target: ConsoleTarget,
-    mirror_console: bool,
-) -> Result<Vec<u8>, std::io::Error>
-where
-    R: AsyncRead + Unpin,
-{
-    let mut buffer = Vec::new();
-    let mut chunk = [0u8; 4096];
-    loop {
-        let n = reader.read(&mut chunk).await?;
-        if n == 0 {
-            break;
-        }
-        if mirror_console {
-            task::block_in_place(|| match target {
-                ConsoleTarget::Stdout => {
-                    let mut out = stdio::stdout();
-                    out.write_all(&chunk[..n])?;
-                    out.flush()
-                }
-                ConsoleTarget::Stderr => {
-                    let mut out = stdio::stderr();
-                    out.write_all(&chunk[..n])?;
-                    out.flush()
-                }
-            })?;
-        }
-        buffer.extend_from_slice(&chunk[..n]);
-    }
-    Ok(buffer)
-}
-
-fn parse_login_success(output: &str) -> Option<CodexAuthStatus> {
-    let lower = output.to_lowercase();
-    if lower.contains("chatgpt") {
-        return Some(CodexAuthStatus::LoggedIn(CodexAuthMethod::ChatGpt));
-    }
-    if lower.contains("api key") || lower.contains("apikey") {
-        // Prefer everything after the first " - " so we do not chop the key itself.
-        let masked = output
-            .split_once(" - ")
-            .map(|(_, value)| value.trim().to_string())
-            .filter(|value| !value.is_empty())
-            .or_else(|| output.split_whitespace().last().map(|v| v.to_string()));
-        return Some(CodexAuthStatus::LoggedIn(CodexAuthMethod::ApiKey {
-            masked_key: masked,
-        }));
-    }
-    None
-}
-
-fn preferred_output_channel(output: &CommandOutput) -> String {
-    let stderr = String::from_utf8(output.stderr.clone()).unwrap_or_default();
-    let stdout = String::from_utf8(output.stdout.clone()).unwrap_or_default();
-    if stderr.trim().is_empty() {
-        stdout
-    } else {
-        stderr
-    }
-}
-
-struct CommandOutput {
-    status: ExitStatus,
-    stdout: Vec<u8>,
-    stderr: Vec<u8>,
-}
diff --git a/crates/codex/src/process.rs b/crates/codex/src/process.rs
new file mode 100644
index 0000000..b9b7975
--- /dev/null
+++ b/crates/codex/src/process.rs
@@ -0,0 +1,111 @@
+use std::{
+    io::{self, Write},
+    path::Path,
+    process::ExitStatus,
+    time::Duration,
+};
+
+use tokio::{
+    io::{AsyncRead, AsyncReadExt},
+    process::Command,
+    task,
+};
+
+use crate::CodexError;
+
+#[derive(Clone, Copy)]
+pub(crate) enum ConsoleTarget {
+    Stdout,
+    Stderr,
+}
+
+pub(crate) async fn tee_stream<R>(
+    mut reader: R,
+    target: ConsoleTarget,
+    mirror_console: bool,
+) -> Result<Vec<u8>, io::Error>
+where
+    R: AsyncRead + Unpin,
+{
+    let mut buffer = Vec::new();
+    let mut chunk = [0u8; 4096];
+    loop {
+        let n = reader.read(&mut chunk).await?;
+        if n == 0 {
+            break;
+        }
+        if mirror_console {
+            task::block_in_place(|| match target {
+                ConsoleTarget::Stdout => {
+                    let mut out = io::stdout();
+                    out.write_all(&chunk[..n])?;
+                    out.flush()
+                }
+                ConsoleTarget::Stderr => {
+                    let mut out = io::stderr();
+                    out.write_all(&chunk[..n])?;
+                    out.flush()
+                }
+            })?;
+        }
+        buffer.extend_from_slice(&chunk[..n]);
+    }
+    Ok(buffer)
+}
+
+pub(crate) fn spawn_with_retry(
+    command: &mut Command,
+    binary: &Path,
+) -> Result<tokio::process::Child, CodexError> {
+    let mut backoff = Duration::from_millis(2);
+    for attempt in 0..5 {
+        match command.spawn() {
+            Ok(child) => return Ok(child),
+            Err(source) => {
+                let is_busy = matches!(source.kind(), std::io::ErrorKind::ExecutableFileBusy)
+                    || source.raw_os_error() == Some(26);
+                if is_busy && attempt < 4 {
+                    std::thread::sleep(backoff);
+                    backoff = std::cmp::min(backoff * 2, Duration::from_millis(50));
+                    continue;
+                }
+                return Err(CodexError::Spawn {
+                    binary: binary.to_path_buf(),
+                    source,
+                });
+            }
+        }
+    }
+
+    unreachable!("spawn_with_retry should return before exhausting retries")
+}
+
+pub(crate) fn command_output_text(output: &CommandOutput) -> String {
+    let stdout = String::from_utf8_lossy(&output.stdout).into_owned();
+    let stderr = String::from_utf8_lossy(&output.stderr).into_owned();
+    let stdout = stdout.trim_end();
+    let stderr = stderr.trim_end();
+    if stdout.is_empty() {
+        stderr.to_string()
+    } else if stderr.is_empty() {
+        stdout.to_string()
+    } else {
+        format!("{stdout}\n{stderr}")
+    }
+}
+
+pub(crate) fn preferred_output_channel(output: &CommandOutput) -> String {
+    let stderr = String::from_utf8(output.stderr.clone()).unwrap_or_default();
+    let stdout = String::from_utf8(output.stdout.clone()).unwrap_or_default();
+    if stderr.trim().is_empty() {
+        stdout
+    } else {
+        stderr
+    }
+}
+
+pub(crate) struct CommandOutput {
+    pub(crate) status: ExitStatus,
+    pub(crate) stdout: Vec<u8>,
+    pub(crate) stderr: Vec<u8>,
+}
