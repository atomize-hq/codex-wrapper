diff --git a/crates/xtask/tests/c3_spec_reports_metadata_retain.rs b/crates/xtask/tests/c3_spec_reports_metadata_retain.rs
index 785d97c..37c9cff 100644
--- a/crates/xtask/tests/c3_spec_reports_metadata_retain.rs
+++ b/crates/xtask/tests/c3_spec_reports_metadata_retain.rs
@@ -1,11 +1,10 @@
-use std::collections::{BTreeSet, HashMap};
+use std::collections::HashMap;
 use std::fs;
 use std::path::{Path, PathBuf};
 use std::process::Command;
 use std::time::{SystemTime, UNIX_EPOCH};
 
 use jsonschema::{Draft, JSONSchema};
-use semver::Version as SemverVersion;
 use serde_json::{json, Value};
 
 const VERSION: &str = "0.61.0";
@@ -415,182 +414,6 @@ fn assert_report_common(report: &Value, expected_mode: &str, expected_target: Op
     }
 }
 
-#[test]
-fn c3_report_filter_semantics_complete_union_empty_wrapper() {
-    let temp = make_temp_dir("ccm-c3-report-complete");
-    let codex_dir = temp.join("cli_manifests").join("codex");
-    materialize_codex_root_for_reports(&codex_dir, true);
-
-    let output = run_xtask_codex_report(&codex_dir);
-    assert!(
-        output.status.success(),
-        "expected codex-report success on complete union:\nstatus: {}\nstdout:\n{}\nstderr:\n{}",
-        output.status,
-        String::from_utf8_lossy(&output.stdout),
-        String::from_utf8_lossy(&output.stderr)
-    );
-
-    let reports_dir = codex_dir.join("reports").join(VERSION);
-    let schema = compile_schema_with_file_id(&codex_dir.join("SCHEMA.json"));
-
-    let any_path = reports_dir.join("coverage.any.json");
-    let any = read_json(&any_path);
-    assert_schema_valid(&schema, &any);
-    assert_report_common(&any, "any", None);
-    let (any_cmds, any_flags, any_args) = extract_report_paths(&any);
-    assert_eq!(any_cmds.len(), 4, "any should include all commands");
-    assert_eq!(any_flags.len(), 2, "any should include all flags");
-    assert_eq!(any_args.len(), 3, "any should include all args");
-
-    let all_path = reports_dir.join("coverage.all.json");
-    let all = read_json(&all_path);
-    assert_schema_valid(&schema, &all);
-    assert_report_common(&all, "all", None);
-    let (all_cmds, all_flags, all_args) = extract_report_paths(&all);
-    assert_eq!(
-        all_cmds,
-        vec![vec!["root".to_string()]],
-        "all should include only all-target commands"
-    );
-    assert_eq!(
-        all_flags,
-        vec![(vec!["root".to_string()], "--all".to_string())],
-        "all should include only all-target flags"
-    );
-    assert_eq!(
-        all_args,
-        vec![(vec!["root".to_string()], "INPUT".to_string())],
-        "all should include only all-target args"
-    );
-
-    for target in TARGETS {
-        let per_target_path = reports_dir.join(format!("coverage.{target}.json"));
-        let report = read_json(&per_target_path);
-        assert_schema_valid(&schema, &report);
-        assert_report_common(&report, "exact_target", Some(target));
-    }
-
-    let linux = read_json(&reports_dir.join(format!("coverage.{TARGET_LINUX}.json")));
-    let (linux_cmds, _linux_flags, linux_args) = extract_report_paths(&linux);
-    assert_eq!(linux_cmds.len(), 3, "linux should see linux+all commands");
-    assert_eq!(linux_args.len(), 2, "linux should not see windows-only arg");
-
-    let windows = read_json(&reports_dir.join(format!("coverage.{TARGET_WINDOWS}.json")));
-    let (windows_cmds, _windows_flags, windows_args) = extract_report_paths(&windows);
-    assert_eq!(
-        windows_cmds.len(),
-        1,
-        "windows should only see root command"
-    );
-    assert_eq!(windows_args.len(), 2, "windows should see windows-only arg");
-}
-
-#[test]
-fn c3_report_skips_coverage_all_when_union_incomplete() {
-    let temp = make_temp_dir("ccm-c3-report-incomplete");
-    let codex_dir = temp.join("cli_manifests").join("codex");
-    materialize_codex_root_for_reports(&codex_dir, false);
-
-    let _output = run_xtask_codex_report(&codex_dir);
-
-    let reports_dir = codex_dir.join("reports").join(VERSION);
-    assert!(
-        reports_dir.join("coverage.any.json").exists(),
-        "codex-report must write coverage.any.json even when union is incomplete"
-    );
-    assert!(
-        reports_dir
-            .join(format!("coverage.{TARGET_LINUX}.json"))
-            .exists(),
-        "codex-report must write per-target report for included input targets"
-    );
-    assert!(
-        !reports_dir
-            .join(format!("coverage.{TARGET_MACOS}.json"))
-            .exists(),
-        "per-target reports must only be generated for union.inputs[].target_triple"
-    );
-    assert!(
-        !reports_dir
-            .join(format!("coverage.{TARGET_WINDOWS}.json"))
-            .exists(),
-        "per-target reports must only be generated for union.inputs[].target_triple"
-    );
-    assert!(
-        !reports_dir.join("coverage.all.json").exists(),
-        "coverage.all.json must not be generated when union complete=false"
-    );
-}
-
-#[test]
-fn c3_version_metadata_reported_requires_union_and_any_report() {
-    let temp = make_temp_dir("ccm-c3-version-metadata");
-    let codex_dir = temp.join("cli_manifests").join("codex");
-
-    fs::create_dir_all(&codex_dir).expect("mkdir codex dir");
-    copy_from_repo(&codex_dir, "SCHEMA.json");
-    copy_from_repo(&codex_dir, "RULES.json");
-    copy_from_repo(&codex_dir, "VERSION_METADATA_SCHEMA.json");
-    write_union_snapshot(&codex_dir, false);
-    write_wrapper_coverage_empty(&codex_dir);
-
-    let missing_reports = run_xtask_codex_version_metadata(&codex_dir, "reported");
-    assert!(
-        !missing_reports.status.success(),
-        "expected failure when coverage.any.json is missing:\nstatus: {}\nstdout:\n{}\nstderr:\n{}",
-        missing_reports.status,
-        String::from_utf8_lossy(&missing_reports.stdout),
-        String::from_utf8_lossy(&missing_reports.stderr)
-    );
-    let err = format!(
-        "{}\n{}",
-        String::from_utf8_lossy(&missing_reports.stdout),
-        String::from_utf8_lossy(&missing_reports.stderr)
-    );
-    assert!(
-        err.contains("coverage.any.json"),
-        "expected missing coverage.any.json error, got:\n{err}"
-    );
-
-    let report_out = run_xtask_codex_report(&codex_dir);
-    assert!(
-        report_out.status.success() || !report_out.status.success(),
-        "codex-report must run to materialize required report files"
-    );
-
-    let output = run_xtask_codex_version_metadata(&codex_dir, "reported");
-    assert!(
-        output.status.success(),
-        "expected success after adding reports:\nstatus: {}\nstdout:\n{}\nstderr:\n{}",
-        output.status,
-        String::from_utf8_lossy(&output.stdout),
-        String::from_utf8_lossy(&output.stderr)
-    );
-
-    let version_path = codex_dir.join("versions").join(format!("{VERSION}.json"));
-    assert!(
-        version_path.exists(),
-        "expected versions/<version>.json written"
-    );
-
-    let schema = compile_schema_with_file_id(&codex_dir.join("VERSION_METADATA_SCHEMA.json"));
-    let metadata = read_json(&version_path);
-    assert_schema_valid(&schema, &metadata);
-    assert_eq!(
-        metadata.get("semantic_version").and_then(|v| v.as_str()),
-        Some(VERSION)
-    );
-    assert_eq!(
-        metadata.get("status").and_then(|v| v.as_str()),
-        Some("reported")
-    );
-    assert_eq!(
-        metadata.get("updated_at").and_then(|v| v.as_str()),
-        Some(TS),
-        "expected deterministic updated_at when SOURCE_DATE_EPOCH=0"
-    );
-}
-
 fn write_versions_metadata(codex_dir: &Path, versions: &HashMap<&str, &str>) {
     for (v, status) in versions {
         let metadata = json!({
@@ -648,174 +471,11 @@ fn parse_retain_output_lists(output: &str) -> (Vec<String>, Vec<String>) {
     (keep, delete)
 }
 
-#[test]
-fn c3_retain_deletes_only_snapshots_and_reports_outside_keep_set() {
-    let temp = make_temp_dir("ccm-c3-retain");
-    let codex_dir = temp.join("cli_manifests").join("codex");
-    fs::create_dir_all(&codex_dir).expect("mkdir codex dir");
-    copy_from_repo(&codex_dir, "RULES.json");
-
-    let all_versions = ["0.1.0", "0.2.0", "0.3.0", "0.4.0", "0.5.0", "0.6.0"];
-
-    write_text(&codex_dir.join("min_supported.txt"), "0.2.0\n");
-    write_text(&codex_dir.join("latest_validated.txt"), "0.5.0\n");
-    for target in TARGETS {
-        let supported = codex_dir
-            .join("pointers")
-            .join("latest_supported")
-            .join(format!("{target}.txt"));
-        let validated = codex_dir
-            .join("pointers")
-            .join("latest_validated")
-            .join(format!("{target}.txt"));
-        if target == TARGET_LINUX {
-            write_text(&supported, "0.3.0\n");
-            write_text(&validated, "0.5.0\n");
-        } else {
-            write_text(&supported, "none\n");
-            write_text(&validated, "none\n");
-        }
-    }
-
-    let versions = HashMap::from([
-        ("0.1.0", "snapshotted"),
-        ("0.2.0", "validated"),
-        ("0.3.0", "reported"),
-        ("0.4.0", "supported"),
-        ("0.5.0", "validated"),
-        ("0.6.0", "validated"),
-    ]);
-    write_versions_metadata(&codex_dir, &versions);
-
-    for v in all_versions {
-        touch_dir_with_marker(&codex_dir.join("snapshots").join(v), v);
-        touch_dir_with_marker(&codex_dir.join("reports").join(v), v);
-        touch_dir_with_marker(&codex_dir.join("raw_help").join(v), v);
-    }
-
-    let expected_keep =
-        BTreeSet::from_iter(["0.2.0", "0.3.0", "0.4.0", "0.5.0", "0.6.0"].map(|v| v.to_string()));
-    let expected_delete = BTreeSet::from_iter(["0.1.0"].map(|v| v.to_string()));
-
-    let dry = run_xtask_codex_retain(&codex_dir, false);
-    let dry_text = format!(
-        "{}\n{}",
-        String::from_utf8_lossy(&dry.stdout),
-        String::from_utf8_lossy(&dry.stderr)
-    );
-    for v in &expected_keep {
-        assert!(
-            dry_text.contains(v),
-            "dry-run output must include keep version {v}:\n{dry_text}"
-        );
-    }
-    for v in &expected_delete {
-        assert!(
-            dry_text.contains(v),
-            "dry-run output must include delete version {v}:\n{dry_text}"
-        );
-    }
-
-    for v in all_versions {
-        assert!(
-            codex_dir.join("snapshots").join(v).exists(),
-            "dry-run must not delete snapshots/{v}"
-        );
-        assert!(
-            codex_dir.join("reports").join(v).exists(),
-            "dry-run must not delete reports/{v}"
-        );
-        assert!(
-            codex_dir.join("raw_help").join(v).exists(),
-            "dry-run must not delete raw_help/{v}"
-        );
-        assert!(
-            codex_dir
-                .join("versions")
-                .join(format!("{v}.json"))
-                .exists(),
-            "retain must not delete versions/{v}.json"
-        );
-    }
-
-    let apply = run_xtask_codex_retain(&codex_dir, true);
-    assert!(
-        apply.status.success(),
-        "expected codex-retain --apply success:\nstatus: {}\nstdout:\n{}\nstderr:\n{}",
-        apply.status,
-        String::from_utf8_lossy(&apply.stdout),
-        String::from_utf8_lossy(&apply.stderr)
-    );
-    let apply_text = format!(
-        "{}\n{}",
-        String::from_utf8_lossy(&apply.stdout),
-        String::from_utf8_lossy(&apply.stderr)
-    );
-    for v in &expected_keep {
-        assert!(
-            apply_text.contains(v),
-            "apply output must include keep version {v}:\n{apply_text}"
-        );
-    }
-    for v in &expected_delete {
-        assert!(
-            apply_text.contains(v),
-            "apply output must include delete version {v}:\n{apply_text}"
-        );
-    }
-
-    let (keep_list, delete_list) = parse_retain_output_lists(&apply_text);
-    if !keep_list.is_empty() && !delete_list.is_empty() {
-        let keep_set: BTreeSet<_> = keep_list.iter().cloned().collect();
-        let delete_set: BTreeSet<_> = delete_list.iter().cloned().collect();
-        assert_eq!(keep_set, expected_keep);
-        assert_eq!(delete_set, expected_delete);
-
-        let mut keep_sorted = keep_list.clone();
-        keep_sorted.sort_by(|a, b| {
-            let a = SemverVersion::parse(a).unwrap_or_else(|e| panic!("parse keep {a}: {e}"));
-            let b = SemverVersion::parse(b).unwrap_or_else(|e| panic!("parse keep {b}: {e}"));
-            a.cmp(&b)
-        });
-        assert_eq!(keep_list, keep_sorted, "keep list must be sorted ascending");
-
-        let mut delete_sorted = delete_list.clone();
-        delete_sorted.sort_by(|a, b| {
-            let a = SemverVersion::parse(a).unwrap_or_else(|e| panic!("parse delete {a}: {e}"));
-            let b = SemverVersion::parse(b).unwrap_or_else(|e| panic!("parse delete {b}: {e}"));
-            a.cmp(&b)
-        });
-        assert_eq!(
-            delete_list, delete_sorted,
-            "delete list must be sorted ascending"
-        );
-    }
-
-    for v in expected_keep.iter() {
-        assert!(
-            codex_dir.join("snapshots").join(v).exists(),
-            "expected keep snapshots/{v}"
-        );
-        assert!(
-            codex_dir.join("reports").join(v).exists(),
-            "expected keep reports/{v}"
-        );
-    }
-    for v in expected_delete.iter() {
-        assert!(
-            !codex_dir.join("snapshots").join(v).exists(),
-            "expected delete snapshots/{v}"
-        );
-        assert!(
-            !codex_dir.join("reports").join(v).exists(),
-            "expected delete reports/{v}"
-        );
-    }
-
-    for v in all_versions {
-        assert!(
-            codex_dir.join("raw_help").join(v).exists(),
-            "retain must not delete raw_help/{v}"
-        );
-    }
-}
+#[path = "c3_spec_reports_metadata_retain/report_filter_semantics.rs"]
+mod report_filter_semantics;
+#[path = "c3_spec_reports_metadata_retain/report_incomplete_union.rs"]
+mod report_incomplete_union;
+#[path = "c3_spec_reports_metadata_retain/retain_behavior.rs"]
+mod retain_behavior;
+#[path = "c3_spec_reports_metadata_retain/version_metadata_requirements.rs"]
+mod version_metadata_requirements;
diff --git a/crates/xtask/tests/c3_spec_reports_metadata_retain/report_filter_semantics.rs b/crates/xtask/tests/c3_spec_reports_metadata_retain/report_filter_semantics.rs
new file mode 100644
index 0000000..f666d2b
--- /dev/null
+++ b/crates/xtask/tests/c3_spec_reports_metadata_retain/report_filter_semantics.rs
@@ -0,0 +1,71 @@
+use super::*;
+
+#[test]
+fn c3_report_filter_semantics_complete_union_empty_wrapper() {
+    let temp = make_temp_dir("ccm-c3-report-complete");
+    let codex_dir = temp.join("cli_manifests").join("codex");
+    materialize_codex_root_for_reports(&codex_dir, true);
+
+    let output = run_xtask_codex_report(&codex_dir);
+    assert!(
+        output.status.success(),
+        "expected codex-report success on complete union:\nstatus: {}\nstdout:\n{}\nstderr:\n{}",
+        output.status,
+        String::from_utf8_lossy(&output.stdout),
+        String::from_utf8_lossy(&output.stderr)
+    );
+
+    let reports_dir = codex_dir.join("reports").join(VERSION);
+    let schema = compile_schema_with_file_id(&codex_dir.join("SCHEMA.json"));
+
+    let any_path = reports_dir.join("coverage.any.json");
+    let any = read_json(&any_path);
+    assert_schema_valid(&schema, &any);
+    assert_report_common(&any, "any", None);
+    let (any_cmds, any_flags, any_args) = extract_report_paths(&any);
+    assert_eq!(any_cmds.len(), 4, "any should include all commands");
+    assert_eq!(any_flags.len(), 2, "any should include all flags");
+    assert_eq!(any_args.len(), 3, "any should include all args");
+
+    let all_path = reports_dir.join("coverage.all.json");
+    let all = read_json(&all_path);
+    assert_schema_valid(&schema, &all);
+    assert_report_common(&all, "all", None);
+    let (all_cmds, all_flags, all_args) = extract_report_paths(&all);
+    assert_eq!(
+        all_cmds,
+        vec![vec!["root".to_string()]],
+        "all should include only all-target commands"
+    );
+    assert_eq!(
+        all_flags,
+        vec![(vec!["root".to_string()], "--all".to_string())],
+        "all should include only all-target flags"
+    );
+    assert_eq!(
+        all_args,
+        vec![(vec!["root".to_string()], "INPUT".to_string())],
+        "all should include only all-target args"
+    );
+
+    for target in TARGETS {
+        let per_target_path = reports_dir.join(format!("coverage.{target}.json"));
+        let report = read_json(&per_target_path);
+        assert_schema_valid(&schema, &report);
+        assert_report_common(&report, "exact_target", Some(target));
+    }
+
+    let linux = read_json(&reports_dir.join(format!("coverage.{TARGET_LINUX}.json")));
+    let (linux_cmds, _linux_flags, linux_args) = extract_report_paths(&linux);
+    assert_eq!(linux_cmds.len(), 3, "linux should see linux+all commands");
+    assert_eq!(linux_args.len(), 2, "linux should not see windows-only arg");
+
+    let windows = read_json(&reports_dir.join(format!("coverage.{TARGET_WINDOWS}.json")));
+    let (windows_cmds, _windows_flags, windows_args) = extract_report_paths(&windows);
+    assert_eq!(
+        windows_cmds.len(),
+        1,
+        "windows should only see root command"
+    );
+    assert_eq!(windows_args.len(), 2, "windows should see windows-only arg");
+}
diff --git a/crates/xtask/tests/c3_spec_reports_metadata_retain/report_incomplete_union.rs b/crates/xtask/tests/c3_spec_reports_metadata_retain/report_incomplete_union.rs
new file mode 100644
index 0000000..2e8e2e9
--- /dev/null
+++ b/crates/xtask/tests/c3_spec_reports_metadata_retain/report_incomplete_union.rs
@@ -0,0 +1,38 @@
+use super::*;
+
+#[test]
+fn c3_report_skips_coverage_all_when_union_incomplete() {
+    let temp = make_temp_dir("ccm-c3-report-incomplete");
+    let codex_dir = temp.join("cli_manifests").join("codex");
+    materialize_codex_root_for_reports(&codex_dir, false);
+
+    let _output = run_xtask_codex_report(&codex_dir);
+
+    let reports_dir = codex_dir.join("reports").join(VERSION);
+    assert!(
+        reports_dir.join("coverage.any.json").exists(),
+        "codex-report must write coverage.any.json even when union is incomplete"
+    );
+    assert!(
+        reports_dir
+            .join(format!("coverage.{TARGET_LINUX}.json"))
+            .exists(),
+        "codex-report must write per-target report for included input targets"
+    );
+    assert!(
+        !reports_dir
+            .join(format!("coverage.{TARGET_MACOS}.json"))
+            .exists(),
+        "per-target reports must only be generated for union.inputs[].target_triple"
+    );
+    assert!(
+        !reports_dir
+            .join(format!("coverage.{TARGET_WINDOWS}.json"))
+            .exists(),
+        "per-target reports must only be generated for union.inputs[].target_triple"
+    );
+    assert!(
+        !reports_dir.join("coverage.all.json").exists(),
+        "coverage.all.json must not be generated when union complete=false"
+    );
+}
diff --git a/crates/xtask/tests/c3_spec_reports_metadata_retain/retain_behavior.rs b/crates/xtask/tests/c3_spec_reports_metadata_retain/retain_behavior.rs
new file mode 100644
index 0000000..68494fb
--- /dev/null
+++ b/crates/xtask/tests/c3_spec_reports_metadata_retain/retain_behavior.rs
@@ -0,0 +1,175 @@
+use super::*;
+use semver::Version as SemverVersion;
+use std::collections::BTreeSet;
+
+#[test]
+fn c3_retain_deletes_only_snapshots_and_reports_outside_keep_set() {
+    let temp = make_temp_dir("ccm-c3-retain");
+    let codex_dir = temp.join("cli_manifests").join("codex");
+    fs::create_dir_all(&codex_dir).expect("mkdir codex dir");
+    copy_from_repo(&codex_dir, "RULES.json");
+
+    let all_versions = ["0.1.0", "0.2.0", "0.3.0", "0.4.0", "0.5.0", "0.6.0"];
+
+    write_text(&codex_dir.join("min_supported.txt"), "0.2.0\n");
+    write_text(&codex_dir.join("latest_validated.txt"), "0.5.0\n");
+    for target in TARGETS {
+        let supported = codex_dir
+            .join("pointers")
+            .join("latest_supported")
+            .join(format!("{target}.txt"));
+        let validated = codex_dir
+            .join("pointers")
+            .join("latest_validated")
+            .join(format!("{target}.txt"));
+        if target == TARGET_LINUX {
+            write_text(&supported, "0.3.0\n");
+            write_text(&validated, "0.5.0\n");
+        } else {
+            write_text(&supported, "none\n");
+            write_text(&validated, "none\n");
+        }
+    }
+
+    let versions = HashMap::from([
+        ("0.1.0", "snapshotted"),
+        ("0.2.0", "validated"),
+        ("0.3.0", "reported"),
+        ("0.4.0", "supported"),
+        ("0.5.0", "validated"),
+        ("0.6.0", "validated"),
+    ]);
+    write_versions_metadata(&codex_dir, &versions);
+
+    for v in all_versions {
+        touch_dir_with_marker(&codex_dir.join("snapshots").join(v), v);
+        touch_dir_with_marker(&codex_dir.join("reports").join(v), v);
+        touch_dir_with_marker(&codex_dir.join("raw_help").join(v), v);
+    }
+
+    let expected_keep =
+        BTreeSet::from_iter(["0.2.0", "0.3.0", "0.4.0", "0.5.0", "0.6.0"].map(|v| v.to_string()));
+    let expected_delete = BTreeSet::from_iter(["0.1.0"].map(|v| v.to_string()));
+
+    let dry = run_xtask_codex_retain(&codex_dir, false);
+    let dry_text = format!(
+        "{}\n{}",
+        String::from_utf8_lossy(&dry.stdout),
+        String::from_utf8_lossy(&dry.stderr)
+    );
+    for v in &expected_keep {
+        assert!(
+            dry_text.contains(v),
+            "dry-run output must include keep version {v}:\n{dry_text}"
+        );
+    }
+    for v in &expected_delete {
+        assert!(
+            dry_text.contains(v),
+            "dry-run output must include delete version {v}:\n{dry_text}"
+        );
+    }
+
+    for v in all_versions {
+        assert!(
+            codex_dir.join("snapshots").join(v).exists(),
+            "dry-run must not delete snapshots/{v}"
+        );
+        assert!(
+            codex_dir.join("reports").join(v).exists(),
+            "dry-run must not delete reports/{v}"
+        );
+        assert!(
+            codex_dir.join("raw_help").join(v).exists(),
+            "dry-run must not delete raw_help/{v}"
+        );
+        assert!(
+            codex_dir
+                .join("versions")
+                .join(format!("{v}.json"))
+                .exists(),
+            "retain must not delete versions/{v}.json"
+        );
+    }
+
+    let apply = run_xtask_codex_retain(&codex_dir, true);
+    assert!(
+        apply.status.success(),
+        "expected codex-retain --apply success:\nstatus: {}\nstdout:\n{}\nstderr:\n{}",
+        apply.status,
+        String::from_utf8_lossy(&apply.stdout),
+        String::from_utf8_lossy(&apply.stderr)
+    );
+    let apply_text = format!(
+        "{}\n{}",
+        String::from_utf8_lossy(&apply.stdout),
+        String::from_utf8_lossy(&apply.stderr)
+    );
+    for v in &expected_keep {
+        assert!(
+            apply_text.contains(v),
+            "apply output must include keep version {v}:\n{apply_text}"
+        );
+    }
+    for v in &expected_delete {
+        assert!(
+            apply_text.contains(v),
+            "apply output must include delete version {v}:\n{apply_text}"
+        );
+    }
+
+    let (keep_list, delete_list) = parse_retain_output_lists(&apply_text);
+    if !keep_list.is_empty() && !delete_list.is_empty() {
+        let keep_set: BTreeSet<_> = keep_list.iter().cloned().collect();
+        let delete_set: BTreeSet<_> = delete_list.iter().cloned().collect();
+        assert_eq!(keep_set, expected_keep);
+        assert_eq!(delete_set, expected_delete);
+
+        let mut keep_sorted = keep_list.clone();
+        keep_sorted.sort_by(|a, b| {
+            let a = SemverVersion::parse(a).unwrap_or_else(|e| panic!("parse keep {a}: {e}"));
+            let b = SemverVersion::parse(b).unwrap_or_else(|e| panic!("parse keep {b}: {e}"));
+            a.cmp(&b)
+        });
+        assert_eq!(keep_list, keep_sorted, "keep list must be sorted ascending");
+
+        let mut delete_sorted = delete_list.clone();
+        delete_sorted.sort_by(|a, b| {
+            let a = SemverVersion::parse(a).unwrap_or_else(|e| panic!("parse delete {a}: {e}"));
+            let b = SemverVersion::parse(b).unwrap_or_else(|e| panic!("parse delete {b}: {e}"));
+            a.cmp(&b)
+        });
+        assert_eq!(
+            delete_list, delete_sorted,
+            "delete list must be sorted ascending"
+        );
+    }
+
+    for v in expected_keep.iter() {
+        assert!(
+            codex_dir.join("snapshots").join(v).exists(),
+            "expected keep snapshots/{v}"
+        );
+        assert!(
+            codex_dir.join("reports").join(v).exists(),
+            "expected keep reports/{v}"
+        );
+    }
+    for v in expected_delete.iter() {
+        assert!(
+            !codex_dir.join("snapshots").join(v).exists(),
+            "expected delete snapshots/{v}"
+        );
+        assert!(
+            !codex_dir.join("reports").join(v).exists(),
+            "expected delete reports/{v}"
+        );
+    }
+
+    for v in all_versions {
+        assert!(
+            codex_dir.join("raw_help").join(v).exists(),
+            "retain must not delete raw_help/{v}"
+        );
+    }
+}
diff --git a/crates/xtask/tests/c3_spec_reports_metadata_retain/version_metadata_requirements.rs b/crates/xtask/tests/c3_spec_reports_metadata_retain/version_metadata_requirements.rs
new file mode 100644
index 0000000..c4ed1e1
--- /dev/null
+++ b/crates/xtask/tests/c3_spec_reports_metadata_retain/version_metadata_requirements.rs
@@ -0,0 +1,70 @@
+use super::*;
+
+#[test]
+fn c3_version_metadata_reported_requires_union_and_any_report() {
+    let temp = make_temp_dir("ccm-c3-version-metadata");
+    let codex_dir = temp.join("cli_manifests").join("codex");
+
+    fs::create_dir_all(&codex_dir).expect("mkdir codex dir");
+    copy_from_repo(&codex_dir, "SCHEMA.json");
+    copy_from_repo(&codex_dir, "RULES.json");
+    copy_from_repo(&codex_dir, "VERSION_METADATA_SCHEMA.json");
+    write_union_snapshot(&codex_dir, false);
+    write_wrapper_coverage_empty(&codex_dir);
+
+    let missing_reports = run_xtask_codex_version_metadata(&codex_dir, "reported");
+    assert!(
+        !missing_reports.status.success(),
+        "expected failure when coverage.any.json is missing:\nstatus: {}\nstdout:\n{}\nstderr:\n{}",
+        missing_reports.status,
+        String::from_utf8_lossy(&missing_reports.stdout),
+        String::from_utf8_lossy(&missing_reports.stderr)
+    );
+    let err = format!(
+        "{}\n{}",
+        String::from_utf8_lossy(&missing_reports.stdout),
+        String::from_utf8_lossy(&missing_reports.stderr)
+    );
+    assert!(
+        err.contains("coverage.any.json"),
+        "expected missing coverage.any.json error, got:\n{err}"
+    );
+
+    let report_out = run_xtask_codex_report(&codex_dir);
+    assert!(
+        report_out.status.success() || !report_out.status.success(),
+        "codex-report must run to materialize required report files"
+    );
+
+    let output = run_xtask_codex_version_metadata(&codex_dir, "reported");
+    assert!(
+        output.status.success(),
+        "expected success after adding reports:\nstatus: {}\nstdout:\n{}\nstderr:\n{}",
+        output.status,
+        String::from_utf8_lossy(&output.stdout),
+        String::from_utf8_lossy(&output.stderr)
+    );
+
+    let version_path = codex_dir.join("versions").join(format!("{VERSION}.json"));
+    assert!(
+        version_path.exists(),
+        "expected versions/<version>.json written"
+    );
+
+    let schema = compile_schema_with_file_id(&codex_dir.join("VERSION_METADATA_SCHEMA.json"));
+    let metadata = read_json(&version_path);
+    assert_schema_valid(&schema, &metadata);
+    assert_eq!(
+        metadata.get("semantic_version").and_then(|v| v.as_str()),
+        Some(VERSION)
+    );
+    assert_eq!(
+        metadata.get("status").and_then(|v| v.as_str()),
+        Some("reported")
+    );
+    assert_eq!(
+        metadata.get("updated_at").and_then(|v| v.as_str()),
+        Some(TS),
+        "expected deterministic updated_at when SOURCE_DATE_EPOCH=0"
+    );
+}
