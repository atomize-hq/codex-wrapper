diff --git a/crates/codex/src/tests/capabilities.rs b/crates/codex/src/tests/capabilities.rs
index 8ec5738..95e5451 100644
--- a/crates/codex/src/tests/capabilities.rs
+++ b/crates/codex/src/tests/capabilities.rs
@@ -101,907 +101,9 @@ fn capability_snapshot_with_metadata(
     }
 }
 
-#[test]
-fn parses_version_output_fields() {
-    let parsed = version::parse_version_output("codex v3.4.5-nightly (commit abc1234)");
-    assert_eq!(parsed.semantic, Some((3, 4, 5)));
-    assert_eq!(parsed.channel, CodexReleaseChannel::Nightly);
-    assert_eq!(parsed.commit.as_deref(), Some("abc1234"));
-    assert_eq!(
-        parsed.raw,
-        "codex v3.4.5-nightly (commit abc1234)".to_string()
-    );
-}
-
-#[test]
-fn update_advisory_detects_newer_release() {
-    let capabilities = capabilities_with_version("codex 1.0.0");
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("1.1.0").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::UpdateRecommended);
-    assert!(advisory.is_update_recommended());
-    assert_eq!(
-        advisory
-            .latest_release
-            .as_ref()
-            .map(|release| release.version.clone()),
-        latest.stable
-    );
-}
-
-#[test]
-fn update_advisory_handles_unknown_local_version() {
-    let capabilities = capabilities_without_version();
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("3.2.1").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::UnknownLocalVersion);
-    assert!(advisory.is_update_recommended());
-    assert!(advisory
-        .notes
-        .iter()
-        .any(|note| note.contains("could not be parsed")));
-}
-
-#[test]
-fn update_advisory_marks_up_to_date() {
-    let capabilities = capabilities_with_version("codex 2.0.1");
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("2.0.1").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::UpToDate);
-    assert!(!advisory.is_update_recommended());
-}
-
-#[test]
-fn update_advisory_falls_back_when_channel_missing() {
-    let capabilities = capabilities_with_version("codex 2.0.0-beta");
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("2.0.1").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.comparison_channel, CodexReleaseChannel::Stable);
-    assert_eq!(advisory.status, CodexUpdateStatus::UpdateRecommended);
-    assert!(advisory
-        .notes
-        .iter()
-        .any(|note| note.contains("comparing against stable")));
-}
-
-#[test]
-fn update_advisory_handles_local_newer_than_known() {
-    let capabilities = capabilities_with_version("codex 2.0.0");
-    let latest = CodexLatestReleases {
-        stable: Some(Version::parse("1.9.9").unwrap()),
-        ..Default::default()
-    };
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::LocalNewerThanKnown);
-    assert!(!advisory.is_update_recommended());
-    assert!(advisory
-        .notes
-        .iter()
-        .any(|note| note.contains("newer than provided")));
-}
-
-#[test]
-fn update_advisory_handles_missing_latest_metadata() {
-    let capabilities = capabilities_with_version("codex 1.0.0");
-    let latest = CodexLatestReleases::default();
-    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
-    assert_eq!(advisory.status, CodexUpdateStatus::UnknownLatestVersion);
-    assert!(!advisory.is_update_recommended());
-    assert!(advisory
-        .notes
-        .iter()
-        .any(|note| note.contains("advisory unavailable")));
-}
-
-#[test]
-fn capability_snapshots_serialize_to_json_and_toml() {
-    let snapshot = sample_capabilities_snapshot();
-
-    let json = serialize_capabilities_snapshot(&snapshot, CapabilitySnapshotFormat::Json)
-        .expect("serialize json");
-    let parsed_json = deserialize_capabilities_snapshot(&json, CapabilitySnapshotFormat::Json)
-        .expect("parse json");
-    assert_eq!(parsed_json, snapshot);
-
-    let toml = serialize_capabilities_snapshot(&snapshot, CapabilitySnapshotFormat::Toml)
-        .expect("serialize toml");
-    let parsed_toml = deserialize_capabilities_snapshot(&toml, CapabilitySnapshotFormat::Toml)
-        .expect("parse toml");
-    assert_eq!(parsed_toml, snapshot);
-}
-
-#[test]
-fn capability_snapshots_and_overrides_round_trip_via_files() {
-    let snapshot = sample_capabilities_snapshot();
-    let overrides = sample_capability_overrides();
-    let temp = tempfile::tempdir().unwrap();
-
-    let snapshot_path = temp.path().join("capabilities.toml");
-    write_capabilities_snapshot(&snapshot_path, &snapshot, None).unwrap();
-    let loaded_snapshot = read_capabilities_snapshot(&snapshot_path, None).unwrap();
-    assert_eq!(loaded_snapshot, snapshot);
-
-    let overrides_path = temp.path().join("overrides.json");
-    write_capability_overrides(&overrides_path, &overrides, None).unwrap();
-    let loaded_overrides = read_capability_overrides(&overrides_path, None).unwrap();
-    assert_eq!(loaded_overrides, overrides);
-}
-
-#[test]
-fn capability_snapshot_match_checks_fingerprint() {
-    let temp = tempfile::tempdir().unwrap();
-    let script = "#!/bin/bash\necho ok";
-    let binary = write_fake_codex(temp.path(), script);
-    let cache_key = capability_cache_key(&binary);
-    let fingerprint = current_fingerprint(&cache_key);
-
-    let snapshot = CodexCapabilities {
-        cache_key: cache_key.clone(),
-        fingerprint: fingerprint.clone(),
-        version: None,
-        features: CodexFeatureFlags::default(),
-        probe_plan: CapabilityProbePlan::default(),
-        collected_at: SystemTime::UNIX_EPOCH,
-    };
-
-    assert!(capability_snapshot_matches_binary(&snapshot, &binary));
-    let mut missing_fingerprint = snapshot.clone();
-    missing_fingerprint.fingerprint = None;
-    assert!(!capability_snapshot_matches_binary(
-        &missing_fingerprint,
-        &binary
-    ));
-
-    std_fs::write(&binary, "#!/bin/bash\necho changed").unwrap();
-    let mut perms = std_fs::metadata(&binary).unwrap().permissions();
-    perms.set_mode(0o755);
-    std_fs::set_permissions(&binary, perms).unwrap();
-
-    assert!(!capability_snapshot_matches_binary(&snapshot, &binary));
-}
-
-#[test]
-fn capability_cache_entries_exposes_cache_state() {
-    let _guard = env_guard();
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let binary = write_fake_codex(temp.path(), "#!/bin/bash\necho ok");
-    let cache_key = capability_cache_key(&binary);
-    let fingerprint = current_fingerprint(&cache_key);
-
-    let snapshot = CodexCapabilities {
-        cache_key: cache_key.clone(),
-        fingerprint: fingerprint.clone(),
-        version: Some(version::parse_version_output("codex 0.0.1")),
-        features: CodexFeatureFlags {
-            supports_features_list: true,
-            supports_output_schema: true,
-            supports_add_dir: false,
-            supports_mcp_login: false,
-        },
-        probe_plan: CapabilityProbePlan {
-            steps: vec![CapabilityProbeStep::VersionFlag],
-        },
-        collected_at: SystemTime::UNIX_EPOCH,
-    };
-
-    update_capability_cache(snapshot.clone());
-
-    let entries = capability_cache_entries();
-    assert!(entries.iter().any(|entry| entry.cache_key == cache_key));
-
-    let fetched = capability_cache_entry(&binary).expect("expected cache entry");
-    assert_eq!(fetched.cache_key, cache_key);
-    assert!(clear_capability_cache_entry(&binary));
-    assert!(capability_cache_entry(&binary).is_none());
-    assert!(capability_cache_entries().is_empty());
-    clear_capability_cache();
-}
-
-#[test]
-fn capability_ttl_decision_reuses_fresh_snapshot() {
-    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(10);
-    let snapshot = capability_snapshot_with_metadata(
-        collected_at,
-        Some(BinaryFingerprint {
-            canonical_path: Some(PathBuf::from("/tmp/codex")),
-            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(1)),
-            len: Some(123),
-        }),
-    );
-
-    let decision = capability_cache_ttl_decision(
-        Some(&snapshot),
-        Duration::from_secs(300),
-        SystemTime::UNIX_EPOCH + Duration::from_secs(100),
-    );
-    assert!(!decision.should_probe);
-    assert_eq!(decision.policy, CapabilityCachePolicy::PreferCache);
-}
-
-#[test]
-fn capability_ttl_decision_refreshes_after_ttl_with_fingerprint() {
-    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(1);
-    let snapshot = capability_snapshot_with_metadata(
-        collected_at,
-        Some(BinaryFingerprint {
-            canonical_path: Some(PathBuf::from("/tmp/codex")),
-            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(1)),
-            len: Some(321),
-        }),
-    );
-
-    let decision = capability_cache_ttl_decision(
-        Some(&snapshot),
-        Duration::from_secs(5),
-        SystemTime::UNIX_EPOCH + Duration::from_secs(10),
-    );
-    assert!(decision.should_probe);
-    assert_eq!(decision.policy, CapabilityCachePolicy::Refresh);
-}
-
-#[test]
-fn capability_ttl_decision_bypasses_when_metadata_missing() {
-    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(2);
-    let snapshot = capability_snapshot_with_metadata(collected_at, None);
-
-    let decision = capability_cache_ttl_decision(
-        Some(&snapshot),
-        Duration::from_secs(5),
-        SystemTime::UNIX_EPOCH + Duration::from_secs(10),
-    );
-    assert!(decision.should_probe);
-    assert_eq!(decision.policy, CapabilityCachePolicy::Bypass);
-}
-
-#[tokio::test]
-async fn probe_reprobes_when_metadata_missing() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let binary = temp.path().join("missing_codex");
-    let cache_key = capability_cache_key(&binary);
-
-    {
-        let mut cache = capability_cache().lock().unwrap();
-        cache.insert(
-            cache_key.clone(),
-            CodexCapabilities {
-                cache_key: cache_key.clone(),
-                fingerprint: None,
-                version: Some(version::parse_version_output("codex 9.9.9")),
-                features: CodexFeatureFlags {
-                    supports_features_list: true,
-                    supports_output_schema: true,
-                    supports_add_dir: true,
-                    supports_mcp_login: true,
-                },
-                probe_plan: CapabilityProbePlan::default(),
-                collected_at: SystemTime::UNIX_EPOCH,
-            },
-        );
-    }
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(1))
-        .build();
-
-    let capabilities = client.probe_capabilities().await;
-    assert!(!capabilities.features.supports_output_schema);
-    assert!(capabilities
-        .probe_plan
-        .steps
-        .contains(&CapabilityProbeStep::VersionFlag));
-
-    clear_capability_cache();
-}
-
-#[tokio::test]
-async fn probe_refresh_policy_forces_new_snapshot() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("probe.log");
-    let script = format!(
-        r#"#!/bin/bash
-echo "$@" >> "{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{{"features":["output_schema"]}}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let first = client.probe_capabilities().await;
-    assert!(first.features.supports_output_schema);
-    let first_lines = std_fs::read_to_string(&log_path).unwrap().lines().count();
-    assert!(first_lines >= 2);
-
-    let refreshed = client
-        .probe_capabilities_with_policy(CapabilityCachePolicy::Refresh)
-        .await;
-    assert!(refreshed.features.supports_output_schema);
-    let refreshed_lines = std_fs::read_to_string(&log_path).unwrap().lines().count();
-    assert!(
-        refreshed_lines > first_lines,
-        "expected refresh policy to re-run probes"
-    );
-    clear_capability_cache();
-}
-
-#[tokio::test]
-async fn probe_bypass_policy_skips_cache_writes() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let script = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":["output_schema"]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema"
-fi
-"#;
-    let binary = write_fake_codex(temp.path(), script);
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let capabilities = client
-        .probe_capabilities_with_policy(CapabilityCachePolicy::Bypass)
-        .await;
-    assert!(capabilities.features.supports_output_schema);
-    assert!(capability_cache_entry(&binary).is_none());
-    clear_capability_cache();
-}
-
-#[test]
-fn parses_features_from_json_and_text() {
-    let json = r#"{"features":["output_schema","add_dir"],"mcp_login":true}"#;
-    let parsed_json = version::parse_features_from_json(json).unwrap();
-    assert!(parsed_json.supports_output_schema);
-    assert!(parsed_json.supports_add_dir);
-    assert!(parsed_json.supports_mcp_login);
-
-    let text = "Features: output-schema add-dir login --mcp";
-    let parsed_text = version::parse_features_from_text(text);
-    assert!(parsed_text.supports_output_schema);
-    assert!(parsed_text.supports_add_dir);
-    assert!(parsed_text.supports_mcp_login);
-}
-
-#[test]
-fn parses_feature_list_json_and_text_tables() {
-    let json = r#"{"features":[{"name":"json-stream","stage":"stable","enabled":true,"notes":"keep"},{"name":"cloud-exec","stage":"experimental","enabled":false}]}"#;
-    let (json_features, json_format) = version::parse_feature_list_output(json, true).unwrap();
-    assert_eq!(json_format, FeaturesListFormat::Json);
-    assert_eq!(json_features.len(), 2);
-    assert_eq!(json_features[0].name, "json-stream");
-    assert_eq!(json_features[0].stage, Some(CodexFeatureStage::Stable));
-    assert!(json_features[0].enabled);
-    assert!(json_features[0].extra.contains_key("notes"));
-    assert_eq!(
-        json_features[1].stage,
-        Some(CodexFeatureStage::Experimental)
-    );
-    assert!(!json_features[1].enabled);
-
-    let text = r#"
-Feature   Stage         Enabled
-json-stream stable      true
-	cloud-exec experimental false
-	"#;
-    let (text_features, text_format) = version::parse_feature_list_output(text, false).unwrap();
-    assert_eq!(text_format, FeaturesListFormat::Text);
-    assert_eq!(text_features.len(), 2);
-    assert_eq!(
-        text_features[1].stage,
-        Some(CodexFeatureStage::Experimental)
-    );
-    assert!(!text_features[1].enabled);
-
-    let (fallback_features, fallback_format) =
-        version::parse_feature_list_output(text, true).unwrap();
-    assert_eq!(fallback_format, FeaturesListFormat::Text);
-    assert_eq!(fallback_features.len(), 2);
-}
-
-#[test]
-fn parses_help_output_flags() {
-    let help =
-        "Usage: codex --output-schema ... add-dir ... login --mcp. See `codex features list`.";
-    let parsed = version::parse_help_output(help);
-    assert!(parsed.supports_output_schema);
-    assert!(parsed.supports_add_dir);
-    assert!(parsed.supports_mcp_login);
-    assert!(parsed.supports_features_list);
-}
-
-#[test]
-fn capability_guard_reports_detected_support() {
-    let flags = CodexFeatureFlags {
-        supports_features_list: true,
-        supports_output_schema: true,
-        supports_add_dir: true,
-        supports_mcp_login: true,
-    };
-    let capabilities = capabilities_with_feature_flags(flags);
-
-    let output_schema = capabilities.guard_output_schema();
-    assert_eq!(output_schema.support, CapabilitySupport::Supported);
-    assert!(output_schema.is_supported());
-
-    let add_dir = capabilities.guard_add_dir();
-    assert_eq!(add_dir.support, CapabilitySupport::Supported);
-    assert!(add_dir.is_supported());
-
-    let mcp_login = capabilities.guard_mcp_login();
-    assert_eq!(mcp_login.support, CapabilitySupport::Supported);
-
-    let features_list = capabilities.guard_features_list();
-    assert_eq!(features_list.support, CapabilitySupport::Supported);
-}
-
-#[test]
-fn capability_guard_marks_absent_feature_as_unsupported() {
-    let flags = CodexFeatureFlags {
-        supports_features_list: true,
-        supports_output_schema: false,
-        supports_add_dir: false,
-        supports_mcp_login: false,
-    };
-    let capabilities = capabilities_with_feature_flags(flags);
-
-    let output_schema = capabilities.guard_output_schema();
-    assert_eq!(output_schema.support, CapabilitySupport::Unsupported);
-    assert!(!output_schema.is_supported());
-    assert!(output_schema
-        .notes
-        .iter()
-        .any(|note| note.contains("features list")));
-
-    let mcp_login = capabilities.guard_mcp_login();
-    assert_eq!(mcp_login.support, CapabilitySupport::Unsupported);
-}
-
-#[test]
-fn capability_guard_returns_unknown_without_feature_list() {
-    let capabilities = capabilities_with_feature_flags(CodexFeatureFlags::default());
-
-    let add_dir = capabilities.guard_add_dir();
-    assert_eq!(add_dir.support, CapabilitySupport::Unknown);
-    assert!(add_dir.is_unknown());
-    assert!(add_dir
-        .notes
-        .iter()
-        .any(|note| note.contains("unknown") || note.contains("unavailable")));
-
-    let features_list = capabilities.guard_features_list();
-    assert_eq!(features_list.support, CapabilitySupport::Unknown);
-}
-
-#[tokio::test]
-async fn capability_snapshot_short_circuits_probes() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("probe.log");
-    let script = format!(
-        r#"#!/bin/bash
-echo "$@" >> "{log}"
-exit 99
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-
-    let snapshot = CodexCapabilities {
-        cache_key: CapabilityCacheKey {
-            binary_path: PathBuf::from("codex"),
-        },
-        fingerprint: None,
-        version: Some(version::parse_version_output("codex 9.9.9-custom")),
-        features: CodexFeatureFlags {
-            supports_features_list: true,
-            supports_output_schema: true,
-            supports_add_dir: false,
-            supports_mcp_login: true,
-        },
-        probe_plan: CapabilityProbePlan::default(),
-        collected_at: SystemTime::now(),
-    };
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .capability_snapshot(snapshot)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let capabilities = client.probe_capabilities().await;
-    assert_eq!(
-        capabilities.cache_key.binary_path,
-        std_fs::canonicalize(&binary).unwrap()
-    );
-    assert!(capabilities.fingerprint.is_some());
-    assert!(capabilities.features.supports_output_schema);
-    assert!(capabilities.features.supports_mcp_login);
-    assert_eq!(
-        capabilities.version.as_ref().and_then(|v| v.semantic),
-        Some((9, 9, 9))
-    );
-    assert!(capabilities
-        .probe_plan
-        .steps
-        .contains(&CapabilityProbeStep::ManualOverride));
-    assert!(!log_path.exists());
-}
-
-#[tokio::test]
-async fn capability_feature_overrides_apply_to_cached_entries() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let script = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":[]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "features list"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex exec"
-fi
-"#;
-    let binary = write_fake_codex(temp.path(), script);
-
-    let base_client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-    let base_capabilities = base_client.probe_capabilities().await;
-    assert!(base_capabilities.features.supports_features_list);
-    assert!(!base_capabilities.features.supports_output_schema);
-
-    let overrides = CapabilityFeatureOverrides::enabling(CodexFeatureFlags {
-        supports_features_list: false,
-        supports_output_schema: true,
-        supports_add_dir: false,
-        supports_mcp_login: true,
-    });
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .capability_feature_overrides(overrides)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let capabilities = client.probe_capabilities().await;
-    assert!(capabilities.features.supports_output_schema);
-    assert!(capabilities.features.supports_mcp_login);
-    assert!(capabilities
-        .probe_plan
-        .steps
-        .contains(&CapabilityProbeStep::ManualOverride));
-    assert_eq!(
-        capabilities.guard_output_schema().support,
-        CapabilitySupport::Supported
-    );
-}
-
-#[tokio::test]
-async fn capability_version_override_replaces_probe_version() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let script = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 0.1.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":["add_dir"]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "add_dir"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex add-dir"
-fi
-	"#;
-    let binary = write_fake_codex(temp.path(), script);
-    let version_override = version::parse_version_output("codex 9.9.9-nightly (commit beefcafe)");
-
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .capability_version_override(version_override)
-        .build();
-
-    let capabilities = client.probe_capabilities().await;
-    assert_eq!(
-        capabilities.version.as_ref().and_then(|v| v.semantic),
-        Some((9, 9, 9))
-    );
-    assert!(matches!(
-        capabilities.version.as_ref().map(|v| v.channel),
-        Some(CodexReleaseChannel::Nightly)
-    ));
-    assert!(capabilities.features.supports_add_dir);
-    assert!(capabilities
-        .probe_plan
-        .steps
-        .contains(&CapabilityProbeStep::ManualOverride));
-    assert_eq!(
-        capabilities.guard_add_dir().support,
-        CapabilitySupport::Supported
-    );
-}
-
-#[tokio::test]
-async fn exec_applies_guarded_flags_when_supported() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("exec.log");
-    let script = format!(
-        r#"#!/bin/bash
-log="{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.2.3"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{{"features":["output_schema","add_dir","mcp_login"]}}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema add_dir login --mcp"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex --output-schema add-dir login --mcp"
-elif [[ "$1" == "exec" ]]; then
-  echo "$@" >> "$log"
-  echo "ok"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .add_dir("src")
-        .output_schema(true)
-        .quiet(true)
-        .mirror_stdout(false)
-        .build();
-
-    let response = client.send_prompt("hello").await.unwrap();
-    assert_eq!(response.trim(), "ok");
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(logged.contains("--add-dir"));
-    assert!(logged.contains("src"));
-    assert!(logged.contains("--output-schema"));
-}
-
-#[tokio::test]
-async fn exec_skips_guarded_flags_when_unknown() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("exec.log");
-    let script = format!(
-        r#"#!/bin/bash
-log="{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 0.9.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo "feature list unavailable" >&2
-  exit 1
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "feature list unavailable" >&2
-  exit 1
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex exec"
-elif [[ "$1" == "exec" ]]; then
-  echo "$@" >> "$log"
-  echo "ok"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .add_dir("src")
-        .output_schema(true)
-        .quiet(true)
-        .mirror_stdout(false)
-        .build();
-
-    let response = client.send_prompt("hello").await.unwrap();
-    assert_eq!(response.trim(), "ok");
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(!logged.contains("--add-dir"));
-    assert!(!logged.contains("--output-schema"));
-}
-
-#[tokio::test]
-async fn mcp_login_skips_when_unsupported() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("login.log");
-    let script = format!(
-        r#"#!/bin/bash
-log="{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{{"features":["output_schema","add_dir"]}}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema add-dir"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex exec"
-elif [[ "$1" == "login" ]]; then
-  echo "$@" >> "$log"
-  echo "login invoked"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let login = client.spawn_mcp_login_process().await.unwrap();
-    assert!(login.is_none());
-    assert!(!log_path.exists());
-}
-
-#[tokio::test]
-async fn mcp_login_runs_when_supported() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let log_path = temp.path().join("login.log");
-    let script = format!(
-        r#"#!/bin/bash
-log="{log}"
-if [[ "$1" == "--version" ]]; then
-  echo "codex 2.0.0"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{{"features":["output_schema","add_dir"],"mcp_login":true}}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema add_dir login --mcp"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex --output-schema add-dir login --mcp"
-elif [[ "$1" == "login" ]]; then
-  echo "$@" >> "$log"
-  echo "login invoked"
-fi
-"#,
-        log = log_path.display()
-    );
-    let binary = write_fake_codex(temp.path(), &script);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let login = client
-        .spawn_mcp_login_process()
-        .await
-        .unwrap()
-        .expect("expected login child");
-    let output = login.wait_with_output().await.unwrap();
-    assert!(output.status.success());
-
-    let logged = std_fs::read_to_string(&log_path).unwrap();
-    assert!(logged.contains("login --mcp"));
-}
-
-#[tokio::test]
-async fn probe_capabilities_caches_and_invalidates() {
-    let _guard = env_guard_async().await;
-    clear_capability_cache();
-
-    let temp = tempfile::tempdir().unwrap();
-    let script_v1 = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 1.2.3-beta (commit cafe123)"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":["output_schema","add_dir","mcp_login"]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "output_schema add-dir login --mcp"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex --output-schema add-dir login --mcp"
-fi
-"#;
-    let binary = write_fake_codex(temp.path(), script_v1);
-    let client = CodexClient::builder()
-        .binary(&binary)
-        .timeout(Duration::from_secs(5))
-        .build();
-
-    let first = client.probe_capabilities().await;
-    assert_eq!(
-        first.version.as_ref().and_then(|v| v.semantic),
-        Some((1, 2, 3))
-    );
-    assert_eq!(
-        first.version.as_ref().map(|v| v.channel),
-        Some(CodexReleaseChannel::Beta)
-    );
-    assert_eq!(
-        first.version.as_ref().and_then(|v| v.commit.as_deref()),
-        Some("cafe123")
-    );
-    assert!(first.features.supports_features_list);
-    assert!(first.features.supports_output_schema);
-    assert!(first.features.supports_add_dir);
-    assert!(first.features.supports_mcp_login);
-
-    let cached = client.probe_capabilities().await;
-    assert_eq!(cached, first);
-
-    let script_v2 = r#"#!/bin/bash
-if [[ "$1" == "--version" ]]; then
-  echo "codex 2.0.0 (commit deadbeef)"
-elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
-  echo '{"features":["add_dir"]}'
-elif [[ "$1" == "features" && "$2" == "list" ]]; then
-  echo "add-dir"
-elif [[ "$1" == "--help" ]]; then
-  echo "Usage: codex add-dir"
-fi
-"#;
-    std_fs::write(&binary, script_v2).unwrap();
-    let mut perms = std_fs::metadata(&binary).unwrap().permissions();
-    perms.set_mode(0o755);
-    std_fs::set_permissions(&binary, perms).unwrap();
-
-    let refreshed = client.probe_capabilities().await;
-    assert_ne!(refreshed.version, first.version);
-    assert_eq!(
-        refreshed.version.as_ref().and_then(|v| v.semantic),
-        Some((2, 0, 0))
-    );
-    assert!(refreshed.features.supports_features_list);
-    assert!(refreshed.features.supports_add_dir);
-    assert!(!refreshed.features.supports_output_schema);
-    assert!(!refreshed.features.supports_mcp_login);
-    clear_capability_cache();
-}
+mod exec_and_login;
+mod feature_parsing_and_guards;
+mod overrides_and_probe;
+mod probe_cache_policy;
+mod snapshots_and_cache;
+mod version_and_advisory;
diff --git a/crates/codex/src/tests/capabilities/exec_and_login.rs b/crates/codex/src/tests/capabilities/exec_and_login.rs
new file mode 100644
index 0000000..b8b1f5f
--- /dev/null
+++ b/crates/codex/src/tests/capabilities/exec_and_login.rs
@@ -0,0 +1,242 @@
+use super::*;
+
+#[tokio::test]
+async fn exec_applies_guarded_flags_when_supported() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("exec.log");
+    let script = format!(
+        r#"#!/bin/bash
+log="{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.2.3"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{{"features":["output_schema","add_dir","mcp_login"]}}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema add_dir login --mcp"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex --output-schema add-dir login --mcp"
+elif [[ "$1" == "exec" ]]; then
+  echo "$@" >> "$log"
+  echo "ok"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .add_dir("src")
+        .output_schema(true)
+        .quiet(true)
+        .mirror_stdout(false)
+        .build();
+
+    let response = client.send_prompt("hello").await.unwrap();
+    assert_eq!(response.trim(), "ok");
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(logged.contains("--add-dir"));
+    assert!(logged.contains("src"));
+    assert!(logged.contains("--output-schema"));
+}
+
+#[tokio::test]
+async fn exec_skips_guarded_flags_when_unknown() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("exec.log");
+    let script = format!(
+        r#"#!/bin/bash
+log="{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 0.9.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo "feature list unavailable" >&2
+  exit 1
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "feature list unavailable" >&2
+  exit 1
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex exec"
+elif [[ "$1" == "exec" ]]; then
+  echo "$@" >> "$log"
+  echo "ok"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .add_dir("src")
+        .output_schema(true)
+        .quiet(true)
+        .mirror_stdout(false)
+        .build();
+
+    let response = client.send_prompt("hello").await.unwrap();
+    assert_eq!(response.trim(), "ok");
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(!logged.contains("--add-dir"));
+    assert!(!logged.contains("--output-schema"));
+}
+
+#[tokio::test]
+async fn mcp_login_skips_when_unsupported() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("login.log");
+    let script = format!(
+        r#"#!/bin/bash
+log="{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{{"features":["output_schema","add_dir"]}}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema add-dir"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex exec"
+elif [[ "$1" == "login" ]]; then
+  echo "$@" >> "$log"
+  echo "login invoked"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let login = client.spawn_mcp_login_process().await.unwrap();
+    assert!(login.is_none());
+    assert!(!log_path.exists());
+}
+
+#[tokio::test]
+async fn mcp_login_runs_when_supported() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("login.log");
+    let script = format!(
+        r#"#!/bin/bash
+log="{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 2.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{{"features":["output_schema","add_dir"],"mcp_login":true}}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema add_dir login --mcp"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex --output-schema add-dir login --mcp"
+elif [[ "$1" == "login" ]]; then
+  echo "$@" >> "$log"
+  echo "login invoked"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let login = client
+        .spawn_mcp_login_process()
+        .await
+        .unwrap()
+        .expect("expected login child");
+    let output = login.wait_with_output().await.unwrap();
+    assert!(output.status.success());
+
+    let logged = std_fs::read_to_string(&log_path).unwrap();
+    assert!(logged.contains("login --mcp"));
+}
+
+#[tokio::test]
+async fn probe_capabilities_caches_and_invalidates() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let script_v1 = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.2.3-beta (commit cafe123)"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":["output_schema","add_dir","mcp_login"]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema add-dir login --mcp"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex --output-schema add-dir login --mcp"
+fi
+"#;
+    let binary = write_fake_codex(temp.path(), script_v1);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let first = client.probe_capabilities().await;
+    assert_eq!(
+        first.version.as_ref().and_then(|v| v.semantic),
+        Some((1, 2, 3))
+    );
+    assert_eq!(
+        first.version.as_ref().map(|v| v.channel),
+        Some(CodexReleaseChannel::Beta)
+    );
+    assert_eq!(
+        first.version.as_ref().and_then(|v| v.commit.as_deref()),
+        Some("cafe123")
+    );
+    assert!(first.features.supports_features_list);
+    assert!(first.features.supports_output_schema);
+    assert!(first.features.supports_add_dir);
+    assert!(first.features.supports_mcp_login);
+
+    let cached = client.probe_capabilities().await;
+    assert_eq!(cached, first);
+
+    let script_v2 = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 2.0.0 (commit deadbeef)"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":["add_dir"]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "add-dir"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex add-dir"
+fi
+"#;
+    std_fs::write(&binary, script_v2).unwrap();
+    let mut perms = std_fs::metadata(&binary).unwrap().permissions();
+    perms.set_mode(0o755);
+    std_fs::set_permissions(&binary, perms).unwrap();
+
+    let refreshed = client.probe_capabilities().await;
+    assert_ne!(refreshed.version, first.version);
+    assert_eq!(
+        refreshed.version.as_ref().and_then(|v| v.semantic),
+        Some((2, 0, 0))
+    );
+    assert!(refreshed.features.supports_features_list);
+    assert!(refreshed.features.supports_add_dir);
+    assert!(!refreshed.features.supports_output_schema);
+    assert!(!refreshed.features.supports_mcp_login);
+    clear_capability_cache();
+}
diff --git a/crates/codex/src/tests/capabilities/feature_parsing_and_guards.rs b/crates/codex/src/tests/capabilities/feature_parsing_and_guards.rs
new file mode 100644
index 0000000..3698043
--- /dev/null
+++ b/crates/codex/src/tests/capabilities/feature_parsing_and_guards.rs
@@ -0,0 +1,126 @@
+use super::*;
+
+#[test]
+fn parses_features_from_json_and_text() {
+    let json = r#"{"features":["output_schema","add_dir"],"mcp_login":true}"#;
+    let parsed_json = version::parse_features_from_json(json).unwrap();
+    assert!(parsed_json.supports_output_schema);
+    assert!(parsed_json.supports_add_dir);
+    assert!(parsed_json.supports_mcp_login);
+
+    let text = "Features: output-schema add-dir login --mcp";
+    let parsed_text = version::parse_features_from_text(text);
+    assert!(parsed_text.supports_output_schema);
+    assert!(parsed_text.supports_add_dir);
+    assert!(parsed_text.supports_mcp_login);
+}
+
+#[test]
+fn parses_feature_list_json_and_text_tables() {
+    let json = r#"{"features":[{"name":"json-stream","stage":"stable","enabled":true,"notes":"keep"},{"name":"cloud-exec","stage":"experimental","enabled":false}]}"#;
+    let (json_features, json_format) = version::parse_feature_list_output(json, true).unwrap();
+    assert_eq!(json_format, FeaturesListFormat::Json);
+    assert_eq!(json_features.len(), 2);
+    assert_eq!(json_features[0].name, "json-stream");
+    assert_eq!(json_features[0].stage, Some(CodexFeatureStage::Stable));
+    assert!(json_features[0].enabled);
+    assert!(json_features[0].extra.contains_key("notes"));
+    assert_eq!(
+        json_features[1].stage,
+        Some(CodexFeatureStage::Experimental)
+    );
+    assert!(!json_features[1].enabled);
+
+    let text = r#"
+Feature   Stage         Enabled
+json-stream stable      true
+	cloud-exec experimental false
+	"#;
+    let (text_features, text_format) = version::parse_feature_list_output(text, false).unwrap();
+    assert_eq!(text_format, FeaturesListFormat::Text);
+    assert_eq!(text_features.len(), 2);
+    assert_eq!(
+        text_features[1].stage,
+        Some(CodexFeatureStage::Experimental)
+    );
+    assert!(!text_features[1].enabled);
+
+    let (fallback_features, fallback_format) =
+        version::parse_feature_list_output(text, true).unwrap();
+    assert_eq!(fallback_format, FeaturesListFormat::Text);
+    assert_eq!(fallback_features.len(), 2);
+}
+
+#[test]
+fn parses_help_output_flags() {
+    let help =
+        "Usage: codex --output-schema ... add-dir ... login --mcp. See `codex features list`.";
+    let parsed = version::parse_help_output(help);
+    assert!(parsed.supports_output_schema);
+    assert!(parsed.supports_add_dir);
+    assert!(parsed.supports_mcp_login);
+    assert!(parsed.supports_features_list);
+}
+
+#[test]
+fn capability_guard_reports_detected_support() {
+    let flags = CodexFeatureFlags {
+        supports_features_list: true,
+        supports_output_schema: true,
+        supports_add_dir: true,
+        supports_mcp_login: true,
+    };
+    let capabilities = capabilities_with_feature_flags(flags);
+
+    let output_schema = capabilities.guard_output_schema();
+    assert_eq!(output_schema.support, CapabilitySupport::Supported);
+    assert!(output_schema.is_supported());
+
+    let add_dir = capabilities.guard_add_dir();
+    assert_eq!(add_dir.support, CapabilitySupport::Supported);
+    assert!(add_dir.is_supported());
+
+    let mcp_login = capabilities.guard_mcp_login();
+    assert_eq!(mcp_login.support, CapabilitySupport::Supported);
+
+    let features_list = capabilities.guard_features_list();
+    assert_eq!(features_list.support, CapabilitySupport::Supported);
+}
+
+#[test]
+fn capability_guard_marks_absent_feature_as_unsupported() {
+    let flags = CodexFeatureFlags {
+        supports_features_list: true,
+        supports_output_schema: false,
+        supports_add_dir: false,
+        supports_mcp_login: false,
+    };
+    let capabilities = capabilities_with_feature_flags(flags);
+
+    let output_schema = capabilities.guard_output_schema();
+    assert_eq!(output_schema.support, CapabilitySupport::Unsupported);
+    assert!(!output_schema.is_supported());
+    assert!(output_schema
+        .notes
+        .iter()
+        .any(|note| note.contains("features list")));
+
+    let mcp_login = capabilities.guard_mcp_login();
+    assert_eq!(mcp_login.support, CapabilitySupport::Unsupported);
+}
+
+#[test]
+fn capability_guard_returns_unknown_without_feature_list() {
+    let capabilities = capabilities_with_feature_flags(CodexFeatureFlags::default());
+
+    let add_dir = capabilities.guard_add_dir();
+    assert_eq!(add_dir.support, CapabilitySupport::Unknown);
+    assert!(add_dir.is_unknown());
+    assert!(add_dir
+        .notes
+        .iter()
+        .any(|note| note.contains("unknown") || note.contains("unavailable")));
+
+    let features_list = capabilities.guard_features_list();
+    assert_eq!(features_list.support, CapabilitySupport::Unknown);
+}
diff --git a/crates/codex/src/tests/capabilities/overrides_and_probe.rs b/crates/codex/src/tests/capabilities/overrides_and_probe.rs
new file mode 100644
index 0000000..1161957
--- /dev/null
+++ b/crates/codex/src/tests/capabilities/overrides_and_probe.rs
@@ -0,0 +1,157 @@
+use super::*;
+
+#[tokio::test]
+async fn capability_snapshot_short_circuits_probes() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("probe.log");
+    let script = format!(
+        r#"#!/bin/bash
+echo "$@" >> "{log}"
+exit 99
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+
+    let snapshot = CodexCapabilities {
+        cache_key: CapabilityCacheKey {
+            binary_path: PathBuf::from("codex"),
+        },
+        fingerprint: None,
+        version: Some(version::parse_version_output("codex 9.9.9-custom")),
+        features: CodexFeatureFlags {
+            supports_features_list: true,
+            supports_output_schema: true,
+            supports_add_dir: false,
+            supports_mcp_login: true,
+        },
+        probe_plan: CapabilityProbePlan::default(),
+        collected_at: SystemTime::now(),
+    };
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .capability_snapshot(snapshot)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let capabilities = client.probe_capabilities().await;
+    assert_eq!(
+        capabilities.cache_key.binary_path,
+        std_fs::canonicalize(&binary).unwrap()
+    );
+    assert!(capabilities.fingerprint.is_some());
+    assert!(capabilities.features.supports_output_schema);
+    assert!(capabilities.features.supports_mcp_login);
+    assert_eq!(
+        capabilities.version.as_ref().and_then(|v| v.semantic),
+        Some((9, 9, 9))
+    );
+    assert!(capabilities
+        .probe_plan
+        .steps
+        .contains(&CapabilityProbeStep::ManualOverride));
+    assert!(!log_path.exists());
+}
+
+#[tokio::test]
+async fn capability_feature_overrides_apply_to_cached_entries() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let script = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":[]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "features list"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex exec"
+fi
+"#;
+    let binary = write_fake_codex(temp.path(), script);
+
+    let base_client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+    let base_capabilities = base_client.probe_capabilities().await;
+    assert!(base_capabilities.features.supports_features_list);
+    assert!(!base_capabilities.features.supports_output_schema);
+
+    let overrides = CapabilityFeatureOverrides::enabling(CodexFeatureFlags {
+        supports_features_list: false,
+        supports_output_schema: true,
+        supports_add_dir: false,
+        supports_mcp_login: true,
+    });
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .capability_feature_overrides(overrides)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let capabilities = client.probe_capabilities().await;
+    assert!(capabilities.features.supports_output_schema);
+    assert!(capabilities.features.supports_mcp_login);
+    assert!(capabilities
+        .probe_plan
+        .steps
+        .contains(&CapabilityProbeStep::ManualOverride));
+    assert_eq!(
+        capabilities.guard_output_schema().support,
+        CapabilitySupport::Supported
+    );
+}
+
+#[tokio::test]
+async fn capability_version_override_replaces_probe_version() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let script = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 0.1.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":["add_dir"]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "add_dir"
+elif [[ "$1" == "--help" ]]; then
+  echo "Usage: codex add-dir"
+fi
+	"#;
+    let binary = write_fake_codex(temp.path(), script);
+    let version_override = version::parse_version_output("codex 9.9.9-nightly (commit beefcafe)");
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .capability_version_override(version_override)
+        .build();
+
+    let capabilities = client.probe_capabilities().await;
+    assert_eq!(
+        capabilities.version.as_ref().and_then(|v| v.semantic),
+        Some((9, 9, 9))
+    );
+    assert!(matches!(
+        capabilities.version.as_ref().map(|v| v.channel),
+        Some(CodexReleaseChannel::Nightly)
+    ));
+    assert!(capabilities.features.supports_add_dir);
+    assert!(capabilities
+        .probe_plan
+        .steps
+        .contains(&CapabilityProbeStep::ManualOverride));
+    assert_eq!(
+        capabilities.guard_add_dir().support,
+        CapabilitySupport::Supported
+    );
+}
diff --git a/crates/codex/src/tests/capabilities/probe_cache_policy.rs b/crates/codex/src/tests/capabilities/probe_cache_policy.rs
new file mode 100644
index 0000000..974644a
--- /dev/null
+++ b/crates/codex/src/tests/capabilities/probe_cache_policy.rs
@@ -0,0 +1,118 @@
+use super::*;
+
+#[tokio::test]
+async fn probe_reprobes_when_metadata_missing() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let binary = temp.path().join("missing_codex");
+    let cache_key = capability_cache_key(&binary);
+
+    {
+        let mut cache = capability_cache().lock().unwrap();
+        cache.insert(
+            cache_key.clone(),
+            CodexCapabilities {
+                cache_key: cache_key.clone(),
+                fingerprint: None,
+                version: Some(version::parse_version_output("codex 9.9.9")),
+                features: CodexFeatureFlags {
+                    supports_features_list: true,
+                    supports_output_schema: true,
+                    supports_add_dir: true,
+                    supports_mcp_login: true,
+                },
+                probe_plan: CapabilityProbePlan::default(),
+                collected_at: SystemTime::UNIX_EPOCH,
+            },
+        );
+    }
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(1))
+        .build();
+
+    let capabilities = client.probe_capabilities().await;
+    assert!(!capabilities.features.supports_output_schema);
+    assert!(capabilities
+        .probe_plan
+        .steps
+        .contains(&CapabilityProbeStep::VersionFlag));
+
+    clear_capability_cache();
+}
+
+#[tokio::test]
+async fn probe_refresh_policy_forces_new_snapshot() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let log_path = temp.path().join("probe.log");
+    let script = format!(
+        r#"#!/bin/bash
+echo "$@" >> "{log}"
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{{"features":["output_schema"]}}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema"
+fi
+"#,
+        log = log_path.display()
+    );
+    let binary = write_fake_codex(temp.path(), &script);
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let first = client.probe_capabilities().await;
+    assert!(first.features.supports_output_schema);
+    let first_lines = std_fs::read_to_string(&log_path).unwrap().lines().count();
+    assert!(first_lines >= 2);
+
+    let refreshed = client
+        .probe_capabilities_with_policy(CapabilityCachePolicy::Refresh)
+        .await;
+    assert!(refreshed.features.supports_output_schema);
+    let refreshed_lines = std_fs::read_to_string(&log_path).unwrap().lines().count();
+    assert!(
+        refreshed_lines > first_lines,
+        "expected refresh policy to re-run probes"
+    );
+    clear_capability_cache();
+}
+
+#[tokio::test]
+async fn probe_bypass_policy_skips_cache_writes() {
+    let _guard = env_guard_async().await;
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let script = r#"#!/bin/bash
+if [[ "$1" == "--version" ]]; then
+  echo "codex 1.0.0"
+elif [[ "$1" == "features" && "$2" == "list" && "$3" == "--json" ]]; then
+  echo '{"features":["output_schema"]}'
+elif [[ "$1" == "features" && "$2" == "list" ]]; then
+  echo "output_schema"
+fi
+"#;
+    let binary = write_fake_codex(temp.path(), script);
+
+    let client = CodexClient::builder()
+        .binary(&binary)
+        .timeout(Duration::from_secs(5))
+        .build();
+
+    let capabilities = client
+        .probe_capabilities_with_policy(CapabilityCachePolicy::Bypass)
+        .await;
+    assert!(capabilities.features.supports_output_schema);
+    assert!(capability_cache_entry(&binary).is_none());
+    clear_capability_cache();
+}
diff --git a/crates/codex/src/tests/capabilities/snapshots_and_cache.rs b/crates/codex/src/tests/capabilities/snapshots_and_cache.rs
new file mode 100644
index 0000000..bc6cb6c
--- /dev/null
+++ b/crates/codex/src/tests/capabilities/snapshots_and_cache.rs
@@ -0,0 +1,163 @@
+use super::*;
+
+#[test]
+fn capability_snapshots_serialize_to_json_and_toml() {
+    let snapshot = sample_capabilities_snapshot();
+
+    let json = serialize_capabilities_snapshot(&snapshot, CapabilitySnapshotFormat::Json)
+        .expect("serialize json");
+    let parsed_json = deserialize_capabilities_snapshot(&json, CapabilitySnapshotFormat::Json)
+        .expect("parse json");
+    assert_eq!(parsed_json, snapshot);
+
+    let toml = serialize_capabilities_snapshot(&snapshot, CapabilitySnapshotFormat::Toml)
+        .expect("serialize toml");
+    let parsed_toml = deserialize_capabilities_snapshot(&toml, CapabilitySnapshotFormat::Toml)
+        .expect("parse toml");
+    assert_eq!(parsed_toml, snapshot);
+}
+
+#[test]
+fn capability_snapshots_and_overrides_round_trip_via_files() {
+    let snapshot = sample_capabilities_snapshot();
+    let overrides = sample_capability_overrides();
+    let temp = tempfile::tempdir().unwrap();
+
+    let snapshot_path = temp.path().join("capabilities.toml");
+    write_capabilities_snapshot(&snapshot_path, &snapshot, None).unwrap();
+    let loaded_snapshot = read_capabilities_snapshot(&snapshot_path, None).unwrap();
+    assert_eq!(loaded_snapshot, snapshot);
+
+    let overrides_path = temp.path().join("overrides.json");
+    write_capability_overrides(&overrides_path, &overrides, None).unwrap();
+    let loaded_overrides = read_capability_overrides(&overrides_path, None).unwrap();
+    assert_eq!(loaded_overrides, overrides);
+}
+
+#[test]
+fn capability_snapshot_match_checks_fingerprint() {
+    let temp = tempfile::tempdir().unwrap();
+    let script = "#!/bin/bash\necho ok";
+    let binary = write_fake_codex(temp.path(), script);
+    let cache_key = capability_cache_key(&binary);
+    let fingerprint = current_fingerprint(&cache_key);
+
+    let snapshot = CodexCapabilities {
+        cache_key: cache_key.clone(),
+        fingerprint: fingerprint.clone(),
+        version: None,
+        features: CodexFeatureFlags::default(),
+        probe_plan: CapabilityProbePlan::default(),
+        collected_at: SystemTime::UNIX_EPOCH,
+    };
+
+    assert!(capability_snapshot_matches_binary(&snapshot, &binary));
+    let mut missing_fingerprint = snapshot.clone();
+    missing_fingerprint.fingerprint = None;
+    assert!(!capability_snapshot_matches_binary(
+        &missing_fingerprint,
+        &binary
+    ));
+
+    std_fs::write(&binary, "#!/bin/bash\necho changed").unwrap();
+    let mut perms = std_fs::metadata(&binary).unwrap().permissions();
+    perms.set_mode(0o755);
+    std_fs::set_permissions(&binary, perms).unwrap();
+
+    assert!(!capability_snapshot_matches_binary(&snapshot, &binary));
+}
+
+#[test]
+fn capability_cache_entries_exposes_cache_state() {
+    let _guard = env_guard();
+    clear_capability_cache();
+
+    let temp = tempfile::tempdir().unwrap();
+    let binary = write_fake_codex(temp.path(), "#!/bin/bash\necho ok");
+    let cache_key = capability_cache_key(&binary);
+    let fingerprint = current_fingerprint(&cache_key);
+
+    let snapshot = CodexCapabilities {
+        cache_key: cache_key.clone(),
+        fingerprint: fingerprint.clone(),
+        version: Some(version::parse_version_output("codex 0.0.1")),
+        features: CodexFeatureFlags {
+            supports_features_list: true,
+            supports_output_schema: true,
+            supports_add_dir: false,
+            supports_mcp_login: false,
+        },
+        probe_plan: CapabilityProbePlan {
+            steps: vec![CapabilityProbeStep::VersionFlag],
+        },
+        collected_at: SystemTime::UNIX_EPOCH,
+    };
+
+    update_capability_cache(snapshot.clone());
+
+    let entries = capability_cache_entries();
+    assert!(entries.iter().any(|entry| entry.cache_key == cache_key));
+
+    let fetched = capability_cache_entry(&binary).expect("expected cache entry");
+    assert_eq!(fetched.cache_key, cache_key);
+    assert!(clear_capability_cache_entry(&binary));
+    assert!(capability_cache_entry(&binary).is_none());
+    assert!(capability_cache_entries().is_empty());
+    clear_capability_cache();
+}
+
+#[test]
+fn capability_ttl_decision_reuses_fresh_snapshot() {
+    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(10);
+    let snapshot = capability_snapshot_with_metadata(
+        collected_at,
+        Some(BinaryFingerprint {
+            canonical_path: Some(PathBuf::from("/tmp/codex")),
+            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(1)),
+            len: Some(123),
+        }),
+    );
+
+    let decision = capability_cache_ttl_decision(
+        Some(&snapshot),
+        Duration::from_secs(300),
+        SystemTime::UNIX_EPOCH + Duration::from_secs(100),
+    );
+    assert!(!decision.should_probe);
+    assert_eq!(decision.policy, CapabilityCachePolicy::PreferCache);
+}
+
+#[test]
+fn capability_ttl_decision_refreshes_after_ttl_with_fingerprint() {
+    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(1);
+    let snapshot = capability_snapshot_with_metadata(
+        collected_at,
+        Some(BinaryFingerprint {
+            canonical_path: Some(PathBuf::from("/tmp/codex")),
+            modified: Some(SystemTime::UNIX_EPOCH + Duration::from_secs(1)),
+            len: Some(321),
+        }),
+    );
+
+    let decision = capability_cache_ttl_decision(
+        Some(&snapshot),
+        Duration::from_secs(5),
+        SystemTime::UNIX_EPOCH + Duration::from_secs(10),
+    );
+    assert!(decision.should_probe);
+    assert_eq!(decision.policy, CapabilityCachePolicy::Refresh);
+}
+
+#[test]
+fn capability_ttl_decision_bypasses_when_metadata_missing() {
+    let collected_at = SystemTime::UNIX_EPOCH + Duration::from_secs(2);
+    let snapshot = capability_snapshot_with_metadata(collected_at, None);
+
+    let decision = capability_cache_ttl_decision(
+        Some(&snapshot),
+        Duration::from_secs(5),
+        SystemTime::UNIX_EPOCH + Duration::from_secs(10),
+    );
+    assert!(decision.should_probe);
+    assert_eq!(decision.policy, CapabilityCachePolicy::Bypass);
+}
diff --git a/crates/codex/src/tests/capabilities/version_and_advisory.rs b/crates/codex/src/tests/capabilities/version_and_advisory.rs
new file mode 100644
index 0000000..316ad84
--- /dev/null
+++ b/crates/codex/src/tests/capabilities/version_and_advisory.rs
@@ -0,0 +1,105 @@
+use super::*;
+
+#[test]
+fn parses_version_output_fields() {
+    let parsed = version::parse_version_output("codex v3.4.5-nightly (commit abc1234)");
+    assert_eq!(parsed.semantic, Some((3, 4, 5)));
+    assert_eq!(parsed.channel, CodexReleaseChannel::Nightly);
+    assert_eq!(parsed.commit.as_deref(), Some("abc1234"));
+    assert_eq!(
+        parsed.raw,
+        "codex v3.4.5-nightly (commit abc1234)".to_string()
+    );
+}
+
+#[test]
+fn update_advisory_detects_newer_release() {
+    let capabilities = capabilities_with_version("codex 1.0.0");
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("1.1.0").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::UpdateRecommended);
+    assert!(advisory.is_update_recommended());
+    assert_eq!(
+        advisory
+            .latest_release
+            .as_ref()
+            .map(|release| release.version.clone()),
+        latest.stable
+    );
+}
+
+#[test]
+fn update_advisory_handles_unknown_local_version() {
+    let capabilities = capabilities_without_version();
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("3.2.1").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::UnknownLocalVersion);
+    assert!(advisory.is_update_recommended());
+    assert!(advisory
+        .notes
+        .iter()
+        .any(|note| note.contains("could not be parsed")));
+}
+
+#[test]
+fn update_advisory_marks_up_to_date() {
+    let capabilities = capabilities_with_version("codex 2.0.1");
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("2.0.1").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::UpToDate);
+    assert!(!advisory.is_update_recommended());
+}
+
+#[test]
+fn update_advisory_falls_back_when_channel_missing() {
+    let capabilities = capabilities_with_version("codex 2.0.0-beta");
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("2.0.1").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.comparison_channel, CodexReleaseChannel::Stable);
+    assert_eq!(advisory.status, CodexUpdateStatus::UpdateRecommended);
+    assert!(advisory
+        .notes
+        .iter()
+        .any(|note| note.contains("comparing against stable")));
+}
+
+#[test]
+fn update_advisory_handles_local_newer_than_known() {
+    let capabilities = capabilities_with_version("codex 2.0.0");
+    let latest = CodexLatestReleases {
+        stable: Some(Version::parse("1.9.9").unwrap()),
+        ..Default::default()
+    };
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::LocalNewerThanKnown);
+    assert!(!advisory.is_update_recommended());
+    assert!(advisory
+        .notes
+        .iter()
+        .any(|note| note.contains("newer than provided")));
+}
+
+#[test]
+fn update_advisory_handles_missing_latest_metadata() {
+    let capabilities = capabilities_with_version("codex 1.0.0");
+    let latest = CodexLatestReleases::default();
+    let advisory = update_advisory_from_capabilities(&capabilities, &latest);
+    assert_eq!(advisory.status, CodexUpdateStatus::UnknownLatestVersion);
+    assert!(!advisory.is_update_recommended());
+    assert!(advisory
+        .notes
+        .iter()
+        .any(|note| note.contains("advisory unavailable")));
+}
diff --git a/evidence_runs/2026-02-05/P4.5_BASE_STEP.txt b/evidence_runs/2026-02-05/P4.5_BASE_STEP.txt
new file mode 100644
index 0000000..b29a77f
--- /dev/null
+++ b/evidence_runs/2026-02-05/P4.5_BASE_STEP.txt
@@ -0,0 +1 @@
+9ab465f548b210ac3a699698162db5fbce38d506
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_audit.txt b/evidence_runs/2026-02-05/P4.5_cargo_audit.txt
new file mode 100644
index 0000000..ca2ae86
--- /dev/null
+++ b/evidence_runs/2026-02-05/P4.5_cargo_audit.txt
@@ -0,0 +1,5 @@
+    Fetching advisory database from `https://github.com/RustSec/advisory-db.git`
+error: couldn't fetch advisory database: I/O operation failed: failed to obtain lock file '/home/dev/.cargo/advisory-db..lock'
+Caused by:
+  -> failed to obtain lock file '/home/dev/.cargo/advisory-db..lock'
+  -> attempted to take an exclusive lock on a read-only path
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_audit_after.txt b/evidence_runs/2026-02-05/P4.5_cargo_audit_after.txt
new file mode 100644
index 0000000..002935d
--- /dev/null
+++ b/evidence_runs/2026-02-05/P4.5_cargo_audit_after.txt
@@ -0,0 +1,3 @@
+      Loaded 909 security advisories (from /home/dev/.cargo/advisory-db)
+warning: couldn't open crates.io index: I/O operation failed: failed to obtain lock file '/home/dev/.cargo/.package-cache'
+    Scanning Cargo.lock for vulnerabilities (190 crate dependencies)
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_clippy.txt b/evidence_runs/2026-02-05/P4.5_cargo_clippy.txt
new file mode 100644
index 0000000..3a3b1e8
--- /dev/null
+++ b/evidence_runs/2026-02-05/P4.5_cargo_clippy.txt
@@ -0,0 +1,2 @@
+    Checking codex v0.2.0 (/home/dev/__Active_Code/codex_wrapper_new/crates/codex)
+    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.80s
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_deny_advisories.txt b/evidence_runs/2026-02-05/P4.5_cargo_deny_advisories.txt
new file mode 100644
index 0000000..602e149
--- /dev/null
+++ b/evidence_runs/2026-02-05/P4.5_cargo_deny_advisories.txt
@@ -0,0 +1 @@
+2026-02-05 21:59:32 [ERROR] failed to acquire advisory database lock: failed to obtain lock file '/home/dev/.cargo/advisory-dbs/db.lock': attempted to take an exclusive lock on a read-only path
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_deny_advisories_after.txt b/evidence_runs/2026-02-05/P4.5_cargo_deny_advisories_after.txt
new file mode 100644
index 0000000..fe21260
--- /dev/null
+++ b/evidence_runs/2026-02-05/P4.5_cargo_deny_advisories_after.txt
@@ -0,0 +1 @@
+advisories ok
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_deny_licenses.txt b/evidence_runs/2026-02-05/P4.5_cargo_deny_licenses.txt
new file mode 100644
index 0000000..ea02fc9
--- /dev/null
+++ b/evidence_runs/2026-02-05/P4.5_cargo_deny_licenses.txt
@@ -0,0 +1 @@
+licenses ok
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_fmt_check.txt b/evidence_runs/2026-02-05/P4.5_cargo_fmt_check.txt
new file mode 100644
index 0000000..e69de29
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_fmt_check_final.txt b/evidence_runs/2026-02-05/P4.5_cargo_fmt_check_final.txt
new file mode 100644
index 0000000..e69de29
diff --git a/evidence_runs/2026-02-05/P4.5_cargo_test.txt b/evidence_runs/2026-02-05/P4.5_cargo_test.txt
new file mode 100644
index 0000000..258da36
--- /dev/null
+++ b/evidence_runs/2026-02-05/P4.5_cargo_test.txt
@@ -0,0 +1,533 @@
+   Compiling codex v0.2.0 (/home/dev/__Active_Code/codex_wrapper_new/crates/codex)
+    Finished `test` profile [unoptimized + debuginfo] target(s) in 3.01s
+     Running unittests src/lib.rs (target/debug/deps/codex-e47e587a1a97e35d)
+
+running 131 tests
+test mcp::tests_runtime_app::app_runtime_api::app_runtime_api_not_found_errors ... ok
+test mcp::tests_runtime_app::runtime_manager::http_connector_retrieval_is_non_destructive ... ok
+test mcp::tests_runtime_app::runtime_manager::runtime_manager_propagates_tool_hints_for_http ... ok
+test mcp::tests_core::config_runtime::streamable_http_connector_converts_timeouts_and_headers ... ok
+test mcp::tests_core::config_runtime::runtime_http_preserves_existing_auth_header ... ok
+test mcp::tests_core::config_runtime::add_streamable_http_sets_token_and_allows_login_logout ... ok
+test tests::modularized::auth_session::parse_login_accepts_unknown_on_success ... ok
+test tests::modularized::auth_session::parses_api_key_login ... ok
+test tests::modularized::auth_session::parses_chatgpt_login ... ok
+test mcp::tests_core::config_runtime::runtime_stdio_server_resolves_env_and_tools ... ok
+test mcp::tests_core::config_runtime::runtime_stdio_launcher_merges_env_timeout_and_tools ... ok
+test mcp::tests_runtime_app::runtime_api::runtime_api_prepare_http_is_non_destructive ... ok
+test mcp::tests_core::config_runtime::runtime_http_resolves_bearer_and_sets_header ... ok
+test tests::modularized::builder_env_home::builder_collects_images ... ok
+test tests::modularized::builder_env_home::builder_can_disable_stdout_mirroring ... ok
+test tests::modularized::builder_env_home::builder_defaults_are_sane ... ok
+test mcp::tests_core::config_runtime::add_stdio_server_injects_env_and_persists ... ok
+test tests::modularized::builder_env_home::builder_mirrors_stdout_by_default ... ok
+test tests::modularized::builder_env_home::builder_sets_json_event_log ... ok
+test tests::modularized::builder_env_home::builder_sets_quiet_flag ... ok
+test tests::modularized::builder_env_home::builder_sets_json_flag ... ok
+test tests::modularized::builder_env_home::codex_home_layout_exposes_paths ... ok
+test tests::modularized::builder_env_home::codex_client_returns_configured_home_layout ... ok
+test tests::modularized::builder_env_home::codex_home_layout_respects_materialization_flag ... ok
+test tests::modularized::auth_session::ensure_chatgpt_login_launches_when_needed ... ok
+test tests::modularized::auth_session::auth_helper_uses_app_scoped_home_without_mutating_env ... ok
+test tests::modularized::auth_session::ensure_api_key_login_runs_when_logged_out ... ok
+test tests::modularized::builder_env_home::apply_respects_rust_log_default ... ok
+test tests::modularized::builder_env_home::builder_uses_env_binary_when_set ... ok
+test mcp::tests_runtime_app::app_runtime_api::app_runtime_api_lists_and_merges_without_writes ... ok
+test mcp::tests_runtime_app::runtime_api::runtime_api_lists_launchers_without_changing_config ... ok
+test mcp::tests_core::config_runtime::remove_server_prunes_config ... ok
+test tests::modularized::builder_env_home::command_env_applies_home_and_binary_per_command ... ok
+test tests::modularized::builder_env_home::seed_auth_errors_when_required_missing ... ok
+test tests::modularized::builder_env_home::seed_auth_copies_files_and_creates_targets ... ok
+test tests::modularized::bundled_binary::resolve_bundled_binary_defaults_to_runtime_platform ... ok
+test tests::modularized::builder_env_home::command_env_can_skip_home_creation ... ok
+test tests::modularized::builder_env_home::seed_auth_skips_optional_files ... ok
+test tests::modularized::bundled_binary::resolve_bundled_binary_errors_when_binary_missing ... ok
+test tests::modularized::bundled_binary::resolve_bundled_binary_rejects_empty_version ... ok
+test tests::modularized::builder_env_home::command_env_respects_existing_rust_log ... ok
+test tests::modularized::capabilities::feature_parsing_and_guards::capability_guard_marks_absent_feature_as_unsupported ... ok
+test tests::modularized::bundled_binary::resolve_bundled_binary_honors_platform_override ... ok
+test tests::modularized::capabilities::feature_parsing_and_guards::capability_guard_reports_detected_support ... ok
+test tests::modularized::capabilities::feature_parsing_and_guards::capability_guard_returns_unknown_without_feature_list ... ok
+test tests::modularized::capabilities::feature_parsing_and_guards::parses_feature_list_json_and_text_tables ... ok
+test tests::modularized::capabilities::feature_parsing_and_guards::parses_features_from_json_and_text ... ok
+test tests::modularized::capabilities::feature_parsing_and_guards::parses_help_output_flags ... ok
+test tests::modularized::builder_env_home::command_env_sets_expected_overrides ... ok
+test tests::modularized::builder_env_home::default_binary_falls_back_when_env_missing ... ok
+test tests::modularized::builder_env_home::default_rust_log_is_error_when_unset ... ok
+test tests::modularized::builder_env_home::default_rust_log_respects_existing_env ... ok
+test tests::modularized::builder_env_home::apply_and_diff_capture_outputs_and_status ... ok
+test tests::modularized::capabilities::exec_and_login::exec_applies_guarded_flags_when_supported ... ok
+test tests::modularized::capabilities::snapshots_and_cache::capability_snapshot_match_checks_fingerprint ... ok
+test tests::modularized::capabilities::snapshots_and_cache::capability_snapshots_and_overrides_round_trip_via_files ... ok
+test tests::modularized::capabilities::snapshots_and_cache::capability_snapshots_serialize_to_json_and_toml ... ok
+test tests::modularized::capabilities::snapshots_and_cache::capability_ttl_decision_bypasses_when_metadata_missing ... ok
+test tests::modularized::capabilities::snapshots_and_cache::capability_ttl_decision_refreshes_after_ttl_with_fingerprint ... ok
+test tests::modularized::capabilities::snapshots_and_cache::capability_ttl_decision_reuses_fresh_snapshot ... ok
+test tests::modularized::capabilities::version_and_advisory::parses_version_output_fields ... ok
+test tests::modularized::capabilities::version_and_advisory::update_advisory_detects_newer_release ... ok
+test tests::modularized::capabilities::version_and_advisory::update_advisory_falls_back_when_channel_missing ... ok
+test tests::modularized::capabilities::version_and_advisory::update_advisory_handles_local_newer_than_known ... ok
+test tests::modularized::capabilities::version_and_advisory::update_advisory_handles_missing_latest_metadata ... ok
+test tests::modularized::capabilities::version_and_advisory::update_advisory_handles_unknown_local_version ... ok
+test tests::modularized::capabilities::version_and_advisory::update_advisory_marks_up_to_date ... ok
+test tests::modularized::cli_commands::app_server_codegen_maps_overrides_and_prettier ... ok
+test tests::modularized::capabilities::exec_and_login::exec_skips_guarded_flags_when_unknown ... ok
+test mcp::tests_core::app_server_rpc_flows::canceling_app_request_returns_cancelled_error ... ok
+test tests::modularized::cli_commands::cloud_exec_maps_args_and_rejects_empty_env_id ... ok
+test tests::modularized::cli_commands::app_server_codegen_surfaces_non_zero_exit ... ok
+test tests::modularized::capabilities::exec_and_login::mcp_login_runs_when_supported ... ok
+test tests::modularized::cli_commands::cloud_list_parses_json_and_maps_args ... ok
+test tests::modularized::cli_commands::features_list_maps_overrides_and_json_flag ... ok
+test tests::modularized::cli_commands::responses_api_proxy_rejects_empty_api_key ... ok
+test tests::modularized::cli_commands::responses_api_proxy_maps_flags_and_parses_server_info ... ok
+test tests::modularized::cli_commands::mcp_add_maps_transports_and_validates_required_fields ... ok
+test tests::modularized::cli_commands::stdio_to_uds_rejects_empty_socket_path ... ok
+test tests::modularized::cli_commands::stdio_to_uds_maps_args_and_pipes_stdio ... ok
+test tests::modularized::capabilities::exec_and_login::probe_capabilities_caches_and_invalidates ... ok
+test tests::modularized::cli_overrides::cli_override_args_apply_safety_precedence ... ok
+test tests::modularized::cli_overrides::color_mode_strings_are_stable ... ok
+test tests::modularized::cli_overrides::explicit_reasoning_overrides_disable_defaults ... ok
+test tests::modularized::cli_overrides::feature_toggles_merge_builder_and_request ... ok
+test tests::modularized::cli_overrides::reasoning_config_by_model ... ok
+test tests::modularized::cli_overrides::request_can_disable_auto_reasoning_defaults ... ok
+test tests::modularized::cli_overrides::request_config_overrides_follow_builder_order ... ok
+test tests::modularized::cli_commands::mcp_list_get_and_add_map_args_and_parse_json ... ok
+test tests::modularized::cli_overrides::request_oss_override_can_disable_builder_flag ... ok
+test tests::modularized::cli_overrides::request_profile_override_replaces_builder_value ... ok
+test tests::modularized::cli_overrides::request_search_override_can_disable_builder_flag ... ok
+test tests::modularized::cli_overrides::resolve_cli_overrides_respects_reasoning_defaults ... ok
+test tests::modularized::capabilities::exec_and_login::mcp_login_skips_when_unsupported ... ok
+test tests::modularized::jsonl_stream::event_channel_stream_times_out_when_idle ... ok
+test tests::modularized::jsonl_stream::json_event_log_captures_apply_diff_and_tool_payloads ... ok
+test tests::modularized::jsonl_stream::json_stream_preserves_order_and_parses_tool_calls ... ok
+test tests::modularized::jsonl_stream::json_stream_propagates_parse_errors ... ok
+test tests::modularized::jsonl_stream::normalize_stream_errors_without_context ... ok
+test tests::modularized::jsonl_stream::normalize_stream_infers_missing_thread_and_turn ... ok
+test tests::modularized::jsonl_stream::json_stream_tees_logs_before_forwarding ... ok
+test tests::modularized::sandbox_execpolicy::execpolicy_rejects_empty_command ... ok
+test tests::modularized::sandbox_execpolicy::execpolicy_maps_policies_and_overrides ... ok
+test tests::modularized::capabilities::overrides_and_probe::capability_feature_overrides_apply_to_cached_entries ... ok
+test tests::modularized::capabilities::overrides_and_probe::capability_snapshot_short_circuits_probes ... ok
+test mcp::tests_runtime_app::runtime_manager::runtime_manager_starts_and_stops_stdio ... ok
+test tests::modularized::sandbox_execpolicy::sandbox_rejects_empty_command ... ok
+test tests::modularized::sandbox_execpolicy::execpolicy_surfaces_parse_errors ... ok
+test tests::modularized::cli_commands::supports_help_review_fork_resume_and_features_commands ... ok
+test mcp::tests_core::app_server_launch::app_server_launch_can_enable_analytics_flag ... ok
+test tests::modularized::sandbox_execpolicy::sandbox_includes_log_denials_on_macos ... ok
+test tests::modularized::sandbox_execpolicy::sandbox_returns_non_zero_status_without_error ... ok
+test tests::modularized::sandbox_execpolicy::sandbox_maps_platform_flags_and_command ... ok
+test tests::modularized::capabilities::overrides_and_probe::capability_version_override_replaces_probe_version ... ok
+test tests::modularized::sandbox_execpolicy::sandbox_honors_working_dir_precedence ... ok
+test mcp::tests_runtime_app::app_runtime_api::app_runtime_lifecycle_starts_and_stops_without_mutation ... ok
+test mcp::tests_core::codex_rpc_flows::canceling_request_returns_cancelled_error ... ok
+test tests::modularized::capabilities::probe_cache_policy::probe_bypass_policy_skips_cache_writes ... ok
+test tests::modularized::capabilities::probe_cache_policy::probe_refresh_policy_forces_new_snapshot ... ok
+test tests::modularized::capabilities::probe_cache_policy::probe_reprobes_when_metadata_missing ... ok
+test tests::modularized::capabilities::snapshots_and_cache::capability_cache_entries_exposes_cache_state ... ok
+test tests::modularized::cli_overrides::apply_respects_cli_overrides_without_search ... ok
+test tests::modularized::cli_overrides::exec_applies_cli_overrides_and_request_patch ... ok
+test tests::modularized::cli_overrides::resume_applies_search_and_selector_overrides ... ok
+test mcp::tests_core::app_server_rpc_flows::turn_interrupt_sends_cancel_notification ... ok
+test mcp::tests_core::app_server_rpc_flows::thread_resume_allows_follow_up_turns ... ok
+test mcp::tests_runtime_app::app_runtime_pool_api::app_runtime_pool_api_reuses_and_restarts_stdio ... ok
+test mcp::tests_core::codex_rpc_flows::codex_flow_streams_events_and_response ... ok
+test mcp::tests_core::app_server_rpc_flows::app_flow_streams_notifications_and_response ... ok
+test mcp::tests_runtime_app::app_runtime_pool_api::app_runtime_pool_api_stop_all_shuts_down_runtimes ... ok
+test mcp::tests_core::codex_rpc_flows::codex_reply_streams_follow_up_notifications ... ok
+
+test result: ok. 131 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.32s
+
+     Running tests/binary_env_integration.rs (target/debug/deps/binary_env_integration-d9c45d6743c28b6c)
+
+running 1 test
+test applies_env_overrides_across_spawn_sites ... ok
+
+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.22s
+
+     Running tests/cli_e2e.rs (target/debug/deps/cli_e2e-8f53920a852f8001)
+
+running 8 tests
+test exec_resume_diff_apply_live_roundtrip ... ok
+test execpolicy_check_is_missing_in_current_cli ... ok
+test features_list_prefers_text_when_json_flag_is_missing ... ok
+test stdio_to_uds_relays_bytes ... ok
+test diff_and_apply_report_current_cli_gaps ... ok
+test sandbox_runs_echo_command ... ok
+test app_server_codegen_generates_schema_bundle ... ok
+test responses_api_proxy_emits_server_info_and_shuts_down ... ok
+
+test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 4.43s
+
+     Running tests/examples_manifest.rs (target/debug/deps/examples_manifest-866ea9c42ad2b67d)
+
+running 1 test
+test examples_manifest_covers_all_explicit_wrapper_commands ... ok
+
+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running tests/fixtures.rs (target/debug/deps/fixtures-f36a99f41b864dcc)
+
+running 3 tests
+test apply_fixture_parses_and_carries_exit_code ... ok
+test resume_fixture_includes_thread_and_turn_ids ... ok
+test streaming_fixture_covers_event_shapes ... ok
+
+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running tests/jsonl_compat.rs (target/debug/deps/jsonl_compat-cd54909432563adc)
+
+running 5 tests
+test known_good_fixtures_include_text_payloads ... ok
+test retains_unknown_fields_in_extra_maps ... ok
+test parses_versioned_exec_fixtures ... ok
+test malformed_lines_are_non_fatal ... ok
+test parses_versioned_resume_fixtures ... ok
+
+test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
+
+     Running tests/jsonl_parser_api.rs (target/debug/deps/jsonl_parser_api-7a768cc835b5775a)
+
+running 6 tests
+test scenario_e_crlf_tolerance_trailing_carriage_return ... ok
+test scenario_a_parses_streaming_fixtures_without_errors ... ok
+test scenario_b_parses_resume_fixtures_without_errors ... ok
+test scenario_f_unknown_type_yields_error_and_continues ... ok
+test scenario_c_malformed_lines_yield_errors_and_continue ... ok
+test scenario_d_offline_matches_streaming_normalization ... ok
+
+test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
+
+     Running unittests examples/app_server_codegen.rs (target/debug/examples/app_server_codegen-673e91546bd0d5b5)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/app_server_thread_turn.rs (target/debug/examples/app_server_thread_turn-22999b626d4a0363)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/app_server_turns.rs (target/debug/examples/app_server_turns-95c16a0b4ec1782b)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/auth_flow.rs (target/debug/examples/auth_flow-8c333a1934245305)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/bundled_binary.rs (target/debug/examples/bundled_binary-137bfbae0f1f5cb6)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/bundled_binary_home.rs (target/debug/examples/bundled_binary_home-cdd76e32cefd7fd6)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/capability_snapshot.rs (target/debug/examples/capability_snapshot-6b4e768302f265b6)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/cli_overrides.rs (target/debug/examples/cli_overrides-bea14c444980501f)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/cloud_tasks.rs (target/debug/examples/cloud_tasks-10d7154cc0bc8521)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/codex_home.rs (target/debug/examples/codex_home-05babfa7275e0d46)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/color_always.rs (target/debug/examples/color_always-09ad9507a3a155d0)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/env_binary.rs (target/debug/examples/env_binary-1cf43e3beb4e88e6)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/exec_resume_apply_wrapper.rs (target/debug/examples/exec_resume_apply_wrapper-994fa6cfeb71736c)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/execpolicy_check.rs (target/debug/examples/execpolicy_check-6f8490635da7c31b)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/feature_detection.rs (target/debug/examples/feature_detection-10c0dcabc8f539c0)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/features_cmd.rs (target/debug/examples/features_cmd-1d0dce047b1c55ef)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/help_scopes.rs (target/debug/examples/help_scopes-33696051f4d1b55d)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/image_json.rs (target/debug/examples/image_json-3ac03e1075385177)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/json_stream.rs (target/debug/examples/json_stream-27785efe594ffe9c)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/mcp_codex_flow.rs (target/debug/examples/mcp_codex_flow-7721ad926129216c)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/mcp_codex_reply.rs (target/debug/examples/mcp_codex_reply-309e588bfbddb688)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/mcp_codex_tool.rs (target/debug/examples/mcp_codex_tool-d63fc51ad8d3a95f)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/mcp_manage.rs (target/debug/examples/mcp_manage-1ff1a16e191ad17e)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/no_stdout_mirror.rs (target/debug/examples/no_stdout_mirror-773a3099f201bd78)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/quiet.rs (target/debug/examples/quiet-e5f34aef6df3ec0a)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/responses_api_proxy.rs (target/debug/examples/responses_api_proxy-1f9e02f8eabafef2)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/resume_apply.rs (target/debug/examples/resume_apply-578ea1e74d1dd69e)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/review_commands.rs (target/debug/examples/review_commands-ff7e3558c92b6df7)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/run_sandbox.rs (target/debug/examples/run_sandbox-646ff0e1d6a0cd6e)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/select_model.rs (target/debug/examples/select_model-1d66e12957425b44)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/send_prompt.rs (target/debug/examples/send_prompt-36b286e60710e572)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/session_commands.rs (target/debug/examples/session_commands-eb16903d856002a0)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/stdio_to_uds_live.rs (target/debug/examples/stdio_to_uds_live-f98f1eb38ca94805)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/stream_events.rs (target/debug/examples/stream_events-8797ea39ec97d8b6)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/stream_last_message.rs (target/debug/examples/stream_last_message-7c1b196b207242bf)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/stream_with_log.rs (target/debug/examples/stream_with_log-2e4b02439a4700f0)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/timeout.rs (target/debug/examples/timeout-3400066ed703ecea)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/timeout_zero.rs (target/debug/examples/timeout_zero-ec05f79d2982d0d3)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/working_dir.rs (target/debug/examples/working_dir-a0d590aa652f3516)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests examples/working_dir_json.rs (target/debug/examples/working_dir_json-5332d76f2fc06c7b)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running unittests src/main.rs (target/debug/deps/xtask-add83d1f8ab534b7)
+
+running 0 tests
+
+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running tests/c0_spec_snapshot.rs (target/debug/deps/c0_spec_snapshot-d124a5c78eb92861)
+
+running 4 tests
+test unix::c0_snapshot_applies_supplement_and_sorts_commands_and_flags ... ok
+test unix::c0_snapshot_infers_usage_args_and_parses_flags_across_blank_lines ... ok
+test unix::c0_snapshot_records_feature_probe_and_feature_gated_commands ... ok
+test unix::c0_snapshot_is_deterministic_except_for_collected_at ... ok
+
+test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.14s
+
+     Running tests/c0_spec_validate.rs (target/debug/deps/c0_spec_validate-425740bd5559e6ae)
+
+running 5 tests
+test c0_validate_passes_on_minimal_valid_codex_dir ... ok
+test c0_validate_rejects_pointer_files_without_trailing_newline ... ok
+test c0_validate_requires_reports_when_version_status_reported ... ok
+test c0_validate_reports_wrapper_overlap_errors_with_required_fields_and_is_deterministic ... ok
+test c0_validate_requires_coverage_all_only_when_union_complete ... ok
+
+test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s
+
+     Running tests/c1_spec_snapshot_per_target.rs (target/debug/deps/c1_spec_snapshot_per_target-c9e2a9551349ed45)
+
+running 2 tests
+test unix::c1_snapshot_rejects_out_dir_when_out_file_is_set ... ok
+test unix::c1_snapshot_writes_per_target_out_file_and_raw_help_under_codex_root ... ok
+
+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.07s
+
+     Running tests/c1_spec_union.rs (target/debug/deps/c1_spec_union-dfda266e61ac2669)
+
+running 4 tests
+test c1_union_fails_when_required_target_missing ... ok
+test c1_union_dedupes_per_command_flags_against_root ... ok
+test c1_union_emits_complete_false_and_missing_targets_for_non_required_missing ... ok
+test c1_union_records_conflicts_and_is_deterministic_with_source_date_epoch ... ok
+
+test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
+
+     Running tests/c2_spec_wrapper_coverage.rs (target/debug/deps/c2_spec_wrapper_coverage-08ef4f403c0c8a75)
+
+running 4 tests
+test c2_wrapper_coverage_generation_is_deterministic_and_includes_wrapper_version ... ok
+test c2_validate_rejects_intentionally_unsupported_without_note ... ok
+test c2_validate_rejects_overlapping_wrapper_scopes_no_scope_means_all_expected_targets ... ok
+test c2_validate_rejects_overlapping_wrapper_scopes_platforms_expand_via_union_platform_mapping ... ok
+
+test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
+
+     Running tests/c3_spec_reports_metadata_retain.rs (target/debug/deps/c3_spec_reports_metadata_retain-daeed37517852a7c)
+
+running 4 tests
+test c3_report_skips_coverage_all_when_union_incomplete ... ok
+test c3_retain_deletes_only_snapshots_and_reports_outside_keep_set ... ok
+test c3_version_metadata_reported_requires_union_and_any_report ... ok
+test c3_report_filter_semantics_complete_union_empty_wrapper ... ok
+
+test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
+
+     Running tests/c4_spec_ci_wiring.rs (target/debug/deps/c4_spec_ci_wiring-917c6273daae94cd)
+
+running 2 tests
+test c4_spec_update_snapshot_workflow_runs_full_pipeline_and_uploads_artifacts ... ok
+test c4_spec_ci_workflow_has_conditional_codex_validate_gate ... ok
+
+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
+
+     Running tests/c5_spec_iu_subtree_inheritance.rs (target/debug/deps/c5_spec_iu_subtree_inheritance-2b06c8c2813a423c)
+
+running 1 test
+test c5_iu_subtree_inheritance_classifies_descendants_and_sorts_deterministically ... ok
+
+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
+
+     Running tests/c6_spec_report_iu_validator.rs (target/debug/deps/c6_spec_report_iu_validator-43cdc0ec5252f992)
+
+running 1 test
+test c6_validator_emits_report_missing_includes_intentionally_unsupported ... ok
+
+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s
+
+     Running tests/c7_spec_iu_roots_adoption.rs (target/debug/deps/c7_spec_iu_roots_adoption-64fe6e4eadff4547)
+
+running 1 test
+test c7_iu_roots_are_generated_and_reports_waive_descendants ... ok
+
+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s
+
