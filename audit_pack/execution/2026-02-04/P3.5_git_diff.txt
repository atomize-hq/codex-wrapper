diff --git a/crates/xtask/src/codex_validate.rs b/crates/xtask/src/codex_validate.rs
index 07dee44..c02ed0a 100644
--- a/crates/xtask/src/codex_validate.rs
+++ b/crates/xtask/src/codex_validate.rs
@@ -8,10 +8,16 @@ use clap::{Parser, ValueEnum};
 use jsonschema::{Draft, JSONSchema};
 use regex::Regex;
 use semver::Version;
-use serde::Deserialize;
 use serde_json::{json, Value};
 use thiserror::Error;
 
+mod models;
+use models::{
+    IuSortKey, ParityExclusionUnit, ParityExclusionsIndex, PointerRead, PointerValue,
+    PointerValues, Rules, RulesWrapperCoverage, ScopedEntry, Violation, WrapperCoverageFile,
+    WrapperScope,
+};
+
 #[derive(Debug, Parser)]
 pub struct Args {
     /// Root directory containing `SCHEMA.json`, `RULES.json`, pointer files, snapshots, reports,
@@ -85,175 +91,6 @@ fn absolutize_schema_id(schema: &mut Value, schema_path: &Path) -> Result<(), Fa
     Ok(())
 }
 
-#[derive(Debug, Clone)]
-struct Violation {
-    code: &'static str,
-    path: String,
-    json_pointer: Option<String>,
-    message: String,
-
-    unit: Option<&'static str>,
-    command_path: Option<String>,
-    key_or_name: Option<String>,
-    field: Option<&'static str>,
-    target_triple: Option<String>,
-
-    details: Option<Value>,
-}
-
-impl Violation {
-    fn sort_key(&self) -> (&str, &str, &str, &str, &str) {
-        (
-            self.path.as_str(),
-            self.unit.unwrap_or(""),
-            self.command_path.as_deref().unwrap_or(""),
-            self.key_or_name.as_deref().unwrap_or(""),
-            self.field.unwrap_or(""),
-        )
-    }
-
-    fn to_human_line(&self) -> String {
-        // Keep this stable and single-line for CI logs.
-        let mut parts = vec![self.code, "error", self.path.as_str()];
-        if let Some(ptr) = self.json_pointer.as_deref() {
-            if !ptr.is_empty() {
-                parts.push(ptr);
-            }
-        }
-        parts.push(self.message.as_str());
-        parts.join(" ")
-    }
-
-    fn to_json(&self) -> Value {
-        let mut out = json!({
-            "code": self.code,
-            "severity": "error",
-            "path": self.path,
-            "message": self.message,
-        });
-        if let Some(ptr) = self.json_pointer.clone() {
-            out["json_pointer"] = Value::String(ptr);
-        }
-        if let Some(details) = self.details.clone() {
-            out["details"] = details;
-        }
-        out
-    }
-}
-
-#[derive(Debug, Deserialize)]
-struct Rules {
-    union: RulesUnion,
-    versioning: RulesVersioning,
-    wrapper_coverage: RulesWrapperCoverage,
-    #[serde(default)]
-    parity_exclusions: Option<RulesParityExclusions>,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesUnion {
-    required_target: String,
-    expected_targets: Vec<String>,
-    platform_mapping: BTreeMap<String, String>,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesVersioning {
-    pointers: RulesPointers,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesPointers {
-    stable_semver_pattern: String,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesWrapperCoverage {
-    scope_semantics: RulesWrapperScopeSemantics,
-    validation: RulesWrapperValidation,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesParityExclusions {
-    schema_version: u32,
-    units: Vec<ParityExclusionUnit>,
-}
-
-#[derive(Debug, Deserialize, Clone)]
-struct ParityExclusionUnit {
-    unit: String,
-    path: Vec<String>,
-    #[serde(default)]
-    key: Option<String>,
-    #[serde(default)]
-    name: Option<String>,
-    #[serde(default)]
-    category: Option<String>,
-    note: String,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesWrapperScopeSemantics {
-    defaults: RulesWrapperScopeDefaults,
-    platforms_expand_to_expected_targets: bool,
-    platforms_expand_using: String,
-    scope_set_resolution: RulesWrapperScopeSetResolution,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesWrapperScopeDefaults {
-    no_scope_means: String,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesWrapperScopeSetResolution {
-    mode: String,
-}
-
-#[derive(Debug, Deserialize)]
-struct RulesWrapperValidation {
-    disallow_overlapping_scopes: bool,
-    overlap_units: Vec<String>,
-}
-
-#[derive(Debug, Deserialize)]
-struct WrapperCoverageFile {
-    schema_version: u32,
-    coverage: Vec<WrapperCommandCoverage>,
-}
-
-#[derive(Debug, Deserialize)]
-struct WrapperCommandCoverage {
-    path: Vec<String>,
-    level: String,
-    note: Option<String>,
-    scope: Option<WrapperScope>,
-    flags: Option<Vec<WrapperFlagCoverage>>,
-    args: Option<Vec<WrapperArgCoverage>>,
-}
-
-#[derive(Debug, Deserialize, Clone)]
-struct WrapperScope {
-    platforms: Option<Vec<String>>,
-    target_triples: Option<Vec<String>>,
-}
-
-#[derive(Debug, Deserialize)]
-struct WrapperFlagCoverage {
-    key: String,
-    level: String,
-    note: Option<String>,
-    scope: Option<WrapperScope>,
-}
-
-#[derive(Debug, Deserialize)]
-struct WrapperArgCoverage {
-    name: String,
-    level: String,
-    note: Option<String>,
-    scope: Option<WrapperScope>,
-}
-
 #[derive(Debug)]
 struct ValidateCtx {
     root: PathBuf,
@@ -505,28 +342,6 @@ fn normalize_single_line_file(path: &Path) -> Result<(), FatalError> {
     Ok(())
 }
 
-#[derive(Debug, Clone)]
-enum PointerValue {
-    None,
-    Version(Version),
-}
-
-#[derive(Debug)]
-enum PointerRead {
-    Missing,
-    InvalidFormat { reason: &'static str },
-    InvalidValue { raw: String },
-    Value(PointerValue),
-}
-
-#[derive(Debug, Default)]
-struct PointerValues {
-    min_supported: Option<String>,
-    latest_validated: Option<String>,
-    by_target_latest_supported: BTreeMap<String, Option<String>>,
-    by_target_latest_validated: BTreeMap<String, Option<String>>,
-}
-
 fn validate_pointers(ctx: &mut ValidateCtx, violations: &mut Vec<Violation>) -> PointerValues {
     let mut out = PointerValues::default();
 
@@ -1480,13 +1295,6 @@ fn validate_wrapper_iu_notes(
     }
 }
 
-#[derive(Debug, Clone)]
-struct ScopedEntry {
-    index: String,
-    scope_kind: &'static str,
-    targets: BTreeSet<String>,
-}
-
 fn validate_wrapper_scope_overlaps(
     ctx: &ValidateCtx,
     violations: &mut Vec<Violation>,
@@ -2086,17 +1894,7 @@ fn read_pointer_file(
 }
 
 fn parse_stable_version(s: &str, stable_semver_re: &Regex) -> Option<Version> {
-    if !stable_semver_re.is_match(s) {
-        return None;
-    }
-    Version::parse(s).ok()
-}
-
-#[derive(Debug)]
-struct ParityExclusionsIndex {
-    commands: BTreeMap<Vec<String>, ParityExclusionUnit>,
-    flags: BTreeMap<(Vec<String>, String), ParityExclusionUnit>,
-    args: BTreeMap<(Vec<String>, String), ParityExclusionUnit>,
+    models::parse_stable_version(s, stable_semver_re)
 }
 
 fn build_parity_exclusions_index(units: &[ParityExclusionUnit]) -> ParityExclusionsIndex {
@@ -2447,13 +2245,6 @@ fn validate_report_exclusions(
     }
 }
 
-#[derive(Debug, Clone, PartialEq, Eq)]
-struct IuSortKey {
-    kind_rank: u8,
-    path: Vec<String>,
-    key_or_name: String,
-}
-
 fn cmp_path_tokens(a: &[String], b: &[String]) -> std::cmp::Ordering {
     let mut i = 0usize;
     while i < a.len() && i < b.len() {
