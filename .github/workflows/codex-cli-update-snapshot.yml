name: Codex CLI update snapshot

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Bare semver (example: 0.77.0)"
        required: true
        type: string
      update_min_supported:
        description: "DEPRECATED: min_supported.txt is a maintainer-only policy change (this workflow will fail if true)"
        required: true
        default: false
        type: boolean

permissions:
  contents: read

jobs:
  # IMPORTANT: This workflow always checks out and builds from the `staging` branch so that
  # automation branches are derived from the same base they target via create-pull-request.
  # This avoids accidentally including unrelated commits when the workflow is dispatched from `main`.
  #
  # The workflow definition itself can still be dispatched from any ref, but the git worktree used
  # for artifact generation and PR creation is pinned to `staging`.
  prepare:
    name: Prepare pins (artifacts.lock.json)
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.upstream.outputs.tag }}
      source_date_epoch: ${{ steps.upstream.outputs.source_date_epoch }}
      snapshot_matrix: ${{ steps.matrix.outputs.snapshot_matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: staging

      - name: Reject automated min_supported updates (policy)
        if: ${{ inputs.update_min_supported }}
        shell: bash
        run: |
          set -euo pipefail
          echo "update_min_supported=true is not supported in this workflow." >&2
          echo "min_supported.txt is a maintainer-only policy change; update it in a separate PR." >&2
          exit 1

      - name: Fetch + validate upstream release
        id: upstream
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          TAG="rust-v${VERSION}"

          curl -fsSL "https://api.github.com/repos/openai/codex/releases/tags/${TAG}" > release.json
          test "$(jq -r '.draft' release.json)" = "false"
          test "$(jq -r '.prerelease' release.json)" = "false"
          PUBLISHED_AT="$(jq -r '.published_at' release.json)"
          test -n "$PUBLISHED_AT" && test "$PUBLISHED_AT" != "null"
          SOURCE_DATE_EPOCH="$(date -d "$PUBLISHED_AT" +%s)"

          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "source_date_epoch=${SOURCE_DATE_EPOCH}" >> "$GITHUB_OUTPUT"

      - name: Compute snapshot matrix from RULES.json (union.expected_targets)
        id: matrix
        shell: bash
        run: |
          set -euo pipefail

          RULES="cli_manifests/codex/RULES.json"

          entries=()
          while IFS= read -r target; do
            case "$target" in
              x86_64-unknown-linux-musl)
                entries+=("{\"target_triple\":\"$target\",\"runs_on\":\"ubuntu-latest\",\"asset_name\":\"codex-$target.tar.gz\",\"binary_path\":\"./codex-$target\",\"extract\":true}")
                ;;
              aarch64-apple-darwin)
                entries+=("{\"target_triple\":\"$target\",\"runs_on\":\"macos-latest\",\"asset_name\":\"codex-$target.tar.gz\",\"binary_path\":\"./codex-$target\",\"extract\":true}")
                ;;
              x86_64-pc-windows-msvc)
                entries+=("{\"target_triple\":\"$target\",\"runs_on\":\"windows-latest\",\"asset_name\":\"codex-$target.exe\",\"binary_path\":\"./codex-$target.exe\",\"extract\":false}")
                ;;
              *)
                echo "Unsupported target_triple in ${RULES} union.expected_targets: ${target}" >&2
                exit 1
                ;;
            esac
          done < <(jq -r '.union.expected_targets[]' "$RULES")

          printf '%s\n' "${entries[@]}" | jq -c -s '{include: .}' > snapshot_matrix.json
          echo "snapshot_matrix=$(cat snapshot_matrix.json)" >> "$GITHUB_OUTPUT"

      - name: Download artifacts + update lockfile
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
          TAG: ${{ steps.upstream.outputs.tag }}
        run: |
          set -euo pipefail

          jq '.include | map({target_triple, asset_name})' snapshot_matrix.json > targets.json

          mkdir -p _download
          jq -c '.[]' targets.json | while read -r row; do
            TARGET="$(jq -r '.target_triple' <<<"$row")"
            ASSET="$(jq -r '.asset_name' <<<"$row")"
            URL="https://github.com/openai/codex/releases/download/${TAG}/${ASSET}"

            OUT="_download/${ASSET}"
            curl -fsSL -o "$OUT" "$URL"
            SIZE_BYTES="$(wc -c < "$OUT" | tr -d ' ')"
            SHA256="$(sha256sum "$OUT" | awk '{print $1}')"

            jq -n \
              --arg v "$VERSION" \
              --arg t "$TARGET" \
              --arg asset "$ASSET" \
              --arg url "$URL" \
              --arg sha "$SHA256" \
              --argjson size "$SIZE_BYTES" \
              '{codex_version:$v, target_triple:$t, asset_name:$asset, download_url:$url, sha256:$sha, size_bytes:$size}' \
              > "_download/${TARGET}.artifact.json"
          done

          jq -s '.' _download/*.artifact.json > artifact.json

          jq \
            --arg v "$VERSION" \
            --slurpfile new artifact.json \
            '
              .version = 1
              | .upstream_repo = "openai/codex"
              | .artifacts = (
                  ( .artifacts // [] )
                  | map(select(.codex_version != $v))
                  + $new[0]
                  | unique_by([.codex_version, .target_triple])
                  | sort_by([(.codex_version|split(".")|map(tonumber)), .target_triple])
                )
            ' \
            cli_manifests/codex/artifacts.lock.json > artifacts.lock.json.tmp
          mv artifacts.lock.json.tmp cli_manifests/codex/artifacts.lock.json

      - name: Upload pins + downloads
        uses: actions/upload-artifact@v4
        with:
          name: "codex-cli-pins-${{ inputs.version }}"
          if-no-files-found: error
          path: |
            cli_manifests/codex/artifacts.lock.json
            _download/

  snapshot:
    name: "Snapshot (${{ matrix.target_triple }})"
    needs: prepare
    runs-on: ${{ matrix.runs_on }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare.outputs.snapshot_matrix) }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: staging
      - uses: dtolnay/rust-toolchain@stable

      - name: Download pins + downloads
        uses: actions/download-artifact@v4
        with:
          name: "codex-cli-pins-${{ inputs.version }}"
          path: .

      - name: Acquire pinned Codex CLI
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
          TARGET: ${{ matrix.target_triple }}
          ASSET: ${{ matrix.asset_name }}
          BIN: ${{ matrix.binary_path }}
          EXTRACT: ${{ matrix.extract }}
        run: |
          set -euo pipefail

          URL="$(jq -r --arg v "$VERSION" --arg t "$TARGET" --arg a "$ASSET" '.artifacts[] | select(.codex_version==$v and .target_triple==$t and .asset_name==$a) | .download_url' cli_manifests/codex/artifacts.lock.json)"
          SHA="$(jq -r --arg v "$VERSION" --arg t "$TARGET" --arg a "$ASSET" '.artifacts[] | select(.codex_version==$v and .target_triple==$t and .asset_name==$a) | .sha256' cli_manifests/codex/artifacts.lock.json)"
          SIZE="$(jq -r --arg v "$VERSION" --arg t "$TARGET" --arg a "$ASSET" '.artifacts[] | select(.codex_version==$v and .target_triple==$t and .asset_name==$a) | .size_bytes' cli_manifests/codex/artifacts.lock.json)"
          test -n "$URL" && test "$URL" != "null"
          test -n "$SHA" && test "$SHA" != "null"
          test -n "$SIZE" && test "$SIZE" != "null"

          FILE="_download/${ASSET}"
          test -f "$FILE"

          python -c 'import hashlib, sys; p=sys.argv[1]; exp_sha=sys.argv[2]; exp_size=int(sys.argv[3]); b=open(p,"rb").read(); got_sha=hashlib.sha256(b).hexdigest(); got_size=len(b); assert got_sha==exp_sha, f"sha256 mismatch: expected={exp_sha} got={got_sha}"; assert got_size==exp_size, f"size mismatch: expected={exp_size} got={got_size}"; print(f"ok: {p} sha256={got_sha} size_bytes={got_size}")' "$FILE" "$SHA" "$SIZE"

          if [ "$EXTRACT" = "true" ]; then
            MEMBER="$(tar -tzf "$FILE" | awk 'NF && substr($0,length($0),1) != "/" {print; exit}')"
            test -n "$MEMBER"
            rm -rf _extract
            mkdir -p _extract
            tar -xzf "$FILE" -C _extract "$MEMBER"
            install -m 0755 "_extract/$MEMBER" "$BIN"
          else
            cp "$FILE" "$BIN"
          fi

          "$BIN" --version

      - name: Generate per-target snapshot (+ raw help)
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
          TARGET: ${{ matrix.target_triple }}
          BIN: ${{ matrix.binary_path }}
          SOURCE_DATE_EPOCH: ${{ needs.prepare.outputs.source_date_epoch }}
        run: |
          set -euo pipefail
          OUT="cli_manifests/codex/snapshots/${VERSION}/${TARGET}.json"
          cargo run -p xtask -- \
            codex-snapshot \
            --codex-binary "$BIN" \
            --out-file "$OUT" \
            --capture-raw-help \
            --raw-help-target "$TARGET" \
            --supplement cli_manifests/codex/supplement/commands.json

      - name: Upload snapshot JSON
        uses: actions/upload-artifact@v4
        with:
          name: "codex-cli-snapshot-${{ inputs.version }}-${{ matrix.target_triple }}"
          if-no-files-found: error
          path: |
            cli_manifests/codex/snapshots/${{ inputs.version }}/${{ matrix.target_triple }}.json

      - name: Upload raw help capture (not committed)
        uses: actions/upload-artifact@v4
        with:
          name: "codex-cli-raw-help-${{ inputs.version }}-${{ matrix.target_triple }}"
          if-no-files-found: error
          path: |
            cli_manifests/codex/raw_help/${{ inputs.version }}/${{ matrix.target_triple }}/

  union-report-validate:
    name: Union → Report → Validate (Linux)
    runs-on: ubuntu-latest
    needs: [prepare, snapshot]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: staging
      - uses: dtolnay/rust-toolchain@stable

      - name: Download pins + downloads
        uses: actions/download-artifact@v4
        with:
          name: "codex-cli-pins-${{ inputs.version }}"
          path: .

      - name: Download required Linux snapshot
        uses: actions/download-artifact@v4
        with:
          name: "codex-cli-snapshot-${{ inputs.version }}-x86_64-unknown-linux-musl"
          path: .

      - name: Download macOS snapshot (best effort)
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: "codex-cli-snapshot-${{ inputs.version }}-aarch64-apple-darwin"
          path: .

      - name: Download Windows snapshot (best effort)
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: "codex-cli-snapshot-${{ inputs.version }}-x86_64-pc-windows-msvc"
          path: .

      - name: Ensure required snapshot exists
        id: ensure-linux-snapshot
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
          SOURCE_DATE_EPOCH: ${{ needs.prepare.outputs.source_date_epoch }}
        run: |
          set -euo pipefail

          ROOT="cli_manifests/codex"
          TARGET="x86_64-unknown-linux-musl"
          OUT="${ROOT}/snapshots/${VERSION}/${TARGET}.json"

          if [ -f "$OUT" ]; then
            echo "generated=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # If the artifact was extracted under an unexpected directory layout, relocate it.
          FOUND="$(find . -type f -path "*/${ROOT}/snapshots/${VERSION}/${TARGET}.json" | head -n 1 || true)"
          if [ -n "$FOUND" ]; then
            mkdir -p "$(dirname "$OUT")"
            if [ "$(realpath "$FOUND")" != "$(realpath "$OUT")" ]; then
              cp "$FOUND" "$OUT"
            fi
            echo "generated=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Last-resort fallback: generate the required Linux snapshot from the pinned download.
          ASSET="codex-${TARGET}.tar.gz"
          FILE="_download/${ASSET}"
          test -f "$FILE"

          MEMBER="$(tar -tzf "$FILE" | awk 'NF && substr($0,length($0),1) != "/" {print; exit}')"
          test -n "$MEMBER"
          rm -rf _extract
          mkdir -p _extract
          tar -xzf "$FILE" -C _extract "$MEMBER"
          install -m 0755 "_extract/$MEMBER" "./codex-${TARGET}"

          cargo run -p xtask -- \
            codex-snapshot \
            --codex-binary "./codex-${TARGET}" \
            --out-file "$OUT" \
            --capture-raw-help \
            --raw-help-target "$TARGET" \
            --supplement "${ROOT}/supplement/commands.json"

          echo "generated=true" >> "$GITHUB_OUTPUT"

      - name: Merge union snapshot
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
          SOURCE_DATE_EPOCH: ${{ needs.prepare.outputs.source_date_epoch }}
        run: |
          set -euo pipefail
          cargo run -p xtask -- codex-union --version "$VERSION" --root cli_manifests/codex

      - name: Generate wrapper coverage
        shell: bash
        env:
          SOURCE_DATE_EPOCH: ${{ needs.prepare.outputs.source_date_epoch }}
        run: |
          set -euo pipefail
          cargo run -p xtask -- \
            codex-wrapper-coverage \
            --out cli_manifests/codex/wrapper_coverage.json

      - name: Generate coverage reports
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
          SOURCE_DATE_EPOCH: ${{ needs.prepare.outputs.source_date_epoch }}
        run: |
          set -euo pipefail
          cargo run -p xtask -- codex-report --version "$VERSION" --root cli_manifests/codex

      - name: Generate version metadata (status=reported)
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
          SOURCE_DATE_EPOCH: ${{ needs.prepare.outputs.source_date_epoch }}
        run: |
          set -euo pipefail
          cargo run -p xtask -- \
            codex-version-metadata \
            --version "$VERSION" \
            --status reported \
            --root cli_manifests/codex

      - name: Validate committed artifacts (hard gate)
        shell: bash
        env:
          SOURCE_DATE_EPOCH: ${{ needs.prepare.outputs.source_date_epoch }}
        run: |
          set -euo pipefail
          cargo run -p xtask -- codex-validate --root cli_manifests/codex

      - name: Generate work queue summary (append to PR body)
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail

          ROOT="cli_manifests/codex"
          REPORT_ANY="${ROOT}/reports/${VERSION}/coverage.any.json"
          test -f "$REPORT_ANY"

          REQUIRED_TARGET="$(jq -r '.union.required_target' "${ROOT}/RULES.json")"
          test -n "$REQUIRED_TARGET" && test "$REQUIRED_TARGET" != "null"

          BASELINE="$(cat "${ROOT}/latest_validated.txt" 2>/dev/null || true)"
          BASELINE="${BASELINE:-unknown}"

          REPORT_REQUIRED="${ROOT}/reports/${VERSION}/coverage.${REQUIRED_TARGET}.json"
          if [[ ! -f "$REPORT_REQUIRED" ]]; then
            REPORT_REQUIRED="$REPORT_ANY"
          fi

          missing_commands="$(jq '.deltas.missing_commands // [] | length' "$REPORT_REQUIRED")"
          missing_commands_help="$(jq '[.deltas.missing_commands // [] | .[] | select((.path | length > 0) and (.path[-1] == "help"))] | length' "$REPORT_REQUIRED")"
          missing_commands_non_help="$(jq '[.deltas.missing_commands // [] | .[] | select((.path | length == 0) or (.path[-1] != "help"))] | length' "$REPORT_REQUIRED")"
          missing_flags="$(jq '.deltas.missing_flags // [] | length' "$REPORT_REQUIRED")"
          missing_flags_root="$(jq '[.deltas.missing_flags // [] | .[] | select(.path | length == 0)] | length' "$REPORT_REQUIRED")"
          missing_flags_non_root="$(jq '[.deltas.missing_flags // [] | .[] | select(.path | length != 0)] | length' "$REPORT_REQUIRED")"
          missing_args="$(jq '.deltas.missing_args // [] | length' "$REPORT_REQUIRED")"
          unsupported="$(jq '.deltas.unsupported // [] | length' "$REPORT_REQUIRED")"
          iu="$(jq '.deltas.intentionally_unsupported // [] | length' "$REPORT_REQUIRED")"
          excluded_commands="$(jq '.deltas.excluded_commands // [] | length' "$REPORT_REQUIRED")"
          excluded_flags="$(jq '.deltas.excluded_flags // [] | length' "$REPORT_REQUIRED")"
          excluded_args="$(jq '.deltas.excluded_args // [] | length' "$REPORT_REQUIRED")"

          {
            echo ""
            echo "## Work Queue Summary (autogenerated)"
            echo ""
            echo "- Version: \`${VERSION}\`"
            echo "- Baseline: \`${BASELINE}\`"
            echo "- Required target: \`${REQUIRED_TARGET}\`"
            echo "- Primary report: \`${REPORT_REQUIRED}\`"
            echo ""
            echo "### Counts (required target)"
            echo ""
            echo "- missing_commands: ${missing_commands} (non-help: ${missing_commands_non_help}, help-only: ${missing_commands_help})"
            echo "- missing_flags: ${missing_flags} (root: ${missing_flags_root}, non-root: ${missing_flags_non_root})"
            echo "- missing_args: ${missing_args}"
            echo "- unsupported: ${unsupported}"
            echo "- intentionally_unsupported (audit-only): ${iu}"
            echo "- excluded_commands/flags/args (audit-only): ${excluded_commands}/${excluded_flags}/${excluded_args}"
            echo ""
            echo "### Notes on inheritance / reporting"
            echo ""
            echo "- **IU subtree inheritance (ADR 0004):** if the wrapper marks a command path as \`intentionally_unsupported\`, all descendant commands/flags/args are treated as IU and appear under \`deltas.intentionally_unsupported\` (not \`missing_*\`). Override by adding an exact wrapper coverage entry."
            echo "- **Global flags model:** some flags are treated as global (root) and are reported at \`path=[]\` to avoid per-command noise; fix root coverage for global flags. If you see the same flag reported missing under many subcommands, confirm whether it is truly global for that version by inspecting \`snapshots/${VERSION}/union.json\`."
            echo ""
            echo "### New/Removed Commands vs Baseline"
            echo ""
          } > _codex_cli_work_queue.md

          BASELINE_UNION="${ROOT}/snapshots/${BASELINE}/union.json"
          VERSION_UNION="${ROOT}/snapshots/${VERSION}/union.json"
          if [[ -f "$BASELINE_UNION" && -f "$VERSION_UNION" ]]; then
            jq -r '.commands[].path | if length==0 then "<root>" else join(" ") end' \
              "$BASELINE_UNION" | sort > /tmp/codex_cmds.baseline.txt
            jq -r '.commands[].path | if length==0 then "<root>" else join(" ") end' \
              "$VERSION_UNION" | sort > /tmp/codex_cmds.new.txt

            {
              echo "- Only in baseline (\`${BASELINE}\`):"
              comm -23 /tmp/codex_cmds.baseline.txt /tmp/codex_cmds.new.txt | head -n 25 | sed -e 's/^[[:space:]]*//' -e 's/^/  - /'
              echo "- Only in new (\`${VERSION}\`):"
              comm -13 /tmp/codex_cmds.baseline.txt /tmp/codex_cmds.new.txt | head -n 25 | sed -e 's/^[[:space:]]*//' -e 's/^/  - /'
              echo ""
            } >> _codex_cli_work_queue.md
          else
            {
              echo "- Baseline union snapshot not available at \`${BASELINE_UNION}\`."
              echo ""
            } >> _codex_cli_work_queue.md
          fi

          {
            echo "### First Missing Commands (non-help)"
            echo ""
            jq -r '[.deltas.missing_commands // [] | .[] | select((.path | length == 0) or (.path[-1] != "help"))] | .[] | (.path | if length==0 then "<root>" else join(" ") end)' \
              "$REPORT_REQUIRED" | head -n 25 | sed 's/^/- /'
            echo ""
            echo "### First Missing Commands (help-only)"
            echo ""
            jq -r '[.deltas.missing_commands // [] | .[] | select((.path | length > 0) and (.path[-1] == "help"))] | .[] | (.path | if length==0 then "<root>" else join(" ") end)' \
              "$REPORT_REQUIRED" | head -n 25 | sed 's/^/- /'
            echo ""
            echo "### First Missing Flags (root)"
            echo ""
            jq -r '[.deltas.missing_flags // [] | .[] | select(.path | length == 0)] | .[] | ((.path | if length==0 then "<root>" else join(" ") end) as $p | "- [" + $p + "] " + .key)' \
              "$REPORT_REQUIRED" | head -n 40
            echo ""
            echo "### First Missing Flags (non-root)"
            echo ""
            jq -r '[.deltas.missing_flags // [] | .[] | select(.path | length != 0)] | .[] | ((.path | if length==0 then "<root>" else join(" ") end) as $p | "- [" + $p + "] " + .key)' \
              "$REPORT_REQUIRED" | head -n 40
            echo ""
            echo "### First Missing Args"
            echo ""
            jq -r '.deltas.missing_args // [] | .[] | ((.path | if length==0 then "<root>" else join(" ") end) as $p | "- [" + $p + "] " + .name)' \
              "$REPORT_REQUIRED" | head -n 25
            echo ""
            echo "Next: open \`${REPORT_REQUIRED}\` and work missing_commands → missing_flags → missing_args."
            echo ""
          } >> _codex_cli_work_queue.md

      - name: Render PR body from template
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          TEMPLATE="cli_manifests/codex/PR_BODY_TEMPLATE.md"
          test -f "$TEMPLATE"
          sed "s/{{VERSION}}/${VERSION}/g" "$TEMPLATE" > _codex_cli_pr_body.md
          test -f _codex_cli_work_queue.md
          cat _codex_cli_work_queue.md >> _codex_cli_pr_body.md

      - name: Upload committed artifact bundle (PR fallback)
        uses: actions/upload-artifact@v4
        with:
          name: "codex-cli-artifacts-${{ inputs.version }}"
          if-no-files-found: error
          path: |
            cli_manifests/codex/snapshots/${{ inputs.version }}/
            cli_manifests/codex/reports/${{ inputs.version }}/
            cli_manifests/codex/versions/${{ inputs.version }}.json
            cli_manifests/codex/wrapper_coverage.json
            cli_manifests/codex/artifacts.lock.json

      - name: Remove CI-only downloads (avoid PR blob commits)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf _download _extract

      - name: Create PR (best effort)
        continue-on-error: true
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.AUTOMATION_TOKEN || github.token }}
          base: staging
          commit-message: "chore: codex cli artifacts for ${{ inputs.version }}"
          title: "chore: codex cli artifacts for ${{ inputs.version }}"
          body-path: _codex_cli_pr_body.md
          branch: "automation/codex-cli-${{ inputs.version }}"
          delete-branch: true
